{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed May 04 2016 09:03:32 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Reversing Malware Command and Control: From Sockets to COM",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "ec057142-3673-4453-a5b7-04a269c654da",
    "author": "Nick Harbour",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "replication-service",
    "focusKeyword": "MANDIANT",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "80b4b44f-2813-4f18-94f9-302766a36ff7"
    ],
    "jcr:created": "Tue Nov 05 2019 18:32:54 GMT+0000",
    "cq:lastReplicated": "Tue Nov 05 2019 18:32:56 GMT+0000",
    "cq:lastModified": "Tue Nov 05 2019 18:32:38 GMT+0000",
    "jcr:baseVersion": "80b4b44f-2813-4f18-94f9-302766a36ff7",
    "jcr:isCheckedOut": true,
    "cq:createdBy": "admin",
    "cq:tags": [
      "fireeye-blog-tags:mandiant",
      "fireeye-blog-authors:cap-nick-harbour",
      "fireeye-blog-threat-research:threat-research"
    ],
    "jcr:uuid": "b399dd3d-46a7-4dd8-b2e1-2f19860e0b35",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Mon Aug 16 2010 11:16:00 GMT-0400",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "admin",
        "text": "\u003Cdiv class=\u0022c00 c00v1\u0022\u003E\u003Cp\u003EOn a Windows host there is more than one way for a program to communicate across the internet.  When reverse engineering a piece of malware it is of critical importance to understand what API is being used and how it works so that you may gain an understanding of the data sent and received as well as command structure and internal protocol if applicable.  The choice of networking API also effects how you craft your indicators (more on this later). I break Windows Malware Command and Control communications into four API categories: Sockets, WinInet, URLMon and COM. The primary focus of this article is COM, since it is the rarest, least understood and most difficult to reverse engineer.\u003C\/p\u003E \u003Cp\u003E\u003Ch4\u003ESockets\u003C\/h4\u003E\u003C\/p\u003E \u003Cp\u003EThe first group, sockets, is the most widely known as it is the same basic networking API found on Unix. It provides a somewhat raw session level access to a TCP or UDP session.  It is provided primarily by the DLL ws2_32.dll, though it has a storied history.  Any application using the socket API must manually craft any higher level protocol such as HTTP.  A socket object is created with a call to the function \u003Cspan style=\u0022color: #0000ff;\u0022\u003Esocket()\u003C\/span\u003E.  It is during this call where the protocol is specified, TCP or UDP.  For a TCP client like most malware backdoors, the function \u003Cspan style=\u0022color: #0000ff;\u0022\u003Econnect()\u003C\/span\u003E must be called, which performs the TCP three-way handshake and paves the way for reading and writing of data.  A server program on the other hand will typically call \u003Cspan style=\u0022color: #0000ff;\u0022\u003Ebind()\u003C\/span\u003E and \u003Cspan style=\u0022color: #0000ff;\u0022\u003Elisten()\u003C\/span\u003E to wait for connections (although \u003Cspan style=\u0022color: #0000ff;\u0022\u003Ebind()\u003C\/span\u003E can also be used client side to force a socket to a specific egress port).  The functions\u003Cspan style=\u0022color: #0000ff;\u0022\u003E send()\u003C\/span\u003E and\u003Cspan style=\u0022color: #0000ff;\u0022\u003E recv()\u003C\/span\u003E are frequently used to transfer data across the wire for TCP connections and \u003Cspan style=\u0022color: #0000ff;\u0022\u003Esendto()\u003C\/span\u003E and \u003Cspan style=\u0022color: #0000ff;\u0022\u003Erecvfrom() \u003C\/span\u003Eare traditionally used for UDP connections.  From a malware analysis perspective this makes things simple, if I need to understand what information a piece of malware is expecting in response to its beacon packet I can typically look for calls to the\u003Cspan style=\u0022color: #0000ff;\u0022\u003E recv()\u003C\/span\u003E function and see how the code that follows inspects the data it reads from the wire.  On Windows though, sockets can be used interchangeably with most operations as if they were a file handle.  For example, a process (like cmd.exe) could be spawned with a network socket specified as its standard input and standard output and that process would automatically communicate across the network.  To learn the socket API in-depth I recommend reading the late W. Richard Stevens\u0027 classic book UNIX Network Programming Volume 1.  The drawback to using the Socket API is that interacting with any higher level protocol such as HTTP must be done so manually.  This allows a lot of flexibility in how the malware crafts its requests but everything must be laid out explicitly.  Malware authors will frequently introduce subtle nuance differences between the way their HTTP traffic looks on the wire and the way most web browsers look.  These small differences make great network signatures!\u003C\/p\u003E \u003Cp\u003E\u003Ch4\u003EWinInet\u003C\/h4\u003E\u003C\/p\u003E \u003Cp\u003EThe WinInet API requires much less work than the socket API.  It is a convenience API which simplifies the interaction to higher level protocols such as HTTP, FTP and even GOPHER!  To begin using the WinInet API to talk to a remote host you first need to call \u003Cspan style=\u0022color: #0000ff;\u0022\u003EInternetOpen()\u003C\/span\u003E followed by \u003Cspan style=\u0022color: #0000ff;\u0022\u003EInternetConnect()\u003C\/span\u003E or \u003Cspan style=\u0022color: #0000ff;\u0022\u003EInternetOpenURL()\u003C\/span\u003E.  Once the internet has been opened and a connection established, to perform and HTTP request you can call the functions \u003Cspan style=\u0022color: #0000ff;\u0022\u003EHttpOpenRequest()\u003C\/span\u003E to make a request handle and \u003Cspan style=\u0022color: #0000ff;\u0022\u003EHttpSendRequest()\u003C\/span\u003E to send the request.  \u003Cspan style=\u0022color: #0000ff;\u0022\u003EInternetReadFile()\u003C\/span\u003E may then be called to read any response from the server.   It can also be used to read data from an FTP session.  The \u003Cspan style=\u0022color: #0000ff;\u0022\u003EInternetWriteFile()\u003C\/span\u003E function can also be used generically in place of any protocol specific function where data needs to be sent across the wire.   The HTTP functions provide the programmer the ability to configure most of the options one would expect in an HTTP request header such as the User-Agent string.  Not all of these values have to be specified though, and the system default will be used if none is specified.  The malware programmer doesn\u0027t have as much flexibility to introduce subtle anomalies in the request structures though like they can with sockets, and left with default settings the malware\u0027s HTTP requests will look virtually identical to legitimate Internet Explorer traffic on the network.\u003C\/p\u003E \u003Cp\u003E\u003Ch4\u003EURLMon\u003C\/h4\u003E\u003C\/p\u003E \u003Cp\u003EThe URL Monikers API provided by the DLL urlmon.dll provides yet another API for performing internet communications.  In the back end it uses COM but I choose to list this as a separate category from the later discussion of COM because using this API is an abstraction away from the ugly, obscure-t0-reverse methods of direct COM interaction.  The most popular function in the URLMon arsenal, from a malware perspective, is the one-punch knockout function \u003Cspan style=\u0022color: #0000ff;\u0022\u003EURLDownloadToFile()\u003C\/span\u003E. Rarely in the Win32 API does one function do so much work.  You provide this function a URL (for any protocol IE understands), a filename and it uses COM to force Internet Explorer to download the resource to the specified filename.  This is very popular with dropper malware which simply needs to download an EXE from a website and launch it.  You might also run into the \u003Cspan style=\u0022color: #0000ff;\u0022\u003EURLDownloadToCacheFile()\u003C\/span\u003E function which will download a specified URL to the browser cache and return the name of the file it downloaded to.  \u003Cspan style=\u0022color: #0000ff;\u0022\u003EURLOpenStream()\u003C\/span\u003E and \u003Cspan style=\u0022color: #0000ff;\u0022\u003EURLOpenPullStream()\u003C\/span\u003E can be used to download a URL to a buffer in memory, but these functions are rarely used in malware.\u003C\/p\u003E \u003Ch3\u003EControlling Internet Explorer with COM\u003C\/h3\u003E\u003Cp\u003EUsing COM for malware command and control has a number of advantages for the malware author.  From a live response\/volatile data\/memory analysis perspective it obscures the source of malicious traffic because all communication with the remote host will be performed within an iexplore.exe process instead of the malware process.  From a reverse engineering perspective it makes things complicated because it is not immediately clear that the malware is doing network communications at all when first inspected with static analysis.  COM has fallen out of fashion with many of today\u0027s programmers and is less understood than many other technologies used in modern software.  Malware analysts may be particularly unfamiliar with the inner workings of COM, depending on the programming background in the Win32 world.\u003C\/p\u003E \u003Cp\u003EBefore any COM object can be instantiated, the function \u003Cspan style=\u0022color: #0000ff;\u0022\u003ECoInitialize()\u003C\/span\u003E must be called to initialize the COM library.  Once this is successfully initialized a call can be made to \u003Cspan style=\u0022color: #0000ff;\u0022\u003ECoCreateInstance()\u003C\/span\u003E to create an instance of a particular COM object, such as Internet Explorer.  In order to understand which object is being instantiated at this point you must inspect the first argument to the \u003Cspan style=\u0022color: #0000ff;\u0022\u003ECoCreateInstance()\u003C\/span\u003E function, which will be a CLSID value which is a unique identifier for a COM object.  Here is the call to \u003Cspan style=\u0022color: #0000ff;\u0022\u003ECoCreateInstance()\u003C\/span\u003E found in a malware sample which used COM:\u003C\/p\u003E \u003Cp\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/cocreateinstance_screen1.png\u0022\u003E\u003Cimg class=\u0022alignnone size-full wp-image-1405\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/cocreateinstance_screen1.png\u0022 alt=\u0022A Call to CoCreateInstance()\u0022 width=\u0022269\u0022 height=\u002272\u0022 \/\u003E\u003C\/a\u003E\u003C\/p\u003E \u003Cp\u003EAt first glance it\u0027s difficult to tell what object this function is instantiating because IDA simply shows you the data type of the first value instead of any type of meaningful interpretation of it.  The first argument in this example code is a global variable (a constant actually) that exists at some location in the binary that has been given the label \u0022rclsid\u0022 by IDA Pro.  If you double click on this first argument IDA Pro will take you to view the variable as it would look in memory:\u003C\/p\u003E \u003Cp\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/rclsid_screen1.png\u0022\u003E\u003Cimg class=\u0022alignnone size-full wp-image-1406\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/rclsid_screen1.png\u0022 alt=\u0022COM CLSID value in memory\u0022 width=\u0022366\u0022 height=\u002272\u0022 \/\u003E\u003C\/a\u003E\u003C\/p\u003E \u003Cp\u003EThis CLSID value is recognized as a data structure by IDA and is shown here broken into its components.  The Human-readable way to represent this CLSID value is \u0022{0002DF01-0000-0000-C000-000000000046}\u0022.  It would be nice if there were an IDA script to automatically name these values, but in the mean time you can look them up manually in the registry.  By opening regedit and browsing to the key \u003Cspan style=\u0022color: #0000ff;\u0022\u003EHKEY_CLASSES_ROOTCLSID\u003C\/span\u003E you can see a rather long list of subkeys, each named with a CLSID value.  By finding the subkey name which matches the hexadecimal values you see in IDA Pro you can identify what the object name is that the program is requesting, which is stored in the default value of the key.  Here is a screen shot of regedit showing the key for the CLSID shown in the example code above:\u003C\/p\u003E \u003Cp\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/regedit_screen1.png\u0022\u003E\u003Cimg class=\u0022alignnone size-full wp-image-1410\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/regedit_screen1.png\u0022 alt=\u0022Regedit Screen showing our CLSID being named InternetExplorer(ver 1.0)\u0022 width=\u0022534\u0022 height=\u0022221\u0022 \/\u003E\u003C\/a\u003E\u003C\/p\u003E \u003Cp\u003ESo it appears that our malware sample is making an instance of the Internet Explorer object!  In order to use any functionality from this object the malware must make use of the last argument to the \u003Cspan style=\u0022color: #0000ff;\u0022\u003ECoCreateInstance()\u003C\/span\u003E function (which was labeled \u0022ppv\u0022).  This parameter is a pointer to pointer to receive a newly allocated data structure containing all the pertinent data for this object, most notably function pointers.  The list of functions available is documented here: \u003Ca href=\u0022http:\/\/msdn.microsoft.com\/en-us\/library\/bb159694.aspx\u0022\u003Ehttp:\/\/msdn.microsoft.com\/en-us\/library\/bb159694.aspx\u003C\/a\u003E.  To see the Internet Explorer object in action from a source code level please take a look at this article: \u003Ca href=\u0022http:\/\/support.microsoft.com\/kb\/167658\u0022\u003Ehttp:\/\/support.microsoft.com\/kb\/167658\u003C\/a\u003E.\u003C\/p\u003E \u003Cp\u003EThe most important function call to this COM object we need to recognize as reverse engineers is the call to the function \u003Cspan style=\u0022color: #0000ff;\u0022\u003ENavigate()\u003C\/span\u003E or \u003Cspan style=\u0022color: #0000ff;\u0022\u003ENavigate2()\u003C\/span\u003E.  This is what actually accomplishes the HTTP request which may also contain POST data or a parametrized GET, and thus transmit data to the remote command and control server. The following screen fragment shows the call to the \u003Cspan style=\u0022color: #0000ff;\u0022\u003ENavigate()\u003C\/span\u003E method of the IE COM object as seen from IDA Pro:\u003C\/p\u003E \u003Cp\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/navigate_call_in_ida_screen1.png\u0022\u003E\u003Cimg class=\u0022alignnone size-full wp-image-1412\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/navigate_call_in_ida_screen1.png\u0022 alt=\u0022Navigate() call in IDA\u0022 width=\u0022192\u0022 height=\u002261\u0022 \/\u003E\u003C\/a\u003E\u003C\/p\u003E \u003Cp\u003EIn this fragment we see the ppv value being accessed, which is what was populated from the call to \u003Cspan style=\u0022color: #0000ff;\u0022\u003ECoCreateInstance()\u003C\/span\u003E.  A function is being called from within this data structure. \u003C\/p\u003E \u003Cp\u003EThis function is at offset 2Ch from the beginning of the ppv data structure, and you can tell that the binary is calling this function because the call instruction accesses this specific offset from the beginning of the structure (\u0022call dword ptr [ecx+\u003Cstrong\u003E2Ch\u003C\/strong\u003E]\u0022).   There is no clear-cut way to go directly from the Microsoft documentation of this COM interface to seeing the actually internal offset used by each member function, so I made a small test application to simply reference each function.  I then disassembled my test application and could see the clear mapping of offsets to member functions.  The following table is a mapping of the commonly used member functions (by malware specifically) and their associated offsets as seen in a call instruction:\u003C\/p\u003E \u003Cp\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/function_table2.png\u0022\u003E\u003Cimg class=\u0022alignnone size-full wp-image-1417\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/function_table2.png\u0022 alt=\u0022\u0022 width=\u0022189\u0022 height=\u0022171\u0022 \/\u003E\u003C\/a\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ch4\u003EFinal Thoughts\u003C\/h4\u003E\u003C\/p\u003E \u003Cp\u003EMy goal with this article was to make more malware analysts and incident responders aware of the spectrum of communication techniques available to malware authors and to make analysts recognize and be able to begin reverse engineering the COM technique specifically.  There is certainly a need for more tools and techniques in this area but it all begins with awareness and understanding.  One thing to take away from this is that as a malware analyst it is not enough to simply know assembly language.  You must gain a working knowledge of the APIs and you must be rigorous, if not downright tenacious, in your appetite to learn new facets of the APIs as you encounter them.  If a malware analyst disregards calls such as CoCreateInstance() without deeper inspection due to their lack of understanding of it, they potentially will miss a critically important component of the malware\u0027s operation.\u003C\/p\u003E \u003C\/div\u003E",
        "jcr:lastModified": "Mon Aug 16 2010 10:16:21 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "admin",
      "text": "\u003Cp\u003EOn a Windows host there is more than one way for a program to communicate across the internet.  When reverse engineering a piece of malware it is of critical importance to understand what API is being used and how it works so that you may gain an understanding of the data sent and received as well as command structure and internal protocol if applicable.  The choice of networking API also effects how you craft your indicators (more on this later). I break Windows Malware Command and Control communications into four API categories: Sockets, WinInet, URLMon and COM. The primary focus of this article is COM, since it is the rarest, least understood and most difficult to reverse engineer.\u003C\/p\u003E ",
      "jcr:lastModified": "Mon Aug 16 2010 10:16:21 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Tue Nov 05 2019 18:32:38 GMT+0000",
      "imageRotate": "0"
    }
  }
}
