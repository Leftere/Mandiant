{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed Feb 17 2021 15:00:43 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Shining a Light on SolarCity: Practical Exploitation of the X2e IoT Device (Part Two)",
    "jcr:versionHistory": "65d1b2dd-9ddd-4561-96bf-1940c2f6c82c",
    "author": "Jake Valletta",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "a7164f33-d8d9-41d6-98d1-d0318128242b"
    ],
    "jcr:created": "Thu Feb 18 2021 19:00:47 GMT+0000",
    "cq:lastModified": "Thu Feb 18 2021 19:00:30 GMT+0000",
    "jcr:baseVersion": "a7164f33-d8d9-41d6-98d1-d0318128242b",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:jake-valetta",
      "fireeye-blog-authors:sam-sabetan",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:vulnerabilities",
      "fireeye-blog-tags:red-team",
      "fireeye-blog-tags:internet-of-things",
      "fireeye-blog-tags:iot"
    ],
    "jcr:uuid": "359f4481-4bbd-497d-87fc-2b61a914a091",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Wed Feb 17 2021 08:00:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EIn this post, we continue our analysis of the \u003Ca href=\u0022http:\/\/cms.digi.com\/resources\/documentation\/digidocs\/90001537\/references\/r_connectport_x2e.htm\u0022\u003ESolarCity ConnectPort X2e\u003C\/a\u003E Zigbee device (referred to throughout as X2e device). In \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2021\/02\/solarcity-exploitation-of-x2e-iot-device-part-one.html\u0022\u003EPart One\u003C\/a\u003E, we discussed the X2e at a high level, performed initial network-based attacks, then discussed the hardware techniques used to gain a remote shell on the X2e device as a non-privileged system user. In this segment, we\u2019ll cover how we obtained a privileged shell on the device locally using power glitching attacks, and explore \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/nvd.nist.gov\/vuln\/detail\/CVE-2020-12878\u0022\u003ECVE-2020-12878\u003C\/a\u003E, a vulnerability we discovered that permitted remote privilege escalation to the \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E user. Combined with \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/nvd.nist.gov\/vuln\/detail\/CVE-2020-9306\u0022\u003ECVE-2020-9306\u003C\/a\u003E (discussed in Part One), this would result in a complete remote compromise of the X2e device.\u003C\/p\u003E\n\u003Ch4\u003ETechnical Analysis\u003C\/h4\u003E\n\u003Ch5\u003ERecap\u003C\/h5\u003E\n\u003Cp\u003EBefore we dive into next steps, let\u2019s recap where we left off:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EThe X2e has an exposed universal asynchronous transmit\/receive (UART) interface, which allows a physically connected user to view (but not interrupt) the Das U-Boot (U-Boot) boot process, and given proper credentials, authenticate to the Linux operating system. Since we do not have \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E credentials, we put this thread on the backburner.\u003C\/li\u003E\n\u003Cli\u003EWe have a full NAND dump of the Spansion raw flash, which includes boot configuration, bootloader firmware, filesystems, and the Linux kernel image. This was used previously in Part One to obtain the hardcoded credential for the \u003Cspan class=\u0022code\u0022\u003Epython\u003C\/span\u003E user.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EKnowing that UART is present and access to the bootloader would be extremely valuable, we decided to revisit that thread.\u003C\/p\u003E\n\u003Ch4\u003EGaining Privileged Access Locally\u003C\/h4\u003E\n\u003Ch5\u003ERevisiting the Bootloader\u003C\/h5\u003E\n\u003Cp\u003EFigure 1 shows the U-Boot boot process displayed while connected via UART connection. In some cases, it is possible to send keyboard input to the device during a set period (usually one to four seconds) when the bootloader presents the message, \u201cHit any key to stop autoboot,\u201d which interrupts the boot process and drops the user into a U-Boot shell. On the X2e, this feature has been disabled by setting the U-Boot configuration parameter \u003Ca href=\u0022https:\/\/lists.denx.de\/pipermail\/u-boot\/2015-October\/229631.html\u0022\u003E\u003Cspan class=\u0022code\u0022\u003ECONFIG_BOOTDELAY\u003C\/span\u003E to \u003Cspan class=\u0022code\u0022\u003E0\u003C\/span\u003E\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Uninterruptable U-Boot bootloader output\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOne attack that has been documented to be successful to disrupt autoboot is to manipulate the bootloader\u2019s ability to access the flash storage during the boot process. In certain circumstances where the U-Boot bootloader is unable to access its own configuration, it fails into a default environment, which may be less restricted. We decided to see if this would be possible on the X2e.\u003C\/p\u003E\n\u003Cp\u003EThese attacks, known as glitch attacks (or more officially known as fault-injection), are a type of side channel attack that attempts to cause a microcontroller unit (MCU) to skip instructions, perform wrong instructions, or fail to access \u003Ca href=\u0022https:\/\/blog.nviso.eu\/2020\/02\/21\/iot-hacking-field-notes-1-intro-to-glitching-attacks\/\u0022\u003Eflash memory\u003C\/a\u003E. Various types of glitching attacks exist including electrical, thermal, and radiation. Based on our objective, we opted to try glitching the power between the MCU and the Spansion NAND flash. Note that glitch attacks can often cause damage to the components on a board or put the device in an unusable state. These types of attacks should be tested as either a last resort or against a secondary device you are comfortable with damaging.\u003C\/p\u003E\n\u003Ch5\u003EGlitching the Bootloader\u003C\/h5\u003E\n\u003Cp\u003EBased on previous research in \u003Ca href=\u0022https:\/\/www.brettlischalk.com\/posts\/nand-glitching-wink-hub-for-root\u0022\u003Ethis domain\u003C\/a\u003E, we opted to target the data lines (I\/O) between the MCU and NAND flash. Recall from Part One that the NAND flash on the X2e was the Spansion S34ML01G1, which was a 63-pin ball grid array (BGA) package. This chip is capable of supporting both 8-bit and 16-bit bus width, which corresponds to the number of I\/O lines utilized. By using the \u003Ca href=\u0022https:\/\/datasheetspdf.com\/datasheet\/S34ML01G1.html\u0022\u003Edatasheet for the flash\u003C\/a\u003E and then querying the ONFI Device ID of our chip, we determined our chip was utilizing the 8-bit configuration, meaning eight I\/O lines were present between the NAND flash and the MCU. For this attack, we focused on manipulating the power on the first (\u003Cspan class=\u0022code\u0022\u003EI\/O0\u003C\/span\u003E) data line. Figure 2 shows the configuration of the BGA-63 pins, with \u003Cspan class=\u0022code\u0022\u003EI\/O0\u003C\/span\u003E highlighted.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Identifying I\/O0 for NAND chip in the Spansion datasheet\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBecause the pins are actually underneath the flash package, we needed to find an exposed lead that corresponded to \u003Cspan class=\u0022code\u0022\u003EI\/O0\u003C\/span\u003E elsewhere on the PCB. One such method for tracing connections across a PCB is a continuity test. A continuity test (using a multimeter) sends a low current electrical signal across two points and produces an audible beep if the points are connected. Using this technique, we located an exposed test point (known as a via) on the bottom of the PCB. Figure 3 shows the \u003Cspan class=\u0022code\u0022\u003EI\/O0\u003C\/span\u003E pin on the top of the PCB (under the NAND chip), and Figure 4 shows the \u003Cspan class=\u0022code\u0022\u003EI\/O0\u003C\/span\u003E pin exposed on the bottom of the PCB.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: I\/O0 on top of PCB (under NAND chip)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig4.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: I\/O0 on bottom of PCB\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWith exposed access to \u003Cspan class=\u0022code\u0022\u003EI\/O0\u003C\/span\u003E located, we experimented with connecting this pin directly to a known ground (\u003Cspan class=\u0022code\u0022\u003EGND\u003C\/span\u003E) pin at various points during the boot process. Figure 5 shows the device powering on with the metal tweezers connecting \u003Cspan class=\u0022code\u0022\u003EI\/O0\u003C\/span\u003E to \u003Cspan class=\u0022code\u0022\u003EGND\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig5.jpg\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Shorting I\/O0 to GND\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWhile connected to the UART interface, we noted several different outcomes. When shorting the pin immediately after powering on, the device failed to produce any output or boot. When shorting after the bootloader finished loading (and handing off to the Linux kernel), the device would also force reboot. However, when timed perfectly between the bootloader loading and attempting to read its configuration, we noted that the bootloader would present different output, and the option to interrupt the boot process was possible with a four-second delay. By pressing keyboard input, we were successfully able to drop into a U-Boot shell, which is shown in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig6.jpg\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Access to U-Boot bootloader shell\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWhile this was great progress, we noted that the current failback bootloader configuration was completely inoperable and certain NAND blocks had been marked as bad (as expected). To get our device back to a working state, we needed to revisit the NAND dump we generated in Part One.\u003C\/p\u003E\n\u003Ch5\u003ERepairing the Bootloader Configuration\u003C\/h5\u003E\n\u003Cp\u003EWhile the current configuration provided us a working shell, we needed to fix the damage we had done. This was performed in two steps: fixing the mistakenly marked bad blocks and then rebuilding the configuration. In our case, the \u003Cspan class=\u0022code\u0022\u003Enand\u003C\/span\u003E utility and its sub-commands \u003Cspan class=\u0022code\u0022\u003Eread\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003Ewrite\u003C\/span\u003E, and \u003Cspan class=\u0022code\u0022\u003Escrub\u003C\/span\u003E allowed us to inspect and manipulate pages and blocks of the NAND. The \u003Cspan class=\u0022code\u0022\u003Enand scrub\u003C\/span\u003E command with a valid offset and size could be used to completely reset a segment of the NAND, which removed any bad block markers. The next challenge was determining what needed to be replaced in the damaged blocks and rebuilding the configuration.\u003C\/p\u003E\n\u003Cp\u003ESince we had a valid NAND image, we revisited the sections read by the bootloader to determine what changes were needed. The format did not match a known format, so we wrote a simple parser in Python to read the binary structure, shown in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Parsing bootloader nvram configuration from flash\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWith details of how the configuration should look, we used the \u003Cspan class=\u0022code\u0022\u003Enand write\u003C\/span\u003E to rebuild this section, byte by byte with the correct details. We also set the boot delay to be four seconds, so that we could always interrupt the bootloader once the new configuration was committed. Once we confirmed our changes were stable, we saved the configuration to flash and could access the bootloader without performing the aforementioned glitch attack.\u003C\/p\u003E\n\u003Ch5\u003EAccessing Linux as root User\u003C\/h5\u003E\n\u003Cp\u003ENow that we have unrestricted access to the bootloader, we can finally influence the rest of the boot process and achieve a privileged shell. We alluded to this in Part One, but the easiest way to turn an unlocked U-Boot shell into a \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E Linux shell is to adjust the boot arguments that U-Boot passes to the Linux kernel. In our case, this was accomplished by using the \u003Cspan class=\u0022code\u0022\u003Esetenv\u003C\/span\u003E utility to change the \u003Cspan class=\u0022code\u0022\u003Estd_bootarg\u003C\/span\u003E environment variable to be \u003Cspan class=\u0022code\u0022\u003Einit=\/bin\/sh\u003C\/span\u003E and instructing U-Boot to resume the standard boot process. Figure 8 shows the Linux shell presented over UART.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig8.jpg\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: root shell after bootloader\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAt this point, we\u2019ve demonstrated a repeatable method for achieving local privilege escalation. In the final segment, we\u2019ll complete our attack by exploring an avenue to remotely escalate privileges.\u003C\/p\u003E\n\u003Ch5\u003EGaining Privileged Access Remotely\u003C\/h5\u003E\n\u003Cp\u003ESince the X2e has only two available listening network services, it makes sense to reinvestigate these services. During Part One, we identified hardcoded credentials for the limited user \u003Cspan class=\u0022code\u0022\u003Epython\u003C\/span\u003E. This was useful for initial probing of the device while it was running, but where do we go from here?\u003C\/p\u003E\n\u003Cp\u003EEmbedded devices typically only have a handful of users, with a majority of functionality being performed by the \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E user. This presents an interesting opportunity for us to abuse overlap between actions performed by the \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E user on contents owned and controlled by the \u003Cspan class=\u0022code\u0022\u003Epython\u003C\/span\u003E user.\u003C\/p\u003E\n\u003Cp\u003EBy reviewing the boot process, we noted a large number of custom \u003Cspan class=\u0022code\u0022\u003Einit\u003C\/span\u003E scripts in the \u003Cspan class=\u0022code\u0022\u003E\/etc\/init.d\/\u003C\/span\u003E directory. These scripts are executed at system start by the \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E user and were responsible for starting daemons and ensuring directories or files exist. One file in particular, \u003Cspan class=\u0022code\u0022\u003E\/etc\/init.d\/S50dropbear.sh\u003C\/span\u003E, was interesting to us, as it appeared to perform a number of actions on files within the directory specified by the \u003Cspan class=\u0022code\u0022\u003E$PYTHON_HOME\u003C\/span\u003E variable, which was \u003Cspan class=\u0022code\u0022\u003E\/WEB\/python\/\u003C\/span\u003E, shown in Figure 9.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig9.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Unsafe operations on $PYTHON_HOME directory\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAt first glance this may seem benign but considering that the \u003Cspan class=\u0022code\u0022\u003E\/WEB\/python\/\u003C\/span\u003E directory is controllable by the \u003Cspan class=\u0022code\u0022\u003Epython\u003C\/span\u003E user, it means that we can potentially control actions taken by \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E. More specifically, the \u003Cspan class=\u0022code\u0022\u003Echown\u003C\/span\u003E operation is dangerous, as the previous \u003Cspan class=\u0022code\u0022\u003Emkdir\u003C\/span\u003E command can fail silently and result in an unsafe \u003Cspan class=\u0022code\u0022\u003Echown\u003C\/span\u003E operation. To weaponize this, we can use symbolic links to point the \u003Cspan class=\u0022code\u0022\u003E\/WEB\/python\/.ssh\/\u003C\/span\u003E to other areas of the filesystem and coerce the \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E process into \u003Cspan class=\u0022code\u0022\u003Echown\u003C\/span\u003E\u2019ing these files to be owned by the \u003Cspan class=\u0022code\u0022\u003Epython\u003C\/span\u003E user. The process we took to exploit this was as follows:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EAuthenticate over SSH using hardcoded \u003Cspan class=\u0022code\u0022\u003Epython\u003C\/span\u003E user credentials.\u003C\/li\u003E\n\u003Cli\u003ECreate a symbolic link, \u003Cspan class=\u0022code\u0022\u003E\/WEB\/python\/.ssh\u003C\/span\u003E, that points to \u003Cspan class=\u0022code\u0022\u003E\/etc\/init.d\/\u003C\/span\u003E.\u003C\/li\u003E\n\u003Cli\u003EReboot the X2e, forcing the system to re-execute \u003Cspan class=\u0022code\u0022\u003E\/etc\/init.d\/S50dropbear.sh\u003C\/span\u003E.\u003C\/li\u003E\n\u003Cli\u003EAfter boot completes, create a malicious \u003Cspan class=\u0022code\u0022\u003Einit\u003C\/span\u003E script in \u003Cspan class=\u0022code\u0022\u003E\/etc\/init.d\/\u003C\/span\u003E as the \u003Cspan class=\u0022code\u0022\u003Epython\u003C\/span\u003E user.\u003C\/li\u003E\n\u003Cli\u003EReboot the X2e, forcing the system to execute the new \u003Cspan class=\u0022code\u0022\u003Einit\u003C\/span\u003E script.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EWhile not the cleanest approach (it requires two reboots), it accomplishes the goal of achieving code execution as \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E. Figure 10 shows the output of our proof of concept. In this case, our malicious \u003Cspan class=\u0022code\u0022\u003Einit\u003C\/span\u003E script spawned a bind shell on TCP port 8080, so that we could connect in as \u003Cspan class=\u0022code\u0022\u003Eroot\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solarcity2\/2fig10.jpg\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Exploiting chown vulnerability to gain shell as user root\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAnd there we have it: a remote connection as root, by abusing two separate vulnerabilities. While not explored in this series, another viable avenue of attack would be to explore potential vulnerabilities in the web server listening on TCP ports 80 and 443; however, this was not an approach that we took.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EWe covered a wide variety of topics in this two-part series, including:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EPhysical device inspection\u003C\/li\u003E\n\u003Cli\u003EIdentifying and exploring physical debugging interfaces (UART)\u003C\/li\u003E\n\u003Cli\u003EChip-off techniques to remove the NAND storage\u003C\/li\u003E\n\u003Cli\u003EBinary analysis of the filesystems and bootloader configurations\u003C\/li\u003E\n\u003Cli\u003EPower glitch attacks against the U-Boot bootloader\u003C\/li\u003E\n\u003Cli\u003ELinux user space privilege escalation\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EWe hope that readers were able to learn from our experiences with the X2e and will be inspired to use these techniques in their own analysis. Finally, Mandiant would like to thank both Tesla\/SolarCity and Digi International for their efforts to remediate these vulnerabilities and for their cooperation with releasing this blog series.\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Feb 18 2021 19:00:30 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EMandiant\u2019s Red Team discovered a series of vulnerabilities present within Digi International\u2019s ConnectPort X2e\u0026nbsp;device, which allows for remote code execution as a privileged user.\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Feb 11 2021 20:09:20 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Feb 11 2021 20:11:33 GMT+0000",
      "imageRotate": "0"
    }
  }
}
