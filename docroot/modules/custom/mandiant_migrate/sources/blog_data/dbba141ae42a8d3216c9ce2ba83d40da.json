{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Thu Oct 10 2019 17:59:56 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Staying Hidden on the Endpoint: Evading Detection with Shellcode",
    "jcr:versionHistory": "19788db1-eb47-4934-9e7b-3b7b20b5cc86",
    "author": "Evan Pena",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "58c62d69-c768-4eb7-a846-a8ce5e448967"
    ],
    "jcr:created": "Thu Oct 10 2019 20:15:25 GMT+0000",
    "cq:lastModified": "Thu Oct 10 2019 20:15:16 GMT+0000",
    "jcr:baseVersion": "58c62d69-c768-4eb7-a846-a8ce5e448967",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:evan-pena",
      "fireeye-blog-authors:casey-erikson",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:endpoint",
      "fireeye-blog-tags:edr",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:shellcode",
      "fireeye-blog-tags:red-team"
    ],
    "jcr:uuid": "6a37b1cf-6c4c-4011-ac87-b401bd69aad9",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Oct 10 2019 14:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003ETrue red team assessments require a secondary objective of avoiding detection. Part of the glory of a successful red team assessment is not getting detected by anything or anyone on the system. As modern Endpoint Detection and Response (EDR) products have matured over the years, the red teams must follow suit. This blog post will provide some insights into how the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.fireeye.com\/services\/red-team-assessments.html\u0022\u003EFireEye Mandiant Red Team\u003C\/a\u003E crafts payloads to bypass modern EDR products and get full command and control (C2) on their victims\u2019 systems.\u003C\/p\u003E\n\u003Cp\u003EShellcode injection or its execution is our favorite method for launching our C2 payload on a victim system; but what is shellcode? Michael Sikorski defines shellcode as a \u201c\u2026term commonly used to describe any piece of self-contained executable code\u201d (Practical Malware Analysis). Most commercial Penetration Testing Frameworks such as Empire, Cobalt Strike, or Metasploit have a shellcode generator built into the tool. The shellcode generator is generally in either a binary format or hex format depending on whether you generate it as raw output or as an application source.\u003C\/p\u003E\n\u003Cp\u003EWhy do we use shellcode for all our payloads?\u003C\/p\u003E\n\u003Cp\u003EThe use of shellcode in our red team assessment payloads allows us to be incredibly flexible in the type of payload we use. Shellcode runners can be in written in a wide range of programming languages that can be incorporated into many types of payloads. This flexibility allows us to customize our payloads to support the specific needs of our clients and of any given situation that may arise during a red team assessment. Since shellcode can be launched from inside a payload or injected into an already running process, we can use several techniques to increase the ability of our payloads to evade detection from EDR products depending on the scenario and technology in place in the target environment. Several techniques exist for obfuscating shellcode, such as encryption and custom encoding, that make it difficult for EDR products to detect shellcode from commercial C2 tools on its own. The flexibility and evasive properties of shellcode are the primary reason that we rely heavily on shellcode based payloads during red team assessments.\u003C\/p\u003E\n\u003Ch4\u003EShellcode Injection Vs. Execution\u003C\/h4\u003E\n\u003Cp\u003EOne of the most crucial parts of any red team assessment is developing a payload that will successfully, reliably, and stealthily run on the target system. Payloads can either execute shellcode from within its own process or inject shellcode into the address space of another process that will ultimately execute the shellcode. For the purposes of this blog post we\u2019ll refer to shellcode injection as shellcode executed inside a remote process and shellcode execution as shellcode executed inside the payload process.\u003C\/p\u003E\n\u003Cp\u003EShellcode injection is one technique that red teams and malicious attackers use to avoid detection from EDR products and network defenders. Additionally, many EDR products implement detections based on expected behavior of windows processes. For example, an attacker that executes Mimikatz from the context of an arbitrary process, let\u2019s say DefinitelyNotEvil.exe, may get detected or blocked outright because the EDR tool does not expect that process to access lsass.exe. However, by injecting into a windows process, such as svchost.exe, that regularly touches lsass.exe, it may be possible to bypass these detections because the EDR product sees this as an expected behavior.\u003C\/p\u003E\n\u003Cp\u003EIn this blog post, we\u2019ll cover three different techniques for running shellcode.\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003ECreateThread\u003C\/li\u003E\n\u003Cli\u003ECreateRemoteThread\u003C\/li\u003E\n\u003Cli\u003EQueueUserAPC\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EEach of these techniques corresponds to a Windows API function that is responsible for the allocation of a thread to the shellcode, ultimately resulting in the shellcode being run. CreateThread is a technique used for shellcode execution while CreateRemoteThread and QueueUserAPC are forms of shellcode injection.\u003C\/p\u003E\n\u003Cp\u003EThe following is a high-level outline of the process for running shellcode with each of the three different techniques.\u003C\/p\u003E\n\u003Ch5\u003ECreateThread\u003C\/h5\u003E\n\u003Col\u003E\n\u003Cli\u003EAllocate memory in the current process\u003C\/li\u003E\n\u003Cli\u003ECopy shellcode into the allocated memory\u003C\/li\u003E\n\u003Cli\u003EModify the protections of the newly allocated memory to allow execution of code from within that memory space\u003C\/li\u003E\n\u003Cli\u003ECreate a thread with the base address of the allocated memory segment\u003C\/li\u003E\n\u003Cli\u003EWait on the thread handle to return\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch5\u003ECreateRemoteThread\u003C\/h5\u003E\n\u003Col\u003E\n\u003Cli\u003EGet the process ID of the process to inject into\u003C\/li\u003E\n\u003Cli\u003EOpen the target process\u003C\/li\u003E\n\u003Cli\u003EAllocate executable memory within the target process\u003C\/li\u003E\n\u003Cli\u003EWrite shellcode into the allocated memory\u003C\/li\u003E\n\u003Cli\u003ECreate a thread in the remote process with the start address of the allocated memory segment\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture1a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 1: Windows API calls for CreateRemoteThread injection\u003C\/span\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003EQueueUserAPC\u003C\/h5\u003E\n\u003Col\u003E\n\u003Cli\u003EGet the process ID of the process to inject into\u003C\/li\u003E\n\u003Cli\u003EOpen the target process\u003C\/li\u003E\n\u003Cli\u003EAllocate memory within the target process\u003C\/li\u003E\n\u003Cli\u003EWrite shellcode into the allocated memory\u003C\/li\u003E\n\u003Cli\u003EModify the protections of the newly allocated memory to allow execution of code from within that memory space\u003C\/li\u003E\n\u003Cli\u003EOpen a thread in the remote process with the start address of the allocated memory segment\u003C\/li\u003E\n\u003Cli\u003ESubmit thread to queue for execution when it enters an \u201calertable\u201d state\u003C\/li\u003E\n\u003Cli\u003EResume thread to enter \u201calertable\u201d state\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture2a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 2: Windows API calls for QueueUserAPC injection\u003C\/span\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ECommand Execution\u003C\/h4\u003E\n\u003Cp\u003ELet\u2019s break down what we\u2019ve talked about so far:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EMalicious code is your shellcode \u2013 the stage 0 or stage 1 code that is truly going to do the malicious work.\u003C\/li\u003E\n\u003Cli\u003EStandard \u201cshellcode runner\u201d application which executes your code via either injection or execution. Most everyone writes their own shellcode runner, so we don\u2019t necessarily deem this as true malware, the real malware is the shellcode itself.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003ENow that we\u2019ve covered all that, we need a method to execute the code you compiled. Generally, this is either an executable (EXE) or a Dynamic Link Library (DLL). The Red Team prefers using \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/LOLBAS-Project\/LOLBAS\u0022\u003ELiving Off the Land Binaries (lolbins)\u003C\/a\u003E\u0026nbsp;\u003Cb\u003Ecommands\u003C\/b\u003E which will execute our compiled \u003Cb\u003Ecode\u003C\/b\u003E.\u003C\/p\u003E\n\u003Cp\u003EThe reason we can take advantage of lolbins is because of unmanaged exports. At a high level, when an executable calls a DLL it is looking for a specific export within the DLL to execute the code within that export. If the export is not properly protected, then you can craft your own DLL with the export name you know the executable is looking for and run your arbitrary code; which in this case will be your shellcode runner.\u003C\/p\u003E\n\u003Ch4\u003EPutting It All Together\u003C\/h4\u003E\n\u003Cp\u003EWe set out to develop a shellcode runner DLL that takes advantage of lolbins through unmanaged exports while also providing the flexibility to execute both injected and non-injected shellcode without a need to update the code base. This effort resulted in a C# shellcode runner called \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/DueDLLigence\u0022\u003EDueDLLigence\u003C\/a\u003E, for which the source code can be found at the GitHub page.\u003C\/p\u003E\n\u003Cp\u003EThe \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/DueDLLigence\u0022\u003EDueDLLigence\u003C\/a\u003E project provides a quick and easy way to switch between different shellcode techniques described previously in this blog post by simply switching out the value of the global variable shown in Figure 3.\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture3a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 3: Shellcode technique variable\u003C\/span\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe DueDLLigence DLL contains three unmanaged exports inside of it. These exports can be used with the \u003Cspan class=\u0022code\u0022\u003ERasautou\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003EControl\u003C\/span\u003E, and \u003Cspan class=\u0022code\u0022\u003ECoregen\u003C\/span\u003E native Windows commands as described in Figure 4. Note: The shellcode that is in the example will only pop calc.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022208\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ENative Windows Executable\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022158\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ERequired Export Name\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ESyntax Used To Run\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022208\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ERasautou\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022158\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EPowershell\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Erasautou \u2013d {full path to dll} \u2013p powershell \u2013a a \u2013e e\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022208\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EControl\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022158\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ECplapplet\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ERename compiled \u201cdll\u201d extension to \u201ccpl\u201d and just double click it!\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022208\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EMSIExec\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022158\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EDllunregisterserver\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Emsiexec \/z {full path to dll}\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: DueDLLigence execution outline\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWhen you open the source code you will find the example uses the exports shown in Figure 5.\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture5a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 5: Source code for exported entry points\u003C\/span\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe first thing you should do is generate your own shellcode. An example of this is shown in Figure 6, where we use Cobalt Strike to generate raw shellcode for the \u201crev_dns\u201d listener. Once that is complete, we run the \u003Cspan class=\u0022code\u0022\u003Ebase64 -w0 payload.bin \u0026gt; [outputFileName]\u003C\/span\u003E command in Linux to generate the base64 encoded version of the shellcode as shown in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture6a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 6: Shellcode generation\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture7a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 7: Converting shellcode to base64\u003C\/span\u003E\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThen you simply replace the base64 encoded shellcode on line 58 with the base64\u0027d version of your own x86 or x64 shellcode. The screenshot in Figure 6 generated an x86 payload, you will need to check the \u201cuse x64 payload\u201d box to generate an x64 payload.\u003C\/p\u003E\n\u003Cp\u003EAt this point you should reinstall the Unmanaged exports library in the DueDLLigence Visual Studio project because sometimes when you\u2019re using a different project it doesn\u2019t work properly. You can reinstall opening the NuGet package manager console shown in Figure 8 and running the \u003Cspan class=\u0022code\u0022\u003EInstall-Package UnmanagedExports -Version 1.2.7 command\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture8a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 8: Open NuGet Package Manager\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAfter you have reinstalled the Unmanaged exports library and replaced the base64 encoded shellcode on line 58 then you are ready to compile! Go ahead and build the source and look for your DLL in the bin folder. We strongly suggest that you test your DLL to ensure it has the proper exports associate with it. Visual Studio Pro comes with the Dumpbin.exe utility which you can run against your DLL to view the exports as shown in Figure 9.\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture9a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 9: Dumpbin.exe output\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EYou can expand the list as much as you want with \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/LOLBAS-Project\/LOLBAS\u0022\u003Emore lolbin techniques\u003C\/a\u003E\u0026nbsp;found over at the GitHub page.\u003C\/p\u003E\n\u003Cp\u003EWe prefer to remove the unmanaged exports that are not going to be used with the respective payload that was generated so there is a smaller footprint in the payload. In general, this is good tradecraft when crafting payloads or writing code. In our industry we have the principle of least privilege, well this is the principle of least code!\u003C\/p\u003E\n\u003Ch4\u003EModern Detections for Shellcode Injection\u003C\/h4\u003E\n\u003Cp\u003EDespite all the evasive advantages that shellcode offers, there is hope when it comes to detecting shellcode injection. We looked at several different methods for process injection.\u003C\/p\u003E\n\u003Cp\u003EIn our shellcode runner, the shellcode injection techniques (CreateRemoteThread and QueueUserAPC) spawn a process in a suspended state and then inject shellcode into the running process. Let\u2019s say we choose the process to inject into as explorer.exe and our payload will run with MSIExec. This will create a process tree where cmd.exe will spawn msiexec.exe which will in turn spawn explorer.exe.\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture10a.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 10: Process tree analysis\u003C\/span\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn an enterprise environment it is possible to collect telemetry data with a SIEM to determine how often, across all endpoints, the cmd.exe -\u0026gt; msiexec.exe -\u0026gt; explorer.exe process tree occurs. Using parent-child process relationships, defenders can identify potential malware through anomaly detection.\u003C\/p\u003E\n\u003Cp\u003EAPI hooking is commonly used by EDR and AV products to monitor and for detect the use of Windows API calls that are commonly used by malware authors. Utilizing kernel routines such as PsSetCreateProcessNotifyRoutine(Ex) and PsSetCreateThreadNotifyRoutine(Ex), security software can monitor when certain API calls are used, such as CreateRemoteThread. Combining this information with other data such as process reputation and enterprise-wide telemetry can be used to provide high fidelity alerts for potential malware.\u003C\/p\u003E\n\u003Cp\u003EWhen process injection occurs, one process modifies the memory protections of a memory region in another process\u2019s address space. By detecting the use of API calls such as VirtualProtectEx that result in one process modifying the memory protections of address space allowed to another process, especially when the PAGE_EXECUTE_READWRITE permissions are used as this permission is used to allow the shellcode to be written and executed within the same memory space.\u003C\/p\u003E\n\u003Cp\u003EAs red teamers and malicious actors continue to develop new process injection techniques, network defenders and security software continue to adapt to the ever-changing landscape. Monitoring Windows API function calls such as VirtualAllocEx, VirtualProtectEx, CreateRemoteThread, and NTQueueAPCThread can provide valuable data for identifying potential malware. Monitoring for the use of CreateProcess with the CREATE_SUSPENDED and CREATE_HIDDEN flags may assist in detecting process injection where the attacker creates a suspended and hidden process to inject into.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/stayinghidden\/Picture11a.png\u0022 alt=\u0022\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003EAs we\u2019ve seen, process injection techniques tend to follow a consistent order in which they call Windows API functions. For example, both injection techniques call VirtualAllocEx followed by WriteProcessMemory and identifying when a process calls these two APIs in that order can be used as a basis for detecting process injection.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EUsing shellcode as the final stage for payloads during assessments allows Red Teams the flexibility to execute payloads in a wide array of environments while implementing techniques to avoid detection. The \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/DueDLLigence\u0022\u003EDueDLLigence shellcode runner is a dynamic tool\u003C\/a\u003E that takes advantage of the evasive properties of both shellcode and process injection to offer Red Teams a way to avoid detection. Detections for the execution of LOLbins on the command line and process injection at the API and process level should be incorporated into defensive methodology, as attackers are increasingly being forced into living off the land with the increased adoption of application whitelisting.\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Oct 10 2019 20:15:16 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003ELearn how the FireEye Mandiant Red Team bypasses Endpoint Detection and Response products.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Oct 07 2019 22:55:49 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Oct 10 2019 16:27:27 GMT+0000",
      "imageRotate": "0"
    }
  }
}
