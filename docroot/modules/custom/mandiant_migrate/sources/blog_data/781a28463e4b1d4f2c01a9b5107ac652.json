{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed Nov 04 2020 18:59:53 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "In Wild Critical Buffer Overflow Vulnerability in Solaris Can Allow Remote Takeover \u2014 CVE-2020-14871",
    "jcr:versionHistory": "05d680d0-e07b-40cd-a4f4-7e8bb64e75c4",
    "author": "Jacob Thompson",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "9b8b4a60-9bc5-47c6-b235-2c917f7a55e9"
    ],
    "jcr:created": "Wed Nov 04 2020 18:59:53 GMT+0000",
    "cq:lastModified": "Wed Nov 04 2020 18:59:46 GMT+0000",
    "jcr:baseVersion": "9b8b4a60-9bc5-47c6-b235-2c917f7a55e9",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:jacob-thompson",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:vulnerability",
      "fireeye-blog-tags:exploit"
    ],
    "jcr:uuid": "48e602b9-ff00-46ba-be7d-a5c30787edd8",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Wed Nov 04 2020 14:00:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EFireEye Mandiant has been investigating compromised Oracle Solaris machines in customer environments. During our investigations, we discovered an exploit tool on a customer\u2019s system and analyzed it to see how it was attacking their Solaris environment. The FLARE team\u2019s Offensive Task Force analyzed the exploit to determine how it worked, reproduced the vulnerability on different versions of Solaris, and then reported it to Oracle. In this blog post we present a description of the vulnerability, offer a quick way to test whether a system may be vulnerable, and suggest mitigations and workarounds.\u0026nbsp;Mandiant experts from the FLARE team will provide more information on this vulnerability and how it was \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2020\/11\/live-off-the-land-an-overview-of-unc1945.html\u0022\u003Eused by UNC1945\u003C\/a\u003E during a Nov. 12 webinar. \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.brighttalk.com\/webcast\/7451\/451508\u0022\u003ERegister today\u003C\/a\u003E and start preparing questions, because we will be fielding them from the audience at the end of the session.\u003C\/p\u003E\n\u003Ch4\u003EVulnerability Discovery\u003C\/h4\u003E\n\u003Cp\u003EThe security vulnerability occurs in the Pluggable Authentication Modules (PAM) library. PAM enables a Solaris application to authenticate users while allowing the system administrator to configure authentication parameters (e.g., password complexity and expiration) in one location that is consistently enforced by all applications.\u003C\/p\u003E\n\u003Cp\u003EThe actual vulnerability is a classic stack-based buffer overflow located in the \u003Ca adhocenable=\u0022false\u0022 href=\u0022http:\/\/web.archive.org\/web\/20080612012716\/http:\/\/src.opensolaris.org\/source\/xref\/onnv\/onnv-gate\/usr\/src\/lib\/libpam\/pam_framework.c#parse_user_name\u0022\u003EPAM \u003Cspan class=\u0022code\u0022\u003Eparse_user_name\u003C\/span\u003E function\u003C\/a\u003E. An abbreviated version of this function is shown in Figure 1.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Estatic int\u003Cbr\u003E\n parse_user_name(char *user_input, char **ret_username)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; register char *ptr;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; register int index = 0;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; char username[PAM_MAX_RESP_SIZE];\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\/* ... *\/\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ptr = user_input;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\/* ... *\/\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\/*\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;* username will be the first string we get from user_input\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;* - we skip leading whitespaces and ignore trailing whitespaces\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;*\/\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; while (*ptr != \u0027\\0\u0027) {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; if ((*ptr == \u0027 \u0027) || (*ptr == \u0027\\t\u0027))\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;break;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; else {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;username[index] = *ptr;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;index++;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;ptr++;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\/* ret_username will be freed in pam_get_user(). *\/\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; if ((*ret_username = malloc(index + 1)) == NULL)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; return (PAM_BUF_ERR);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; (void) strcpy(*ret_username, username);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; return (PAM_SUCCESS);\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: The parse_user_name function has a stack-based buffer overflow vulnerability\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe vulnerability arises whenever a username longer than \u003Cspan class=\u0022code\u0022\u003EPAM_MAX_RESP_SIZE\u003C\/span\u003E (512 bytes) is passed to \u003Cspan class=\u0022code\u0022\u003Eparse_user_name\u003C\/span\u003E. The vulnerability has likely existed for decades, and one possible reason is that it is only exploitable if an application does not already limit usernames to a smaller length before passing them to PAM. One situation where network-facing software does not always limit the username length arises in the SSH server, and this is the exploit vector used by the tool that we discovered.\u003C\/p\u003E\n\u003Cp\u003ESSH Keyboard-Interactive authentication is a \u201cpassthrough\u201d authentication mechanism where the SSH protocol relays prompts and responses between the server\u2019s PAM libraries and the client. It was designed to support custom forms of authentication such as two-factor without modifying the SSH protocol. By manipulating SSH client settings to force Keyboard-Interactive authentication to prompt for the username rather than sending it through normal means, an attacker can also pass unlimited input to the PAM \u003Cspan class=\u0022code\u0022\u003Eparse_user_name\u003C\/span\u003E function.\u003C\/p\u003E\n\u003Ch4\u003EProof of Concept Exploit\u003C\/h4\u003E\n\u003Cp\u003EIn order to quickly test different versions of Solaris to see if they may be vulnerable, we developed a proof of concept exploit to trigger the overflow and crash the SSH server. The standard OpenSSH client offers all the options needed to trigger the vulnerability (Figure 2).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solaris\/picture2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: A server can be quickly tested to see if it is vulnerable over SSH\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe indication that the server is vulnerable is that the SSH client prints \u201cAuthentication failed;\u201d a non-vulnerable PAM library causes the SSH server to repeatedly prompt for a username if it receives one that is too long. The overflow in the PAM library also causes the SSH server to crash, as shown in Figure 3. The operating system writes a crash dump to \u003Cspan class=\u0022code\u0022\u003E\/core\u003C\/span\u003E if the SSH server crashes with no debugger attached. In fact, if a \u003Cspan class=\u0022code\u0022\u003E\/core\u003C\/span\u003E file exists on a Solaris machine and the file command reports that it is from \u003Cspan class=\u0022code\u0022\u003Esshd\u003C\/span\u003E, those are indicators consistent with this vulnerability having been exploited.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/solaris\/picture3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: The SSH server crashes in the parse_user_name function\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EVulnerable Operating Systems\u003C\/h4\u003E\n\u003Cul\u003E\n\u003Cli\u003ESolaris 9 (some releases)\u003C\/li\u003E\n\u003Cli\u003ESolaris 10 (all releases)\u003C\/li\u003E\n\u003Cli\u003ESolaris 11.0\u003Cul\u003E\n\u003Cli\u003EWhile the \u003Cspan class=\u0022code\u0022\u003Eparse_user_name\u003C\/span\u003E function remains vulnerable in unpatched Solaris 11.1 and later, unrelated changes to the PAM library truncate the username before the vulnerable function receives it, rendering the issue non-exploitable via SSH. If the \u003Cspan class=\u0022code\u0022\u003Eparse_user_name\u003C\/span\u003E function were reachable in another context, then the vulnerability could become exploitable.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003Cli\u003EIllumos (OpenIndiana 2020.04)\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003EMitigations and Workaround\u003C\/h4\u003E\n\u003Cp\u003EA patch from Oracle for Solaris 10 and 11 is described in the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.oracle.com\/security-alerts\/cpuoct2020.html#AppendixSUNS\u0022\u003EOctober 2020 Critical Patch Update\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EBecause Solaris 9 is no longer supported, Oracle has not released a patch. For Solaris 9, as well as Solaris 10 or 11 systems where patching is inconvenient, we recommend editing the \u003Cspan class=\u0022code\u0022\u003E\/etc\/ssh\/sshd_config\u003C\/span\u003E file to add the lines \u003Cspan class=\u0022code\u0022\u003EChallengeResponseAuthentication no\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003EKbdInteractiveAuthentication no\u003C\/span\u003E and restart the SSH server. While this removes the opportunity to exploit the vulnerability using SSH Keyboard-Interactive authentication, there may be other ways to attack the \u003Cspan class=\u0022code\u0022\u003Eparse_user_name\u003C\/span\u003E function and we recommend using this workaround only as a stopgap until Solaris 9 systems can be upgraded, or the October patch can be accessed and installed for supported Solaris versions.\u003C\/p\u003E\n\u003Ch4\u003EAcknowledgements\u003C\/h4\u003E\n\u003Cp\u003EJeffrey Martin of Rapid7 contributed to the testing of this vulnerability.\u003C\/p\u003E\n",
        "jcr:lastModified": "Wed Nov 04 2020 18:35:35 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EAfter seeing Oracle Solaris compromises, we analyzed the exploit to determine how it worked and then reported it to Oracle.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Nov 04 2020 18:09:32 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed Nov 04 2020 18:59:46 GMT+0000",
      "imageRotate": "0"
    }
  }
}
