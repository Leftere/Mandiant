{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed May 04 2016 09:03:58 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Did It Execute?",
    "jcr:versionHistory": "98064b4d-3b0c-40aa-b88e-ee44fb59af31",
    "author": "Mary Singh",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "focusKeyword": "application compatibility cache",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "d6e7988e-36c6-4890-94c1-14d115cbe7b3"
    ],
    "jcr:created": "Fri Jul 24 2020 00:03:28 GMT+0000",
    "cq:lastModified": "Fri Jul 24 2020 00:03:11 GMT+0000",
    "jcr:baseVersion": "d6e7988e-36c6-4890-94c1-14d115cbe7b3",
    "jcr:isCheckedOut": true,
    "cq:createdBy": "admin",
    "cq:tags": [
      "fireeye-blog-tags:malware",
      "fireeye-blog-authors:cap-mary-singh",
      "fireeye-blog-tags:back-to-basics",
      "fireeye-blog-tags:registry",
      "fireeye-blog-tags:file-execution",
      "fireeye-blog-tags:prefetch",
      "fireeye-blog-tags:shimcache",
      "fireeye-blog-tags:application-compatibility-cache",
      "fireeye-blog-tags:forensics"
    ],
    "jcr:uuid": "b7278405-97e4-4803-a63c-b7d700f8aa21",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Aug 27 2013 17:26:05 GMT-0500",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "reference-adjustment-service",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
        "text": "\u003Cdiv class=\u0022c00 c00v1\u0022\u003E\u003Cp\u003EYou found a malicious executable! Now you\u0027ve got a crucial question to answer: did the file execute? We\u0027ll discuss a few sources of evidence you can use to answer this question. In this post, we will focus on static or \u0026quot;dead drive\u0026quot; forensics on Windows systems. We will cover four main sources of evidence: Windows Prefetch, Registry, Log Files, and File Information.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003EPrefetch\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EWindows Prefetch is a good place to begin looking for evidence of file execution. Microsoft designed Windows Prefetch to allow commonly used programs to open faster. By default, it stores information for the last 128 executed files in prefetch files found in \u0026quot;C:WindowsPrefetch\u0026quot;. A prefetch file is named as \u0026quot;executable file name\u0026quot; + \u003Ca target=\u0022_blank\u0022 href=\u0022http:\/\/www.hexacorn.com\/blog\/2012\/06\/13\/prefetch-hash-calculator-a-hash-lookup-table-xpvistaw7w2k3w2k8\/\u0022\u003Ehash\u003C\/a\u003E of file path + .pf. The prefetch file stores the first and last run dates, file path, number of times executed, and files loaded within the first ten seconds of process execution. So, if your malware filename \/ path hash shows up as a prefetch file named \u0026quot;DABEARS.EXE-12F3B52A.pf\u0026quot;, then you know the file executed. Note: on Windows servers, Prefetch is disabled by default.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003ERegistry\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EAs one would expect, the Windows Registry contains vast amounts of information on what goes on behind the scenes in Windows. Since the Registry is so large, the list below is not comprehensive, but it shows the main Registry keys we examine to determine file execution:\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E1. ShimCache\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EMicrosoft created the ShimCache, or \u0026quot;AppCompatCache\u0026quot; to identify application compatibility issues. The cache data tracks file path, size, last modified time, and last \u0026quot;execution\u0026quot; time (depending on OS). If a file is executed with Windows \u0026quot;createprocess,\u0026quot; it is logged in the ShimCache. While a file\u0027s presence in the ShimCache does not 100% prove file execution, it does show Windows interacted with the file. The following keys contain ShimCache data: \u0026quot;HKLMSYSTEMCurrentControlSetControlSession ManagerAppCompatibilityAppCompatCache (XP) and \u0026quot;HKLMSYSTEMCurrentControlSetControlSession ManagerAppCompatCacheAppCompatCache\u0026quot; (Non-XP). For more information on the ShimCache, see Andrew Davis\u0027 blog entry \u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/www.mandiant.com\/blog\/leveraging-application-compatibility-cache-forensic-investigations\/\u0022\u003Ehere\u003C\/a\u003E - or Mandiant\u0027s SANS DFIR conference presentation \u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/www.dropbox.com\/s\/7aulgcm84vnsaeg\/Johnny%20AppCompatCache.pdf\u0022\u003Ehere\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E2. MUICache\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EWhen a file is executed via Windows Explorer, the program shell creates an entry in the MUICache. There\u0027s a good write up of the process on the \u003Ca target=\u0022_blank\u0022 href=\u0022http:\/\/windowsir.blogspot.com\/2005\/12\/mystery-of-muicachesolved.html\u0022\u003EWindows Incident Response blog\u003C\/a\u003E. Windows uses the MUICache to store application names as retrieved from the PE Version Information in its Resource Section. The information is stored in the following keys:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u0026quot;HKCUSoftwareMicrosoftWindowsShellNoRoamMUICache\u0026quot; (XP, 2000, 2003) and\u003C\/li\u003E\n\u003Cli\u003E\u0026quot;HKCUSoftwareClassesLocal SettingsSoftwareMicrosoftWindowsShellMuiCache\u0026quot; (Vista, 7, 2008).\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003E\u003Cb\u003E3. UserAssist\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EThe UserAssist tracks executables and links opened in Explorer. The UserAssist key tracks last execution time and number of times a file was run in the registry key: \u0026quot;HKCUSoftwareMicrosoftWindowsCurrentVersionExplorerUserAssist\u0026quot;. Values under the UserAssist key, corresponding to the executable names and file paths, are encrypted with ROT13; as a result, you may miss evidence within this key if you conduct keyword searches prior to decoding. There are a number of tools to decrypt the key, including the RegRipper userassist.pl plugin, found \u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/code.google.com\/p\/regripper\/downloads\/list\u0022\u003Ehere\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003ELog Files\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EThere are a few logs you can analyze to determine file execution. Start with the Windows System Event Log, since this log records service starts. The event in Figure 1 shows an Administrator (SID=\u0026quot;-500\u0026quot;) executed the PSEXECSVC remote execution service:\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-1-Event-ID-7035-Service-start.png\u0022\u003E\u003Cimg width=\u0022508\u0022 height=\u0022141\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-1-Event-ID-7035-Service-start.png\u0022 alt=\u0022Figure 1: Event ID 7035 - Service start\u0022 class=\u0022size-full wp-image-5063\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003EFigure 1: Event ID 7035 - Service start\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003EWhen a service starts, it usually executes the file specified in the ImagePath or a loaded service DLL. For example, the \u0026quot;Netman\u0026quot; service uses the legitimate file \u0026quot;netman.dll\u0026quot; when it executes. However, if the ServiceDll in the registry contains a path to a backdoor named \u0026quot;tabcteng.dll\u0026quot;, the \u0026quot;Netman\u0026quot; service would execute \u0026quot;tabcteng.dll\u0026quot; instead. Be sure to validate the files in the ImagePath and ServiceDlls for any suspicious service starts.\u003C\/p\u003E\n\u003Cp\u003EIf Audit Process Tracking is enabled in the Windows Event Log audit settings, the Windows Security Event Log is a wealth of information about processes and can definitively prove file execution. Figure 2 and Figure 3 show the malicious file and associated process ID, as well as the parent process ID and username to aid in further investigation.\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-2-XP-EventID-592-Process-creation.png\u0022\u003E\u003Cimg width=\u0022504\u0022 height=\u002281\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-2-XP-EventID-592-Process-creation.png\u0022 alt=\u0022Figure 2: XP EventID 592 - Process creation\u0022 class=\u0022size-full wp-image-5064\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003EFigure 2: XP EventID 592 - Process creation\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003EWindows Vista+ records a similar process creation event, but the EventID is 4688.\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-3-Vista+-EventID-4688-Process-creation.png\u0022\u003E\u003Cimg width=\u0022503\u0022 height=\u0022219\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-3-Vista+-EventID-4688-Process-creation.png\u0022 alt=\u0022Figure 3: Vista+ EventID 4688 - Process creation\u0022 class=\u0022size-full wp-image-5065\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003EFigure 3: Vista+ EventID 4688 - Process creation\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003EAuditing capabilities are more granular with newer versions of Windows and are integrated with Group Policy starting in Windows Server 2008 R2 and Windows 7. Advanced audit policy settings can be found \u003Ca target=\u0022_blank\u0022 href=\u0022http:\/\/technet.microsoft.com\/en-us\/library\/dd772712(v=ws.10).aspx\u0022\u003Ehere\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EThere are too many vendors to cover in this post, but host-based IPS or AV product logs may show when a file is running and\/or attempting an action on another file. Figure 4 contains an example event from a McAfee Access Protection log.\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-4-McAfee-Access-Protection-log-event.png\u0022\u003E\u003Cimg width=\u0022508\u0022 height=\u002296\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-4-McAfee-Access-Protection-log-event.png\u0022 alt=\u0022Figure 4: McAfee Access Protection log event\u0022 class=\u0022size-full wp-image-5066\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003EFigure 4: McAfee Access Protection log event\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003EThe Windows Scheduled Task Log may confirm if the attacker used a scheduled task to execute malware. Scheduled Tasks are recorded in a log file named \u0026quot;SchedLgU.txt\u0026quot; as follows:\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-5-Event-in-Scheduled-Task-log.png\u0022\u003E\u003Cimg width=\u0022503\u0022 height=\u002279\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-5-Event-in-Scheduled-Task-log.png\u0022 alt=\u0022Figure 5: Event in Scheduled Task log\u0022 class=\u0022size-full wp-image-5067\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003EFigure 5: Event in Scheduled Task log\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003EIn Windows Vista+, the scheduled task executions are also recorded in the log \u0026quot;Microsoft-Windows-TaskScheduler\/Operational\u0026quot; event log under Event ID 200 and 201.\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-6-Event-ID-200-201-Scheduled-Task-execution.png\u0022\u003E\u003Cimg width=\u0022508\u0022 height=\u002286\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-6-Event-ID-200-201-Scheduled-Task-execution.png\u0022 alt=\u0022Figure 6: Event ID 200 \u0026amp; 201 - Scheduled Task execution\u0022 class=\u0022size-full wp-image-5068\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003EFigure 6: Event ID 200 \u0026amp; 201 - Scheduled Task execution\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003EFinally, if an application \u003Ca target=\u0022_blank\u0022 href=\u0022http:\/\/xkcd.com\/376\/\u0022\u003Ecrashes\u003C\/a\u003E, the Dr. Watson log may record a malicious task running.\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-7-Running-tasks-captured-in-Dr.-Watson-Log.png\u0022\u003E\u003Cimg width=\u0022503\u0022 height=\u0022108\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Figure-7-Running-tasks-captured-in-Dr.-Watson-Log.png\u0022 alt=\u0022Figure 7: Running tasks captured in Dr. Watson Log\u0022 class=\u0022size-full wp-image-5069\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003EFigure 7: Running tasks captured in Dr. Watson Log\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003E\u003Cb\u003EFile Functionality\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EAnother way to determine if a file was executed is to look for any output files. When you analyzed the malicious file, was it configured to create data? For example, if the malicious file you found is a keylogger and an associated keylog file is present on the system, the attacker likely executed the file. If the malware was configured to connect to a particular domain name, the browser history may have recorded the associated domain. Table 1 contains an example of two communication mechanisms captured in browser history from the same backdoor.\u003C\/p\u003E\n\u003Cfigure\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Table-1-Malicious-communication-in-browser-history.png\u0022\u003E\u003Cimg width=\u0022648\u0022 height=\u0022109\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/Table-1-Malicious-communication-in-browser-history.png\u0022 alt=\u0022Table 1: Malicious communication in browser history\u0022 class=\u0022size-full wp-image-5070\u0022\u003E\u003C\/a\u003E\u003Cfigcaption\u003ETable 1: Malicious communication in browser history\u003C\/figcaption\u003E\u003C\/figure\u003E\u003Cp\u003ETo determine if a malicious file executed, analyze the file\u0027s functionality, and look for evidence of the resulting activity on disk. Malware functionality can also help you assess an attacker\u0027s \u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/www.mandiant.com\/blog\/chinese-motivations-corporate-espionage-historical-perspective\/\u0022\u003Emotivation\u003C\/a\u003E, end goals, and perhaps reveal additional malicious files.\u003C\/p\u003E\n\u003Cp\u003EWhile this post covered the primary sources of evidence we use to detect file execution, there are many more Registry keys and other Windows files which provide evidence of malware execution, especially in Windows Vista and above. Similarly, information found in system memory can be even more valuable for proving file execution and may provide specific attacker commands and accessed resources. So please, if you find a malicious executable on a running system, \u003Cb\u003E\u003Ci\u003Ebe sure to capture the memory\u003C\/i\u003E\u003C\/b\u003E before doing anything else. You can capture and analyze memory with \u003Ca target=\u0022_blank\u0022 href=\u0022\/content\/fireeye-www\/en_US\/services\/freeware\/redline.html\u0022 adhocenable=\u0022false\u0022\u003EMandiant Redline\u2122\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EWe will discuss more forensic artifacts in future posts, but feel free to direct message me on Twitter \u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/twitter.com\/marycheese\u0022\u003E@marycheese\u003C\/a\u003E.\u003C\/p\u003E\n\u003C\/div\u003E\n",
        "jcr:lastModified": "Sat Aug 29 2015 13:10:04 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "admin",
      "text": "\u003Cp\u003EYou found a malicious executable! Now you\u0027ve got a crucial question to answer: did the file execute? We\u0027ll discuss a few sources of evidence you can use to answer this question. In this post, we will focus on static or \u0022dead drive\u0022 forensics on Windows systems. We will cover four main sources of evidence: Windows Prefetch, Registry, Log Files, and File Information.\u003C\/p\u003E ",
      "jcr:lastModified": "Tue Aug 27 2013 17:26:05 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
