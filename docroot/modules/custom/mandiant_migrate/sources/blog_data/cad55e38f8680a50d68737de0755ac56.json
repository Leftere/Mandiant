{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Thu Aug 06 2020 19:22:07 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Bypassing MassLogger Anti-Analysis \u2014 a Man-in-the-Middle Approach",
    "jcr:versionHistory": "10cf4fda-d3e6-4573-bb9d-7bfb39983053",
    "author": "Nhan Huynh",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "39988fbd-c15d-4dc3-9932-7484a1c2549e"
    ],
    "jcr:created": "Sat Aug 22 2020 20:40:58 GMT+0000",
    "cq:lastModified": "Sat Aug 22 2020 20:38:17 GMT+0000",
    "jcr:baseVersion": "39988fbd-c15d-4dc3-9932-7484a1c2549e",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:nhan-huynh",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:malware-analysis",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:reverse-engineering",
      "fireeye-blog-tags:evasion"
    ],
    "jcr:uuid": "74ae00bf-ab18-4395-9566-312ff92d7fe1",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Aug 06 2020 15:15:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EThe FireEye Front Line Applied Research \u0026amp; Expertise (FLARE) Team attempts to always stay on top of the most current and emerging threats. As a member of the FLARE Reverse Engineer team, I recently received a request to analyze a fairly new credential stealer identified as MassLogger. Despite the lack of novel functionalities and features, this sample employs a sophisticated technique that replaces the Microsoft Intermediate Language (MSIL) at run time to hinder static analysis. At the time of this writing, there is only \u003Ca href=\u0022https:\/\/cert-agid.gov.it\/wp-content\/uploads\/2020\/06\/CERT-AGID_MassLogger-20200609.pdf\u0022\u003Eone publication\u003C\/a\u003E discussing the MassLogger obfuscation technique in some detail. Therefore, I decided to share my research and \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/jitm\u0022\u003Etools to help analyze MassLogger and other malware using a similar technique\u003C\/a\u003E. Let us take a deep technical dive into the MassLogger credential stealer and the .NET runtime.\u003C\/p\u003E\n\u003Ch4\u003ETriage\u003C\/h4\u003E\n\u003Cp\u003EMassLogger is a .NET credential stealer. It starts with a launcher (\u003Cspan class=\u0022code\u0022\u003E6b975fd7e3eb0d30b6dbe71b8004b06de6bba4d0870e165de4bde7ab82154871\u003C\/span\u003E) that uses simple anti-debugging techniques which can be easily bypassed when identified. This first stage loader eventually XOR-decrypts the second stage assembly which then decrypts, loads and executes the final MassLogger payload (\u003Cspan class=\u0022code\u0022\u003Ebc07c3090befb5e94624ca4a49ee88b3265a3d1d288f79588be7bb356a0f9fae\u003C\/span\u003E) named \u003Cspan class=\u0022code\u0022\u003EBin-123.exe\u003C\/span\u003E. The final payload can be easily extracted and executed independently. Therefore, we will focus exclusively on this final payload where the main anti analysis technique is used.\u003C\/p\u003E\n\u003Cp\u003EBasic static analysis doesn\u2019t reveal anything too exciting. We notice some interesting strings, but they are not enough to give us any hints about the malware\u2019s capabilities. Executing the payload in a controlled environment shows that the sample drops a log file that identifies the malware family, its version, and most importantly some configuration options. A sample log file is described in Figure 1. We can also extract some interesting strings from memory as the sample runs. However, basic dynamic analysis is not sufficient to extract all host-based indicators (HBIs), network-based indicators (NBIs) and complete malware functionality. We must perform a deeper analysis to better understand the sample and its capabilities.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003EUser Name: user\u003Cbr\u003E\n IP: 127.0.0.1\u003Cbr\u003E\n Location: United States\u003Cbr\u003E\n OS: Microsoft Windows 7 Ultimate 32bit\u003Cbr\u003E\n CPU: Intel(R) Core(TM) i7-6820HQ CPU @ 2.70GHz\u003Cbr\u003E\n GPU: VMware SVGA 3D\u003Cbr\u003E\n AV: NA\u003Cbr\u003E\n Screen Resolution: 1438x2460\u003Cbr\u003E\n Current Time: 6\/17\/2020 1:23:30 PM\u003Cbr\u003E\n MassLogger Started: 6\/17\/2020 1:23:21 PM\u003Cbr\u003E\n Interval: 2 hour\u003Cbr\u003E\n MassLogger Process: C:\\Users\\user\\Desktop\\Bin-123.exe\u003Cbr\u003E\n MassLogger Melt: false\u003Cbr\u003E\n MassLogger Exit after delivery: false\u003Cbr\u003E\n As Administrator: False\u003Cbr\u003E\n Processes:\u003Cbr\u003E\n Name:cmd, Title:Administrator: FakeNet-NG - fakenet\u003Cbr\u003E\n Name:iexplore, Title:FakeNet-NG - Internet Explorer\u003Cbr\u003E\n Name:dnSpy-x86, Title:dnSpy v6.0.5 (32-bit)\u003Cbr\u003E\n Name:cmd, Title:Administrator: C:\\Windows\\System32\\cmd.exe\u003Cbr\u003E\n Name:ProcessHacker, Title:Process Hacker [WIN-R23GG4KO4SD\\user]+ (Administrator)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### WD Exclusion ###\u003Cbr\u003E\n Disabled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### USB Spread ###\u003Cbr\u003E\n Disabled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Binder ###\u003Cbr\u003E\n Disabled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Window Searcher ###\u003Cbr\u003E\n Disabled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Downloader ###\u003Cbr\u003E\n Disabled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Bot Killer ###\u003Cbr\u003E\n Disabled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Search And Upload ###\u003Cbr\u003E\n Disabled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Telegram Desktop ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Pidgin ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### FileZilla ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Discord Tokken ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### NordVPN ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Outlook ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### FoxMail ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Thunderbird ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### QQ Browser ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### FireFox ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Chromium Recovery ###\u003Cbr\u003E\n Not Installed\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E### Keylogger And Clipboard ###\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E[20\/06\/17]\u0026nbsp; [Welcome to Chrome - Google Chrome]\u003Cbr\u003E\n [ESC]\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E[20\/06\/17]\u0026nbsp; [Clipboard]\u003Cbr\u003E\n Vewgbprxvhvjktmyxofjvpzgazqszaoo\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Sample MassLogger log\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EJust Decompile It\u003C\/h4\u003E\n\u003Cp\u003ELike many other .NET malwares, MassLogger obfuscates all of its methods names and even the method control flow. We can use \u003Cspan class=\u0022code\u0022\u003Ede4dot\u003C\/span\u003E to automatically deobfuscate the MassLogger payload. However, looking at the deobfuscated payload, we quickly identify a major issue: Most of the methods contain almost no logic as shown in Figure 2.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: dnSpy showing empty methods\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ELooking at the original MassLogger payload in \u003Cspan class=\u0022code\u0022\u003EdnSpy\u003C\/span\u003E\u2019s Intermediate Language (IL) view confirms that most methods do not contain any logic and simply return nothing. This is obviously not the real malware since we already observed with dynamic analysis that the sample indeed performs malicious activities and logging to a log file. We are left with a few methods, most notably the method with the token \u003Cspan class=\u0022code\u0022\u003E0x0600049D\u003C\/span\u003E called first thing in the main module constructor.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: dnSpy IL view showing the method\u0027s details\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EMethod \u003Cspan class=\u0022code\u0022\u003E0x0600049D\u003C\/span\u003E control flow has been obfuscated into a series of switch statements. We can still somewhat follow the method\u2019s high-level logic with the help of \u003Cspan class=\u0022code\u0022\u003EdnSpy\u003C\/span\u003E as a debugger. However, fully analyzing the method would be very time consuming. Instead, when first analyzing this payload, I chose to quickly scan over the entire module to look for hints. Luckily, I spot a few interesting strings I missed during basic static analysis: \u003Cspan class=\u0022code\u0022\u003Eclrjit.dll\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003EVirtualProtect\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003EWriteProcessMemory\u003C\/span\u003E as seen in Figure 4.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure4.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Interesting strings scattered throughout the module\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EA quick internet search for \u201c\u003Cspan class=\u0022code\u0022\u003Eclrjit.dll\u003C\/span\u003E\u201d and \u201c\u003Cspan class=\u0022code\u0022\u003EVirtualProtect\u003C\/span\u003E\u201d quickly takes us to \u003Ca href=\u0022https:\/\/xoofx.com\/blog\/2018\/04\/12\/writing-managed-jit-in-csharp-with-coreclr\/\u0022\u003Ea\u003C\/a\u003E \u003Ca href=\u0022https:\/\/georgeplotnikov.github.io\/articles\/just-in-time-hooking.html\u0022\u003Efew\u003C\/a\u003E \u003Ca href=\u0022http:\/\/antonioparata.blogspot.com\/2018\/02\/analyzing-nasty-net-protection-of.html\u0022\u003Epublications\u003C\/a\u003E describing a technique commonly referred to as Just-In-Time Hooking. In essence, JIT Hooking involves installing a hook at the \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E function where the JIT compiler is about to compile the MSIL into assembly (x86, x64, etc). With the hook in place, the malware can easily replace each method body with the real MSIL that contains the original malware logic. To fully understand this process, let\u2019s explore the .NET executable, the .NET methods, and how MSIL turns into x86 or x64 assembly.\u003C\/p\u003E\n\u003Ch4\u003E.NET Executable Methods\u003C\/h4\u003E\n\u003Cp\u003EA .NET executable is just another binary following the Portable Executable (PE) format. There are plenty of resources describing the \u003Ca href=\u0022https:\/\/bytepointer.com\/resources\/pietrek_peering_inside_pe.htm\u0022\u003EPE\u003C\/a\u003E \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/archive\/msdn-magazine\/2002\/february\/inside-windows-win32-portable-executable-file-format-in-detail\u0022\u003Efile\u003C\/a\u003E \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/debug\/pe-format?redirectedfrom=MSDN\u0022\u003Eformat\u003C\/a\u003E, the \u003Ca href=\u0022https:\/\/www.ntcore.com\/files\/dotnetformat.htm\u0022\u003E.NET metadata\u003C\/a\u003E and the .NET token tables in detail. I recommend our readers to take a quick detour and refresh their memory on those topics before continuing. This post won\u2019t go into further details but will focus on the .NET methods instead.\u003C\/p\u003E\n\u003Cp\u003EEach .NET method in a .NET assembly is identified by a token. In fact, everything in a .NET assembly, whether it\u2019s a module, a class, a method prototype, or a string, is identified by a token. Let\u2019s look at method identified by the token \u003Cspan class=\u0022code\u0022\u003E0x0600049D\u003C\/span\u003E, as shown in Figure 5. The most-significant byte (\u003Cspan class=\u0022code\u0022\u003E0x06\u003C\/span\u003E) tells us that this token is a method token (type \u003Cspan class=\u0022code\u0022\u003E0x06\u003C\/span\u003E) instead of a module token (type \u003Cspan class=\u0022code\u0022\u003E0x00\u003C\/span\u003E), a TypeDef token (type \u003Cspan class=\u0022code\u0022\u003E0x02\u003C\/span\u003E), or a LocalVarSig token (type \u003Cspan class=\u0022code\u0022\u003E0x11\u003C\/span\u003E), for example. The three least significant bytes tell us the ID of the method, in this case it\u2019s \u003Cspan class=\u0022code\u0022\u003E0x49D\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003E1181\u003C\/span\u003E in decimal). This ID is also referred to as the Method ID (MID) or the Row ID of the method.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure5.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Method details for method 0x0600049D\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ETo find out more information about this method, we look within the tables of the \u201c\u003Cspan class=\u0022code\u0022\u003E#~\u003C\/span\u003E\u201d stream of the .NET metadata streams in the .NET metadata directory as show in Figure 6. We traverse to the entry number \u003Cspan class=\u0022code\u0022\u003E1181\u003C\/span\u003E or \u003Cspan class=\u0022code\u0022\u003E0x49D\u003C\/span\u003E of the Method table to find the method metadata which includes the Relative Virtual Address (RVA) of the method body, various flags, a pointer to the name of the method, a pointer to the method signature, and finally, an pointer to the parameters specification for this method. \u003Cb\u003EPlease note that the MID starts at 1 instead of 0\u003C\/b\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure6.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Method details from the PE file header\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFor method \u003Cspan class=\u0022code\u0022\u003E0x0600049D\u003C\/span\u003E, the RVA of the method body is \u003Cspan class=\u0022code\u0022\u003E0xB690\u003C\/span\u003E. This RVA belongs to the \u003Cspan class=\u0022code\u0022\u003E.text\u003C\/span\u003E section whose RVA is \u003Cspan class=\u0022code\u0022\u003E0x2000\u003C\/span\u003E. Therefore, this method body begins at \u003Cspan class=\u0022code\u0022\u003E0x9690\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003E0xB690\u003C\/span\u003E \u2013 \u003Cspan class=\u0022code\u0022\u003E0x2000\u003C\/span\u003E) bytes into the \u003Cspan class=\u0022code\u0022\u003E.text\u003C\/span\u003E section. The \u003Cspan class=\u0022code\u0022\u003E.text\u003C\/span\u003E section starts at \u003Cspan class=\u0022code\u0022\u003E0x200\u003C\/span\u003E bytes into the file according to the section header. As a result, we can find the method body at \u003Cspan class=\u0022code\u0022\u003E0x9890\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003E0x9690\u003C\/span\u003E + \u003Cspan class=\u0022code\u0022\u003E0x200\u003C\/span\u003E) bytes offset into the file. We can see the method body in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Method 0x0600049D body in a hex editor\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003E.NET Method Body\u003C\/h4\u003E\n\u003Cp\u003EThe .NET method body starts with a method body header, followed by the MSIL bytes. There are two types of .NET methods: a tiny method and a fat method. Looking at the first byte of the method body header, the two least-significant bits tell us if the method is tiny (where the last two bits are \u003Cspan class=\u0022code\u0022\u003E10\u003C\/span\u003E) or fat (where the last two bits are \u003Cspan class=\u0022code\u0022\u003E11\u003C\/span\u003E).\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E.NET Tiny Method\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003ELet\u2019s look at method \u003Cspan class=\u0022code\u0022\u003E0x06000495\u003C\/span\u003E. Following the same steps described earlier, we check the row number \u003Cspan class=\u0022code\u0022\u003E0x495\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003E1173\u003C\/span\u003E in decimal) of the Method table to find the method body RVA is \u003Cspan class=\u0022code\u0022\u003E0x7A7C\u003C\/span\u003E which translates to \u003Cspan class=\u0022code\u0022\u003E0x5C7C\u003C\/span\u003E as the offset into the file. At this offset, the first byte of the method body is \u003Cspan class=\u0022code\u0022\u003E0x0A\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003E0000\u003C\/span\u003E \u003Cspan class=\u0022code\u0022\u003E1010\u003C\/span\u003E in binary).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure8.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Method 0x06000495 metadata and body\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ESince the two least-significant bits are \u003Cspan class=\u0022code\u0022\u003E10\u003C\/span\u003E, we know that \u003Cspan class=\u0022code\u0022\u003E0x06000495\u003C\/span\u003E is a tiny method. For a tiny method, the method body header is \u003Cb\u003Eone byte long\u003C\/b\u003E. The \u003Cb\u003Etwo least-significant bits\u003C\/b\u003E are \u003Cspan class=\u0022code\u0022\u003E10\u003C\/span\u003E to indicate that this is the tiny method, and the \u003Cb\u003Esix most-significant bits\u003C\/b\u003E tell us the size of the MSIL to follow (i.e. how long the MSIL is). In this case, the six most-significant bits are \u003Cspan class=\u0022code\u0022\u003E000010\u003C\/span\u003E, which tells us the method body is two bytes long. The entire method body for \u003Cspan class=\u0022code\u0022\u003E0x06000495\u003C\/span\u003E is \u003Cspan class=\u0022code\u0022\u003E0A\u003C\/span\u003E \u003Cspan class=\u0022code\u0022\u003E16\u003C\/span\u003E \u003Cspan class=\u0022code\u0022\u003E2A\u003C\/span\u003E, followed by a NULL byte, which has been disassembled by \u003Cspan class=\u0022code\u0022\u003EdnSpy\u003C\/span\u003E as shown in Figure 9.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure9.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Method 0x06000495 in dnSpy IL view\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E.NET Fat Method\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003EComing back to method \u003Cspan class=\u0022code\u0022\u003E0x0600049D\u003C\/span\u003E (entry number \u003Cspan class=\u0022code\u0022\u003E1181\u003C\/span\u003E) at offset \u003Cspan class=\u0022code\u0022\u003E0x9890\u003C\/span\u003E into the file (RVA \u003Cspan class=\u0022code\u0022\u003E0xB690\u003C\/span\u003E), the first byte of the method body is \u003Cspan class=\u0022code\u0022\u003E0x1B\u003C\/span\u003E (or \u003Cspan class=\u0022code\u0022\u003E0001\u003C\/span\u003E \u003Cspan class=\u0022code\u0022\u003E1011\u003C\/span\u003E in binary). The two least-significant bits are \u003Cspan class=\u0022code\u0022\u003E11\u003C\/span\u003E, indicating that \u003Cspan class=\u0022code\u0022\u003E0x0600049D\u003C\/span\u003E is a fat method. The fat method body header is \u003Cb\u003E12-byte long\u003C\/b\u003E whose structure is beyond the scope of this blog post. The field we really care about is a \u003Cb\u003Efour-byte field\u003C\/b\u003E at \u003Cb\u003Eoffset \u003Cspan class=\u0022code\u0022\u003E0x04\u003C\/span\u003E byte\u003C\/b\u003E into this fat header. This field specifies the length of the MSIL that follows this method body header. For method \u003Cspan class=\u0022code\u0022\u003E0x0600049D\u003C\/span\u003E, the entire method body header is \u201c\u003Cspan class=\u0022code\u0022\u003E1B 30 08 00 \u003Cb\u003EA8 61 00 00\u003C\/b\u003E 75 00 00 11\u003C\/span\u003E\u201d and the length of the MSIL to follow is \u201c\u003Cspan class=\u0022code\u0022\u003EA8 61 00 00\u003C\/span\u003E\u201d or \u003Cspan class=\u0022code\u0022\u003E0x61A8\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003E25000\u003C\/span\u003E in decimal) bytes.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure10.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Method 0x0600049D body in a hex editor\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EJIT Compilation\u003C\/h4\u003E\n\u003Cp\u003EWhether a method is tiny or fat, it does not execute as is. When the .NET runtime needs to execute a method, it follows exactly the process described earlier to find the method body which includes the method body header and the MSIL bytes. If this is the first time the method needs to run, the .NET runtime invokes the Just-In-Time compiler which takes the MSIL bytes and compiles them into x86 or x64 assembly depending on whether the current process is 32- or 64-bit. After some preparation, the JIT compiler eventually calls the \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E function. The entire .NET runtime project is open-sourced and \u003Ca href=\u0022https:\/\/github.com\/dotnet\/runtime\u0022\u003Eavailable on GitHub\u003C\/a\u003E. We can easily find out that the \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E function has the following prototype (Figure 11):\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003ECorJitResult __stdcall compileMethod (\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; ICorJitInfo\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *comp,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/* IN *\/\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; CORINFO_METHOD_INFO\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *\u003Cb\u003Einfo\u003C\/b\u003E,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/* IN *\/\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; unsigned \/* code:CorJitFlag *\/\u0026nbsp;\u0026nbsp;\u0026nbsp; flags,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/* IN *\/\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; BYTE\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; **nativeEntry,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/* OUT *\/\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; ULONG\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *nativeSizeOfCode\u0026nbsp;\u0026nbsp;\u0026nbsp; \/* OUT *\/\u003Cbr\u003E\n );\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: compileMethod() function protype\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 12 shows the \u003Cspan class=\u0022code\u0022\u003ECORINFO_METHOD_INFO\u003C\/span\u003E structure.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Estruct CORINFO_METHOD_INFO\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; CORINFO_METHOD_HANDLE\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ftn;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; CORINFO_MODULE_HANDLE\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; scope;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; BYTE *\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u003Cb\u003EILCode\u003C\/b\u003E;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; unsigned\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u003Cb\u003EILCodeSize\u003C\/b\u003E;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; unsigned\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; maxStack;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; unsigned\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; EHcount;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; CorInfoOptions\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; options;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; CorInfoRegionKind\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; regionKind;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; CORINFO_SIG_INFO\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;args;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; CORINFO_SIG_INFO\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; locals;\u003Cbr\u003E\n };\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: CORINFO_METHOD_INFO structure\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003EILCode\u003C\/span\u003E is a pointer to the MSIL of the method to compile, and the \u003Cspan class=\u0022code\u0022\u003EILCodeSize\u003C\/span\u003E tells us how long the MSIL is. The return value of \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E is an error code indicating success or failure. In case of success, the \u003Cspan class=\u0022code\u0022\u003EnativeEntry\u003C\/span\u003E pointer is populated with the address of the executable memory region containing the x86 or the x64 instruction that is compiled from the MSIL.\u003C\/p\u003E\n\u003Ch4\u003EMassLogger JIT Hooking\u003C\/h4\u003E\n\u003Cp\u003ELet\u2019s come back to MassLogger. As soon as the main module initialization runs, it first decrypts MSIL of the other methods. It then installs a hook to execute its own version of \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E (method \u003Cspan class=\u0022code\u0022\u003E0x06000499\u003C\/span\u003E). This method replaces the \u003Cspan class=\u0022code\u0022\u003EILCode\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003EILCodeSize\u003C\/span\u003E fields of the info argument to the original \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E with the real malware\u2019s MSIL bytes.\u003C\/p\u003E\n\u003Cp\u003EIn addition to replacing the MSIL bytes, MassLogger also patches the method body header at module initialization time. As seen from Figure 13, the method body header of method \u003Cspan class=\u0022code\u0022\u003E0x060003DD\u003C\/span\u003E on disk (at file offset 0x3CE0) is different from the header in memory (at RVA \u003Cspan class=\u0022code\u0022\u003E0x5AE0\u003C\/span\u003E). The only two things remaining quite consistent are the least significant two bits indicating whether the method is tiny or fat. To successfully defeat this anti-analysis technique, we must recover the real MSIL bytes as well as the correct method body headers.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure13.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 13: Same method body with different headers when resting on disk vs. loaded in memory\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EDefeating JIT Method Body Replacement With JITM\u003C\/h4\u003E\n\u003Cp\u003ETo automatically recover the MSIL and the method body header, one possible approach suggested by another FLARE team member is to install our own hook at \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E function before loading and allowing the MassLogger module constructor to run.\u0026nbsp; There are \u003Ca href=\u0022https:\/\/georgeplotnikov.github.io\/articles\/just-in-time-hooking.html\u0022\u003Emultiple\u003C\/a\u003E \u003Ca href=\u0022https:\/\/ntcore.com\/files\/netint_injection.htm\u0022\u003Etutorials\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/xoofx.com\/blog\/2018\/04\/12\/writing-managed-jit-in-csharp-with-coreclr\/\u0022\u003Eopen-sourced\u003C\/a\u003E \u003Ca href=\u0022https:\/\/github.com\/maddnias\/SJITHook\u0022\u003Eprojects\u003C\/a\u003E on hooking \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E using both managed hooks (the new \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E is a managed method written in C#) and native hooks (the new \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E is native and written in C or C++). However, due to the unique way MassLogger hooks \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E, we cannot use the vtable hooking technique implemented by many of the aforementioned projects. Therefore, I\u2019d like to share the following project: \u003Ca href=\u0022https:\/\/github.com\/fireeye\/jitm\u0022\u003EJITM\u003C\/a\u003E, which is designed use inline hooking implemented by \u003Ca href=\u0022https:\/\/github.com\/stevemk14ebr\/PolyHook_2_0\u0022\u003EPolyHook\u003C\/a\u003E library. JITM comes with a wrapper for \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E which logs all the method body headers and MSIL bytes to a JSON file before calling the original \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003EIn addition to the hook, \u003Cspan class=\u0022code\u0022\u003EJITM\u003C\/span\u003E also includes a .NET loader. This loader first loads the native hook DLL (\u003Cspan class=\u0022code\u0022\u003Ejitmhook.dll\u003C\/span\u003E) and installs the hook. The loader then loads the MassLogger payload and executes its entry point. This causes MassLogger\u2019s module initialization code to execute and install its own hook, but hooking \u003Cspan class=\u0022code\u0022\u003Ejitmhook.dll\u003C\/span\u003E code instead of the original \u003Cspan class=\u0022code\u0022\u003EcompileMethod()\u003C\/span\u003E. An alternative approach to executing MassLogger\u2019s entry point is to call the \u003Cspan class=\u0022code\u0022\u003ERuntimeHelpers.PrepareMethod()\u003C\/span\u003E API to force the JIT compiler to run on all methods. This approach is better because it avoids running the malware, and it potentially can recover methods not called in the sample\u2019s natural code path. However, additional work is required to force all methods to be compiled properly.\u003C\/p\u003E\n\u003Cp\u003ETo load and recover MassLogger methods, first run the following command (Figure 14):\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Ejitm.exe \u003Cb\u003EBin-123.exe\u003C\/b\u003E [optional_timeout]\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 14: Command to run jitm\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce the timeout expires, you should see the files \u003Cspan class=\u0022code\u0022\u003Ejitm.log\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Ejitm.json\u003C\/span\u003E created in the current directory. \u003Cspan class=\u0022code\u0022\u003Ejitm.json\u003C\/span\u003E contains the method tokens, method body headers and MSIL bytes of all methods recovered from \u003Cspan class=\u0022code\u0022\u003EBin-123.exe\u003C\/span\u003E. The only thing left to do is to rebuild the .NET metadata so we can perform static analysis.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure15.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 15: Sample jitm.json\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ERebuilding the Assembly\u003C\/h4\u003E\n\u003Cp\u003ESince the decrypted method body headers and MSIL bytes may not fit in the original .NET assembly properly, the easiest thing to do is to add a new section and a section header to MassLogger. There are \u003Ca href=\u0022https:\/\/reverseengineering.stackexchange.com\/questions\/15045\/adding-a-new-pe-section-for-a-code-cave\u0022\u003Eplenty\u003C\/a\u003E of \u003Ca href=\u0022https:\/\/reverseengineering.stackexchange.com\/questions\/8390\/python-adding-a-asection-to-a-pe-file\u0022\u003Eresources\u003C\/a\u003E on \u003Ca href=\u0022https:\/\/reverseengineering.stackexchange.com\/questions\/13995\/adding-section-to-pe-binary-using-stud-pe\u0022\u003Ehow to\u003C\/a\u003E \u003Ca href=\u0022http:\/\/www.rohitab.com\/discuss\/topic\/41466-add-a-new-pe-section-code-inside-of-it\/\u0022\u003Eadd a PE section header and data\u003C\/a\u003E, none of which is trivial or easy to automate. Therefore, \u003Cspan class=\u0022code\u0022\u003EJITM\u003C\/span\u003E also include the following Python 2.7 helper script to automate this process: \u003Cspan class=\u0022code\u0022\u003EScripts\\addsection.py\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003EWith the method body header and MSIL of each method added to a new PE section as shown in Figure 16, we can easily parse the .NET metadata and fix each method\u2019s RVA to point to the correct method body within the new section. Unfortunately, I did not find any Python library to easily parse the .NET metadata and the MethodDef table. Therefore, \u003Cspan class=\u0022code\u0022\u003EJITM\u003C\/span\u003E also includes a partially implemented .NET metadata parser: \u003Cspan class=\u0022code\u0022\u003EScript\\pydnet.py\u003C\/span\u003E. This script uses \u003Cspan class=\u0022code\u0022\u003Epefile\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Evivisect\u003C\/span\u003E modules and parses the PE file up to the \u003Cspan class=\u0022code\u0022\u003EMethod\u003C\/span\u003E table to extract all methods and their associated RVAs.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure16.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 16: Bin-123.exe before and after adding an additional section named FLARE\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFinally, to tie everything together, \u003Cspan class=\u0022code\u0022\u003EJITM\u003C\/span\u003E provides \u003Cspan class=\u0022code\u0022\u003EScript\\fix_assembly.py\u003C\/span\u003E to perform the following tasks:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EWrite the method body header and MSIL of each method recovered in \u003Cspan class=\u0022code\u0022\u003Ejitm.json\u003C\/span\u003E into a temporary binary file named \u201c\u003Cspan class=\u0022code\u0022\u003Esection.bin\u003C\/span\u003E\u201d while at the same time remember the associated method token and the offset into \u003Cspan class=\u0022code\u0022\u003Esection.bin\u003C\/span\u003E.\u003C\/li\u003E\n\u003Cli\u003EUse \u003Cspan class=\u0022code\u0022\u003Eaddsection.py\u003C\/span\u003E to add \u003Cspan class=\u0022code\u0022\u003Esection.bin\u003C\/span\u003E into \u003Cspan class=\u0022code\u0022\u003EBin-123.exe\u003C\/span\u003E and save the data into a new file, e.g. \u003Cspan class=\u0022code\u0022\u003EBin-123.fixed.exe\u003C\/span\u003E.\u003C\/li\u003E\n\u003Cli\u003EUse \u003Cspan class=\u0022code\u0022\u003Epydnet.py\u003C\/span\u003E to parse \u003Cspan class=\u0022code\u0022\u003EBin-123.fixed.exe\u003C\/span\u003E and update the RVA field of each method entry in the MethodDef table to point to the correct RVA into the new section.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EThe final result is a partially reconstructed .NET assembly. Although additional work is necessary to get this assembly to run correctly, it is good enough to perform static analysis to understand the malware\u2019s high-level functionalities.\u003C\/p\u003E\n\u003Cp\u003ELet\u2019s look at the reconstructed method \u003Cspan class=\u0022code\u0022\u003E0x0600043E\u003C\/span\u003E that implements the decryption logic for the malware configuration. Compared to the original MSIL, the reconstructed MSIL now shows that the malware uses \u003Cspan class=\u0022code\u0022\u003EAES-256\u003C\/span\u003E in \u003Cspan class=\u0022code\u0022\u003ECBC\u003C\/span\u003E mode with \u003Cspan class=\u0022code\u0022\u003EPKCS7\u003C\/span\u003E padding. With a combination of dynamic analysis and static analysis, we can also easily identify the key to be \u201c\u003Cspan class=\u0022code\u0022\u003EVewgbprxvhvjktmyxofjvpzgazqszaoo\u003C\/span\u003E\u201d and the IV to be part of the \u003Cspan class=\u0022code\u0022\u003EBase64\u003C\/span\u003E-encoded buffer passed in as its argument.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/masslogger\/figure17.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 17: Method 0x0600043 before and after fixing the assembly\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EArmed with that knowledge, we can write a simple tool to decrypt the malware configuration and recover all HBIs and NBIs (Figure 18).\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003E \u0026nbsp;BinderBytes: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; BinderName: Mzvmy_Nyrrd\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; BinderOnce: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; DownloaderFilename: Hrebxs\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; DownloaderOnce: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;DownloaderUrl: Vrwus\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EmailAddress: appfoil@outlook.com\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EmailClient: smtp.outlook.com\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EmailEnable: true\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EmailPass: services000\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EmailPort: 587\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EmailSendTo: appfoil@outlook.com\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EmailSsl: True\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableAntiDebugger: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableAntiHoneypot: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableAntiSandboxie: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableAntiVMware: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableBinder: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableBotKiller: false\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableBrowserRecovery: true\u003Cbr\u003E\n EnableDeleteZoneIdentifier: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableDownloader: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableForceUac: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableInstall: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableKeylogger: true\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableMemoryScan: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableMutex: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableScreenshot: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableSearchAndUpload: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableSpreadUsb: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;EnableWDExclusion: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; EnableWindowSearcher: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;ExectionDelay: 6\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;ExitAfterDelivery: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;FtpEnable: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;FtpHost: ftp:\/\/127.0.0.1\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;FtpPass:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;FtpPort: 21\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;FtpUser: Foo\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;InstallFile: Pkkbdphw\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;InstallFolder: %AppData%\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;InstallSecondFolder: Eqrzwmf\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Key:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Mutex: Ysjqh\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;PanelEnable: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;PanelHost: http:\/\/example.com\/panel\/upload.php\u003Cbr\u003E\n \u0026nbsp;SearchAndUploadExtensions: .jpeg, .txt, .docx, .doc,\u003Cbr\u003E\n \u0026nbsp; SearchAndUploadSizeLimit: 500000\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; SearchAndUploadZipSize: 5000000\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; SelfDestruct: false\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;SendingInterval: 2\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Version: MassLogger v1.3.4.0\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; WindowSearcherKeywords: youtube, facebook, amazon,\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 18: Decrypted configuration\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EUsing a JIT compiler hook to replace the MSIL is a powerful technique that makes static analysis almost impossible. Although this technique is not new, I haven\u2019t seen many .NET malwares making use of it, let alone trying to implement their own adaptation instead of using widely available protectors like ConfuserEx. Hopefully, with this blog post and \u003Cspan class=\u0022code\u0022\u003E\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/jitm\u0022\u003EJITM\u003C\/a\u003E\u003C\/span\u003E, analysts will now have the tools and knowledge to defeat MassLogger or any future variants that use a similar technique.\u003C\/p\u003E\n\u003Cp\u003EIf this is the type of work that excites you; and, if you thrive to push the state of the art when it comes to malware analysis and reverse engineering, the Front Line Applied Research and Expertise (FLARE) team may be a good place for you. The FLARE team faces fun and exciting challenges on a daily basis; and we are constantly looking for more team members to tackle these challenges head on. Check out \u003Ca href=\u0022https:\/\/www.fireeye.com\/company\/jobs.html\u0022\u003EFireEye\u2019s career page\u003C\/a\u003E to see if any of our opportunities would be a good fit for you.\u003C\/p\u003E\n\u003Ch4\u003EContributors (Listed Alphabetically)\u003C\/h4\u003E\n\u003Cul\u003E\n\u003Cli\u003ETyler Dean (\u003Ca href=\u0022https:\/\/twitter.com\/spresec\u0022\u003E@spresec\u003C\/a\u003E): Technical review of the post\u003C\/li\u003E\n\u003Cli\u003EMichael Durakovich: Technical review of the post\u003C\/li\u003E\n\u003Cli\u003EStephen Eckels (\u003Ca href=\u0022https:\/\/github.com\/stevemk14ebr\/\u0022\u003E@stevemk14ebr\u003C\/a\u003E): Help with porting JITM to use PolyHook\u003C\/li\u003E\n\u003Cli\u003EJon Erickson (\u003Ca href=\u0022https:\/\/github.com\/evil-e\u0022\u003E@evil-e\u003C\/a\u003E): Technical review of the post\u003C\/li\u003E\n\u003Cli\u003EMoritz Raabe (\u003Ca href=\u0022https:\/\/twitter.com\/m_r_tz?lang=en\u0022\u003E@m_r_tz\u003C\/a\u003E): Technical review of the post\u003C\/li\u003E\n\u003C\/ul\u003E\n",
        "jcr:lastModified": "Sat Aug 22 2020 20:38:17 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EWe discuss and share a tool we used to analyze MassLogger, a fairly new credential stealer that employs a sophisticated technique to hinder static analysis.\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Aug 06 2020 18:23:23 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Aug 06 2020 19:22:00 GMT+0000",
      "imageRotate": "0"
    }
  }
}
