{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Fri Jan 31 2020 16:48:33 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Abusing DLL Misconfigurations \u2014 Using Threat Intelligence to Weaponize R\u0026D",
    "jcr:versionHistory": "8f5d503e-c4d9-4e7b-a8d8-8bad6a885809",
    "author": "Evan Pena",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "ebd266fb-4333-4216-b596-e5eaccdb077b"
    ],
    "jcr:created": "Fri Jan 31 2020 16:48:33 GMT+0000",
    "cq:lastModified": "Fri Jan 31 2020 16:48:19 GMT+0000",
    "jcr:baseVersion": "ebd266fb-4333-4216-b596-e5eaccdb077b",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:evan-pena",
      "fireeye-blog-authors:ruben-boonen",
      "fireeye-blog-authors:brett-hawkins",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:dll",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:red-teaming",
      "fireeye-blog-tags:intelligence",
      "fireeye-blog-tags:sideloading"
    ],
    "jcr:uuid": "b90b1f76-3d2e-4894-b795-1d5cc9c83cb9",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Fri Jan 31 2020 11:45:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Ch4\u003EDLL Abuse Techniques Overview\u003C\/h4\u003E\n\u003Cp\u003EDynamic-link library (DLL) \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/attack.mitre.org\/techniques\/T1073\/\u0022\u003Eside-loading\u003C\/a\u003E\u0026nbsp;occurs when Windows Side-by-Side (WinSxS) \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/sbscs\/manifests?redirectedfrom=MSDN\u0022\u003Emanifests\u003C\/a\u003E\u0026nbsp;are not explicit about the characteristics of DLLs being loaded by a program. In layman\u2019s terms, DLL side-loading can allow an attacker to trick a program into loading a malicious DLL. If you are interested in learning more about how DLL side-loading works and how we see attackers using this technique, read through our \u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/fireeye-www\/global\/en\/current-threats\/pdfs\/rpt-dll-sideloading.pdf\u0022 adhocenable=\u0022false\u0022\u003Ewhitepaper\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.cyberark.com\/threat-research-blog\/dllspy-tighten-your-defense-by-discovering-dll-hijacking-easily\/\u0022\u003EDLL hijacking\u003C\/a\u003E\u0026nbsp;occurs when an attacker is able to take advantage of the Windows search and load order, allowing the execution of a malicious DLL, rather than the legitimate DLL.\u003C\/p\u003E\n\u003Cp\u003EDLL side-loading and hijacking has been around for years; in fact, FireEye Mandiant was one of the \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2014\/04\/dll-side-loading-another-blind-spot-for-anti-virus.html\u0022\u003Efirst to discover\u0026nbsp;the DLL side-loading technique\u003C\/a\u003E along with \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2010\/07\/malware-persistence-windows-registry.html\u0022\u003EDLL search order hijacking\u003C\/a\u003E\u0026nbsp;back in 2010. So why are we still writing a blog about it? Because it\u2019s still a method that works and is used in real world intrusions! FireEye Mandiant still identifies and observes threat groups using DLL abuse techniques during incident response (IR) engagements. There are still plenty of signed executables vulnerable to this, and our red team has weaponized DLL abuse techniques to be part of our methodology.\u0026nbsp;For detection and preventative measures on DLL abuse techniques, see the \u201cDetection and Preventative Measures\u201d section in this blog post.\u003C\/p\u003E\n\u003Cp\u003EEven though DLL abuse techniques are not new or cutting edge, this blog post will showcase how the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.fireeye.com\/services\/red-team-assessments.html\u0022\u003EFireEye Mandiant red team\u003C\/a\u003E uses \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.fireeye.com\/solutions\/cyber-threat-intelligence.html\u0022\u003EFireEye Intelligence\u003C\/a\u003E to expedite the research phase of identifying vulnerable executables, at scale! We will also walk you through how to discover new executables susceptible to DLL abuse and how the FireEye Mandiant red team has weaponized these DLL abuse techniques in its \u003Ca href=\u0022https:\/\/github.com\/fireeye\/DueDLLigence\u0022\u003EDueDLLigence\u003C\/a\u003E tool. The DueDLLigence tool was initially released to be a \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2019\/10\/staying-hidden-on-the-endpoint-evading-detection-with-shellcode.html\u0022\u003Eframework for application whitelisting bypasses\u003C\/a\u003E, but given the nature of unmanaged exports it can be used for DLL abuse techniques as well.\u003C\/p\u003E\n\u003Ch4\u003ECollecting and Weaponizing FireEye Intelligence\u003C\/h4\u003E\n\u003Cp\u003EA benefit of being part of the red team at FireEye Mandiant is having access to a tremendous amount of threat intelligence; Our organization\u2019s incident response and intelligence consultants have observed, documented, and analysed the actions of attackers across almost every major breach over the past decade. For this project, the FireEye Mandiant red team asked the FireEye Technical Operations and Reverse Engineering Advanced Practices (TORE AP) team to leverage FireEye Intelligence and provide us with all DLL abuse techniques used by attackers that matched the following criteria:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EA \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/debug\/pe-format\u0022\u003Estandalone PE\u0026nbsp;file\u003C\/a\u003E (.exe file) was used to call a malicious DLL\u003C\/li\u003E\n\u003Cli\u003EThe .exe must be signed and the certificate not expire within a year\u003C\/li\u003E\n\u003Cli\u003EThe intelligence about the technique must include the name of the malicious DLL that was called\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EOnce the results were provided to the red team, we started weaponizing the intelligence by taking the approach outlined in the rest of the post, which includes:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EIdentifying executables susceptible to DLL search order hijacking\u003C\/li\u003E\n\u003Cli\u003EIdentifying library dependencies for the executable\u003C\/li\u003E\n\u003Cli\u003ESatisfying API\u2019s exported in the library\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch5\u003EDLL Search Order Hijacking\u003C\/h5\u003E\n\u003Cp\u003EIn many cases it is possible to execute code within the context of a legitimate \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/debug\/pe-format\u0022\u003EPortable Executable\u003C\/a\u003E (PE)\u0026nbsp;by taking advantage of insecure library references. If a developer allows \u003Cspan class=\u0022code\u0022\u003ELoadLibrary\u003C\/span\u003E to resolve the path of a library dynamically then that PE will also look in the current directory for the library DLL. This behavior can be used for malicious purposes by copying a legitimate PE to a directory where the attacker has write access. If the attacker creates a custom payload DLL, then the application will load that DLL and execute the attacker\u2019s code. This can be beneficial for a red team: the PE may be signed and have the appearance of trust to the endpoint security solution (AV\/EDR), it may bypass application white listing (AWL) and can confuse\/delay an investigation process.\u003C\/p\u003E\n\u003Cp\u003EIn this section we will look at one example where we identify the conditions for hijacking a PE and implement the requirements in our payload DLL. For this test case we will use a signed binary PotPlayerMini (MD5: \u003Cspan class=\u0022code\u0022\u003Ef16903b2ff82689404f7d0820f461e5d\u003C\/span\u003E). This PE was chosen since it has been used by attackers dating back to 2016.\u003C\/p\u003E\n\u003Ch5\u003EIdentifying Library Dependencies\u003C\/h5\u003E\n\u003Cp\u003EIt is possible to determine which libraries and exports a PE requires through static analysis with tools such as \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.hex-rays.com\/products\/ida\/\u0022\u003EIDA\u003C\/a\u003E\u0026nbsp;or \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/ghidra-sre.org\/\u0022\u003EGhidra\u003C\/a\u003E. The screenshot shown in Figure 1, for example, shows that PotPlayerMini tries to load a DLL called \u201c\u003Cspan class=\u0022code\u0022\u003EPotPlayer.dll\u003C\/span\u003E\u201d.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Static Analysis of DLL\u0027s loaded by PotPlayerMini\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWhere static analysis is not feasible or desirable it may be possible to use a hooking framework such as \u003Ca adhocenable=\u0022false\u0022 href=\u0022http:\/\/www.rohitab.com\/apimonitor\u0022\u003EAPI Monitor\u003C\/a\u003E\u0026nbsp;or \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/frida.re\u0022\u003EFrida\u003C\/a\u003E\u0026nbsp;to profile the \u003Cspan class=\u0022code\u0022\u003ELoadLibrary\u003C\/span\u003E \/ \u003Cspan class=\u0022code\u0022\u003EGetProcAddress\u003C\/span\u003E behavior of the application.\u003C\/p\u003E\n\u003Cp\u003EIn Figure 2 we used API Monitor to see this same DLL loading behavior. As you can see, PotPlayerMini is looking for the \u003Cspan class=\u0022code\u0022\u003EPotPlayer.dll\u003C\/span\u003E file in its current directory. At this point, we have validated that PotPlayerMini is susceptible to DLL search order hijacking.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Dynamic Analysis of DLL\u0027s loaded by PotPlayerMini\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003ESatisfying Exports\u003C\/h5\u003E\n\u003Cp\u003EAfter identifying potentially vulnerable library modules we need to apply a similar methodology to identify which exports are required from the module PE. Figure 3 shows a decompiled view from PotPlayerMini highlighting which exports it is looking for within the \u003Cspan class=\u0022code\u0022\u003EGetProcAddress\u003C\/span\u003E functions using static analysis. Figure 4 shows performing this same analysis of exports in the PotPlayerMini application, but using dynamic analysis instead.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Static Analysis of exports in PotPlayerMini DLL\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture4.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Dynamic Analysis of exports in PotPlayerMini DLL\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn our case the payload is a .NET DLL which uses \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/3F\/DllExport\u0022\u003EUnmanagedExports\u003C\/a\u003E\u0026nbsp;so we have to satisfy all export requirements from the binary as shown in Figure 5.\u0026nbsp;This is because the .NET UnmanagedExports library does not support \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/dlls\/dllmain\u0022\u003E\u003Cspan class=\u0022code\u0022\u003EDllMain\u003C\/span\u003E\u003C\/a\u003E, since that is an entry point and is not exported. All export requirements need to be satisfied to ensure the DLL has all the functions exported which the program accesses via \u003Cspan class=\u0022code\u0022\u003EGetProcAddress\u003C\/span\u003E or import address table (IAT). These export methods will match those that were observed in the static and dynamic analysis. This may require some trial and error depending on the validation that is present in the binary.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture5.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Adding export requirements in .NET DLL\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce we execute the binary, we can see that it successfully executes our function as shown in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture6.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Executing binary susceptible to DLL abuse\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003EDLL Hijacking Without Satisfying All Exports\u003C\/h5\u003E\n\u003Cp\u003EWhen writing a payload DLL in C\/C++ it is possible to hijack control flow in \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/dlls\/dllmain\u0022\u003E\u003Cspan class=\u0022code\u0022\u003EDllMain\u003C\/span\u003E\u003C\/a\u003E. When doing this it is not necessary to enumerate and satisfy all needed exports as previously described. There also may be cases where the DLL does not have any\u0026nbsp;exports and can only be hijacked via the\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003EDllMain\u003C\/span\u003E\u0026nbsp;entry point.\u003C\/p\u003E\n\u003Cp\u003EAn example of this can be shown with the Windows Media Player Folder Sharing executable called \u003Cspan class=\u0022code\u0022\u003Ewmpshare.exe\u003C\/span\u003E. You can copy the executable to a directory out of its original location (\u003Cspan class=\u0022code\u0022\u003EC:\\Program Files (x86)\\Windows Media Player\u003C\/span\u003E) and perform dynamic analysis using API Monitor. In Figure 7, you can see that the wmpshare.exe program uses the \u003Cspan class=\u0022code\u0022\u003ELoadLibraryW\u003C\/span\u003E method to load the \u003Cspan class=\u0022code\u0022\u003Ewmp.dll file\u003C\/span\u003E, but does not specify an explicit path to the DLL. When this happens, the \u003Cspan class=\u0022code\u0022\u003ELoadLibraryW\u003C\/span\u003E method will first search the directory in which the process was created (present working directory). Full details on the search order used can be found in \u0026nbsp;the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/libloaderapi\/nf-libloaderapi-loadlibraryw\u0022\u003E\u003Cspan class=\u0022code\u0022\u003ELoadLibraryW\u003C\/span\u003E documentation\u003C\/a\u003E\u0026nbsp;and the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/processthreadsapi\/nf-processthreadsapi-createprocessa\u0022\u003E\u003Cspan class=\u0022code\u0022\u003ECreateProcess\u003C\/span\u003E documentation\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Viewing LoadLibrary calls in wmpshare.exe\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ESince it does not specify an explicit path, you can test if it can be susceptible to DLL hijacking by creating a blank file named \u201c\u003Cspan class=\u0022code\u0022\u003Ewmp.dll\u003C\/span\u003E\u201d and copying it to the same directory as the \u003Cspan class=\u0022code\u0022\u003Ewmpshare.exe\u003C\/span\u003E file. Now when running the wmpshare executable in API Monitor, you can see it is first checking in its current directory for the \u003Cspan class=\u0022code\u0022\u003Ewmp.dll\u003C\/span\u003E file, shown in Figure 8. Therefore, it is possible to use this binary for DLL hijacking.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture8.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Viewing LoadLibrary calls in wmpshare.exe with dummy dll present\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 9 shows using the wmpshare executable in a weaponized manner to take advantage of the \u003Cspan class=\u0022code\u0022\u003EDllMain\u003C\/span\u003E entry point with a DLL created in C++.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture9.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Using the DllMain entry point\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EDiscovering New Executables Susceptible to DLL Abuse\u003C\/h4\u003E\n\u003Cp\u003EIn addition to weaponizing the FireEye intelligence of the executables used for DLL abuse by attackers, the FireEye Mandiant red team performed research to discover new executables susceptible to abuse by targeting Windows system utilities and third-party applications.\u003C\/p\u003E\n\u003Ch5\u003EWindows System Utilities\u003C\/h5\u003E\n\u003Cp\u003EThe FireEye Mandiant red team used the methodology previously described in the Collecting and Weaponizing FireEye Intelligence section to look at Windows system utilities present in the \u003Cspan class=\u0022code\u0022\u003EC:\\Windows\\System32\u003C\/span\u003E directory that were susceptible to DLL abuse techniques. One of the system utilities found was the deployment image servicing and management (DISM) utility (\u003Cspan class=\u0022code\u0022\u003EDism.exe\u003C\/span\u003E). When performing dynamic analysis of this system utility, it was observed that it was attempting to load the \u003Cspan class=\u0022code\u0022\u003EDismCore.dll\u003C\/span\u003E file in the current directory as shown in Figure 10.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture10.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Performing dynamic analysis of Dism utility\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENext, we loaded the DISM system utility into API Monitor from its normal path (\u003Cspan class=\u0022code\u0022\u003EC:\\Windows\\System32\u003C\/span\u003E) in order to see the required exports as shown in Figure 11.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture11.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Required exports for DismCore.dll\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe code shown in Figure 12 was added to \u003Ca href=\u0022https:\/\/github.com\/fireeye\/DueDLLigence\u0022\u003EDueDLLigence\u003C\/a\u003E to validate that the DLL was vulnerable and could be ran successfully using the DISM system utility.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture12.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: Dism export method added to DueDLLigence\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003EThird-Party Applications\u003C\/h5\u003E\n\u003Cp\u003EThe FireEye Mandiant red team also targeted executable files associated with common third-party applications that could be susceptible to DLL abuse. One of the executable files discovered was a \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/tortoisesvn.net\/\u0022\u003ETortoise SVN\u003C\/a\u003E\u0026nbsp;utility (\u003Cspan class=\u0022code\u0022\u003ESubWCRev.exe\u003C\/span\u003E).\u0026nbsp; When performing dynamic analysis of this Tortoise SVN utility, it was observed that it was attempting to load \u003Cspan class=\u0022code\u0022\u003Ecrshhndl.dll\u003C\/span\u003E in the current directory. The export methods are shown in Figure 13.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture13.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 13: Performing dynamic analysis of SubWCRev.exe\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe code shown in Figure 14 was added to \u003Ca href=\u0022https:\/\/github.com\/fireeye\/DueDLLigence\u0022\u003EDueDLLigence\u003C\/a\u003E to validate that the DLL was vulnerable and could be ran successfully using the Tortoise SVN utility.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture14.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 14: SubWCRev.exe export methods added to DueDLLigence\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EApplying It to the Red Team\u003C\/h4\u003E\n\u003Cp\u003EHaving a standalone trusted executable allows the red team to simply copy the trusted executable and malicious DLL to a victim machine and bypass various host-based security controls, including application whitelisting. Once the trusted executable (vulnerable to DLL abuse) and malicious DLL are both in the same present working directory, the executable will call the corresponding DLL within the same directory. This method can be used in multiple phases of the attack lifecycle as payload implants, including phases such as establishing persistence and performing lateral movement.\u003C\/p\u003E\n\u003Ch5\u003EPersistence\u003C\/h5\u003E\n\u003Cp\u003EIn this example, we will be using the Windows system utility \u003Cspan class=\u0022code\u0022\u003EDism.exe\u003C\/span\u003E discovered in the Windows System Utilities section as our executable, along with a DLL generated by \u003Ca href=\u0022https:\/\/github.com\/fireeye\/DueDLLigence\u0022\u003EDueDLLigence\u003C\/a\u003E in conjunction with \u003Ca href=\u0022https:\/\/github.com\/fireeye\/SharPersist\u0022\u003ESharPersist\u003C\/a\u003E to establish persistence on a target system. First, the DISM system utility and malicious DLL are uploaded to the target system as shown in Figure 15.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture15.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 15: Uploading payload files\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThen we use \u003Ca href=\u0022https:\/\/github.com\/fireeye\/SharPersist\u0022\u003ESharPersist\u003C\/a\u003E to add \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/attack.mitre.org\/techniques\/T1060\/\u0022\u003Estartup folder persistence\u003C\/a\u003E, which uses our DISM system utility and associated DLL as shown in Figure 16.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture16.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 16: Adding startup folder persistence with SharPersist\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAfter the target machine has been rebooted and the targeted user has logged on, Figure 17 shows our Cobalt Strike C2 server receiving a beacon callback from our startup folder persistence where we are living in the \u003Cspan class=\u0022code\u0022\u003EDism.exe\u003C\/span\u003E process.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture17.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 17: Successful persistence callback\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003ELateral Movement\u003C\/h5\u003E\n\u003Cp\u003EWe will continue using the same DISM system utility and DLL file for lateral movement. The \u003Cspan class=\u0022code\u0022\u003EHOGWARTS\\adumbledore\u003C\/span\u003E user has administrative access to the remote host \u003Cspan class=\u0022code\u0022\u003E192.168.1.101\u003C\/span\u003E in this example. We transfer the DISM system utility and the associated DLL file via the SMB protocol to the remote host as shown in Figure 18.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture18.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 18: Transferring payload files to remote host via SMB\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThen we setup a SOCKS proxy in our initial beacon, and use Impacket\u2019s \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/SecureAuthCorp\/impacket\/blob\/master\/examples\/wmiexec.py\u0022\u003Ewmiexec.py\u003C\/a\u003E\u0026nbsp;to execute our payload via the Windows Management Instrumentation (WMI) protocol, as shown in Figure 19 and Figure 20.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022623\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Eproxychains python wmiexec.py -nooutput DOMAIN\/user:password:@x.x.x.x C:\\\\Temp\\\\Dism.exe\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 19: Executing payload via WMI with Impacket\u2019s wmiexec.py\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture20.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 20: Output of executing command shown in Figure 19\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe receive a beacon from the remote host, shown in Figure 21, after executing the DISM system utility via WMI.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/sideloading\/Picture21.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 21: Obtaining beacon on remote host\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EDetection and Preventative Measures\u003C\/h4\u003E\n\u003Cp\u003EDetailed prevention and detection methods for DLL side-loading are well documented in the \u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/fireeye-www\/global\/en\/current-threats\/pdfs\/rpt-dll-sideloading.pdf\u0022\u003Ewhitepaper\u003C\/a\u003E\u0026nbsp;and mentioned in the DLL Abuse Techniques Overview. The whitepaper breaks it down into preventative measures at the software development level and goes into recommendations for the endpoint user level. A few detection methods that are not mentioned in the whitepaper include:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EChecking for processes that have unusual network connectivity\u003Cul\u003E\n\u003Cli\u003EIf you have created a baseline of normal process network activity, and network activity for a given process has become different than the baseline, it is possible the said process has been compromised.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003Cli\u003EDLL whitelisting\u003Cul\u003E\n\u003Cli\u003ETrack the hashes of DLLs used on systems to identify discrepancies.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EThese detection methods are difficult to implement at scale, but possible to utilize. That is exactly why this old technique is still valid and used by modern red teams and threat groups. The real problem that allows this vulnerability to continue to exist has to do with software publishers. Software publishers need to be aware of DLL abuse techniques and know how to prevent such vulnerabilities from being developed into products (e.g. by implementing the mitigations discussed in our \u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/fireeye-www\/global\/en\/current-threats\/pdfs\/rpt-dll-sideloading.pdf\u0022\u003Ewhitepaper\u003C\/a\u003E). Applying these recommendations will reduce the DLL abuse opportunities attackers use to bypass several modern-day detection techniques.\u003C\/p\u003E\n\u003Cp\u003EMicrosoft has provided some great resources on \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/dlls\/dynamic-link-library-security\u0022\u003EDLL security\u003C\/a\u003E and \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/msrc-blog.microsoft.com\/2018\/04\/04\/triaging-a-dll-planting-vulnerability\/\u0022\u003Etriaging a DLL hijacking vulnerability\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EThreat intelligence provides immense value to red teamers who are looking to perform offensive research and development and emulate real-life attackers. By looking at what real attackers are doing, a red teamer can glean inspiration for future tooling or TTPs.\u003C\/p\u003E\n\u003Cp\u003EDLL abuse techniques can be helpful from an evasion standpoint in multiple phases of the attack lifecycle, such as persistence and lateral movement. There will continue to be more executables discovered that are susceptible to DLL abuse and used by security professionals and adversaries alike.\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Jan 30 2020 22:18:25 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EGiven the nature of unmanaged exports, our previously released DueDLLigence tool can also be used for DLL abuse techniques.\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Jan 30 2020 21:40:44 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Fri Jan 31 2020 16:48:19 GMT+0000",
      "imageRotate": "0"
    }
  }
}
