{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Mon Nov 09 2020 19:05:04 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "WOW64!Hooks: WOW64 Subsystem Internals and Hooking Techniques",
    "jcr:versionHistory": "d7e34939-dee2-414b-8b49-457d87378bce",
    "author": "Stephen Eckels",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "d8f2445c-8464-4978-8cfe-1929125dd1a7"
    ],
    "jcr:created": "Mon Nov 16 2020 18:01:04 GMT+0000",
    "cq:lastModified": "Mon Nov 16 2020 17:59:03 GMT+0000",
    "jcr:baseVersion": "d8f2445c-8464-4978-8cfe-1929125dd1a7",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:stephen-eckels",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:detection",
      "fireeye-blog-tags:evasion",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:windows",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "ca78fa4b-bb7d-4209-9f86-ab1135bfe97a",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Mon Nov 09 2020 14:00:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EMicrosoft is known for their backwards compatibility. When they rolled out the 64-bit variant of Windows years ago they needed to provide compatibility with existing 32-bit applications. In order to provide seamless execution regardless of application bitness, the WoW (Windows on Windows) system was coined. This layer, which will be referred to as \u2018WOW64\u2019 from here on out, is responsible for translating all Windows API calls from 32-bit userspace to the 64-bit operating system kernel. This blog post is broken up into two sections. First we start by diving deep into the WOW64 system. To do this, we trace a call from 32-bit userspace and follow the steps it takes to finally transition to the kernel. The second part of the post assesses two hooking techniques and their effectiveness. I will cover how this system works, the ways malware abuses it, and detail a mechanism by which all WoW syscalls can be hooked from userspace. Note that all information here is true as of Windows 10, version 2004 and in some cases \u003Ci\u003Ehas\u003C\/i\u003E changed from how previous Windows versions were implemented.\u003C\/p\u003E\n\u003Ch4\u003ERecognition\u003C\/h4\u003E\n\u003Cp\u003EFirst and foremost, this is a topic which has existing research by multiple authors. This work was critical in efficient exploration of the internals and research would have taken much longer had these authors not publicly posted their awesome work. I would like to callout the following references:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E(\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/wbenny.github.io\/2018\/11\/04\/wow64-internals.html\u0022\u003Ewbenny\u003C\/a\u003E): An extremely detailed view of WOW64 internals on ARM\u003C\/li\u003E\n\u003Cli\u003E(\u003Ca adhocenable=\u0022false\u0022 href=\u0022http:\/\/blog.rewolf.pl\/blog\/?p=102\u0022\u003EReWolf\u003C\/a\u003E): A PoC heaven\u2019s gate implementation\u003C\/li\u003E\n\u003Cli\u003E(\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/JustasMasiulis\/wow64pp\u0022\u003EJustasMasiulis\u003C\/a\u003E): A very clean C++ heaven\u2019s gate implementation\u003C\/li\u003E\n\u003Cli\u003E(\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.malwaretech.com\/2014\/02\/the-0x33-segment-selector-heavens-gate.html\u0022\u003EMalwareTech\u003C\/a\u003E): A WOW64 segmentation explanation\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003EWOW64 Internals\u003C\/h4\u003E\n\u003Cp\u003ETo understand how the WOW64 system works internally we will explore the call sequence starting in 32-bit usermode before transitioning into the kernel from within a system DLL. Within these system DLLs the operating system will check arguments and eventually transition to a stub known as a syscall stub. This syscall stub is responsible for servicing the API call in the kernel. On a 64-bit system, the syscall stub is straightforward as it directly executes the syscall instruction as shown in Figure 1.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Native x64 Syscall Stub\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 2 shows a syscall stub for a 32-bit process running on WOW64\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: WOW64 Syscall Stub\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENotice that instead of a syscall instruction in the WOW64 version, \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceCall\u003C\/span\u003E is called. In the WOW64 system what would normally be an entry into the kernel is instead replaced by a call to a usermode routine. Following this \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceCall\u003C\/span\u003E, we can see in Figure 3 that it immediately performs an indirect jmp through a pointer named \u003Cspan class=\u0022code\u0022\u003EWow64Transition\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Wow64SystemService transitions through a pointer \u2018Wow64Transition\u2019\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENote that the \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceCall\u003C\/span\u003E function is found within ntdll labeled as ntdll_77550000; a WOW64 process has two ntdll modules loaded, a 32-bit one and a 64-bit one. WinDbg differentiates between these two by placing the address of the module after the 32-bit variant. The 64-bit ntdll can be found in %WINDIR%\\System32 and the 32-bit in %WINDIR%\\SysWOW64. In the PDBs, the 64bit and 32bit ntdlls are referred to as ntdll.pdb and wntdll.pdb respectively, try loading them in a disassembler! Continuing with the call trace, if we look at what the \u003Cspan class=\u0022code\u0022\u003EWow64Transition\u003C\/span\u003E pointer holds we can see its destination is \u003Cspan class=\u0022code\u0022\u003Ewow64cpu!KiFastSystemCall\u003C\/span\u003E. As an aside, note that the address of \u003Cspan class=\u0022code\u0022\u003Ewow64cpu!KiFastSystemCall\u003C\/span\u003E is held in the 32-bit TEB (Thread Environment Block) via member WOW32Reserved, this isn\u2019t relevant for this trace but is useful to know. In Figure 4 we see the body of \u003Cspan class=\u0022code\u0022\u003EKiFastSystemCall\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure4.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: KiFastSystemCall transitions to x64 mode via segment selector 0x33\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003EKiFastSystemCall\u003C\/span\u003E performs a jmp using the 0x33 segment selector to a memory location just after the instruction. This 0x33 segment transitions the CPU into 64-bit mode via a GDT entry as described by (MalwareTech).\u003C\/p\u003E\n\u003Cp\u003ELet\u0027s recap the trace we\u0027ve performed to this point. We started from a call in ntdll, NtResumeThread. This function calls the Wow64SystemServiceCall function which then executes the Wow64Transition. The KiFastSystemCall performs the transition from 32-bit to 64-bit execution. The flow is shown in Figure 5.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure5.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: 32-bit to 64-bit transition\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe destination of the CPU transition jump is the 64-bit code show in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure6.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Destination of KiFastSystemCall\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 6 shows the first 64-bit instruction we\u2019ve seen executed in this call trace so far. In order to understand it, we need to look at how the WOW64 system initializes itself. For a detailed explanation of this refer to (wbenny). For now, we can look at the important parts in \u003Cspan class=\u0022code\u0022\u003Ewow64cpu!RunSimulatedCode\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: 64bit registers are saved in RunSimulatedCode\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 7 depicts the retrieval of the 64-bit TEB which is used to access Thread Local Storage at slot index 1. Then the moving of a function pointer table into register r15. The TLS data retrieved is an undocumented data structure \u003Cspan class=\u0022code\u0022\u003EWOW64_CPURESERVED\u003C\/span\u003E that contains register data and CPU state information used by the WOW64 layer to set and restore registers across the 32-bit and 64-bit boundaries. Within this structure is the \u003Cspan class=\u0022code\u0022\u003EWOW64_CONTEXT\u003C\/span\u003E structure, \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/winnt\/ns-winnt-wow64_context\u0022\u003Epartially documented on the Microsoft website\u003C\/a\u003E. I have listed both structures at the end of this post. We\u2019ll look at how this context structure is used later, but for our understanding of the jmp earlier all we need to know is that r15 is a function pointer table.\u003C\/p\u003E\n\u003Cp\u003EIt\u2019s interesting to note at this point the architecture of the WOW64 layer. From the perspective of the 64-bit kernel the execution of 32-bit (Wow64) usermode applications is essentially a big while loop. The loop executes x86 instructions in the processor\u0027s 32-bit execution mode and occasionally exits the loop to service a system call. Because the kernel is 64-bit, the processor mode is temporarily switched to 64-bit, the system call serviced, then the mode switched back and the loop continued where it was paused. One could say the WOW64 layer acts like an emulator where the instructions are instead executed on the physical CPU.\u003C\/p\u003E\n\u003Cp\u003EGoing back to the jmp instruction we saw in Figure 6, we now know what is occurring. The instruction jmp [r15 + 0xF8] is equivalent to the C code jmp TurboThunkDispatch[0xF8 \/ sizeof(uint64_t)]. Looking at the function pointer at this index we can see we\u2019re at the function \u003Cspan class=\u0022code\u0022\u003Ewow64cpu!CpupReturnFromSimulatedCode\u003C\/span\u003E (Figure 8).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure8.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: TurboThunk table\u0027s last function pointer entry is an exit routine\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis routine is responsible for saving the state of the 32-bit registers into the \u003Cspan class=\u0022code\u0022\u003EWOW64_CONTEXT\u003C\/span\u003E structure we mentioned before as well as retrieving the arguments for the syscall. There is some trickiness going on here, so let\u2019s examine this in detail. First a pointer to the stack is moved into r14 via xchg, the value at this location will be the return address from the syscall stub where \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceCall\u003C\/span\u003E was called. The stack pointer r14 is then incremented by 4 to get a pointer to where the stack should be reset when it\u2019s time to restore all these context values. These two values are then stored in the context\u2019s EIP and ESP variables respectively. The r14 stack pointer is then incremented one more time to get the location where the __stdcall arguments are (remember stdcall passes all arguments on the stack). This argument array is important for later, remember it. The arguments pointer is moved into r11, so in C this means that r11 is equivalent to an array of stack slots where each slot is an argument uint32_t r11[argCount]. The rest of the registers and EFlags are then saved.\u003C\/p\u003E\n\u003Cp\u003EOnce the 32-bit context is saved, the WOW64 layer then calculates the appropriate TurboThunk to invoke by grabbing the upper 16 bits of the syscall number and dispatches to that thunk. Note that at the beginning of this array is the function \u003Cspan class=\u0022code\u0022\u003ETurboDispatchJumpAddressEnd\u003C\/span\u003E, shown in Figure 9, which is invoked for functions that do not support TurboThunks.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure9.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: TurboThunk table\u0027s first function pointer entry is an entry routine\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ETurboThunks are described by (wbenny)\u2014read his blog post at this point if you have not. To summarize the post, for functions that have simple arguments with widths \u0026lt;= sizeof(uint32_t) the WOW64 layer will directly widen these arguments to 64 bits via zero or sign-extension and then perform a direct syscall into the kernel. This all occurs within wow64cpu, rather than executing a more complex path detailed as follows. This acts as an optimization. For more complex functions that do not support TurboThunks the \u003Cspan class=\u0022code\u0022\u003ETurboDispatchJumpAddressEnd\u003C\/span\u003E stub is used which dispatches to \u003Cspan class=\u0022code\u0022\u003Ewow64!SystemServiceEx\u003C\/span\u003E to perform the system call as shown in Figure 10.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure10.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Complex system calls go through Wow64SystemServiceEx\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe\u2019ll look at this routine in a moment as it\u2019s the meat of this blog post, but for now let\u2019s finish this call trace. Once \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceEx\u003C\/span\u003E returns from doing the system call the return value in eax is moved into the \u003Cspan class=\u0022code\u0022\u003EWOW64_CONTEXT\u003C\/span\u003E structure and then the 32-bit register states are restored. There\u2019s two paths for this, a common case and a case that appears to exist only to be used by \u003Cspan class=\u0022code\u0022\u003ENtContinue\u003C\/span\u003E and other WOW64 internals. A flag at the start of the \u003Cspan class=\u0022code\u0022\u003EWOW64_CPURESERVED\u003C\/span\u003E structure retrieved from the\u0026nbsp;TLS slot is checked, and controls which restore path to follow as shown in Figure 11.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure11.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: CPU state is restored once the system call is done; there\u2019s a simple path and a complex one handling XMM registers\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe simpler case will build a jmp that uses the segment selector 0x23 to transition back to 32-bit mode after restoring all the saved registers in the \u003Cspan class=\u0022code\u0022\u003EWOW64_CONTEXT\u003C\/span\u003E. The more complex case will additionally restore some segments, xmm values, and the saved registers in the \u003Cspan class=\u0022code\u0022\u003EWOW64_CONTEXT\u003C\/span\u003E structure and then will do an iret to transition back. The common case jmp once built is shown in Figure 12.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure12.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: Dynamically built jmp to transition back to 32bit mode\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAt this point our call trace is complete. The WOW64 layer has transitioned back to 32-bit mode and will continue execution at the ret after \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceCall\u003C\/span\u003E in the syscall stub we started with. Now that an understanding of the flow of the WOW64 layer itself is understood, let\u2019s examine the \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceEx\u003C\/span\u003E call we glossed over before.\u003C\/p\u003E\n\u003Cp\u003EA little bit into the \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceEx\u003C\/span\u003E routine, Figure 13 shows some interesting logic that we will use later.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure13.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 13: Logging routines invoked before and after dispatching the syscalls\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe routine starts by indexing into service tables which hold pointers to routines that convert the passed argument array into the wider 64-bit types expected by the regular 64-bit system modules. This argument array is exactly the stack slot that was stored earlier in r14.\u003C\/p\u003E\n\u003Cp\u003ETwo calls to the \u003Cspan class=\u0022code\u0022\u003ELogService\u003C\/span\u003E function exist, however these are only called if the DLL %WINDIR%\\system32\\wow64log.dll is loaded and has the exports Wow64LogInitialize, Wow64LogSystemService, Wow64LogMessageArgList, and Wow64LogTerminate. This DLL is not present on Windows by default, but it can be placed there with administrator privileges.\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003EThe next section will detail how this logging DLL can be used to hook syscalls that transition through this wow64layer. Because the logging routine \u003Cspan class=\u0022code\u0022\u003ELogService\u003C\/span\u003E is invoked before and after the syscall is serviced we can achieve a standard looking inline hook style callback function capable of inspecting arguments and return values.\u003C\/p\u003E\n\u003Ch4\u003EBypassing Inline Hooks\u003C\/h4\u003E\n\u003Cp\u003EAs described in this blog post, Windows provides a way for 32-bit applications to execute 64-bit syscalls on a 64-bit system using the WOW64 layer. However, the segmentation switch we noted earlier can be manually performed, and 64-bit shellcode can be written to setup a syscall. This technique is popularly called \u201cHeaven\u2019s Gate\u201d. JustasMasiulis\u2019 work \u003Ca href=\u0022https:\/\/github.com\/JustasMasiulis\/wow64pp\/blob\/be72557d0bd2e997d985fd9c590529b62de3765b\/include\/wow64pp.hpp#L727\u0022\u003Ecall_function64\u003C\/a\u003E can be used as a reference to see how this may be done in practice (JustasMasiulis). When system calls are performed this way the 32-bit syscall stub that the WOW64 layer uses is completely skipped in the execution chain. This is unfortunate for security products or tracing tools because any inline hooks in-place on these stubs are also bypassed. Malware authors know this and utilize \u201cHeaven\u2019s Gate\u201d as a bypass technique in some cases. Figure 14 and Figure 15 shows the execution flow of a regular syscall stub through the WOW64 layer, and hooked syscall stub where malware utilizes \u201cHeaven\u2019s Gate\u201d.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure14.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 14: NtResumeThread transitioning through the WOW64 layer\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure15b.png\u0022 alt=\u0022\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003E\u003Cbr\u003E\nFigure 15: NtResumeThread inline hook before transitioning through the WOW64 layer\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAs seen in Figure 15, when using the Heaven\u2019s Gate technique, execution begins \u003Ci\u003Eafter\u003C\/i\u003E the inline hook and WOW64 layer is done. This is an effective bypass technique, but one that is easy to detect from a lower level such as a driver or hypervisor. The easiest bypass to inline hooks is simply to restore the original function bytes, usually from bytes on disk. Malware such as AgentTesla and Conti has been known to utilize this last evasion technique.\u003C\/p\u003E\n\u003Ch4\u003EHooking WOW64 via Inline Hooks\u003C\/h4\u003E\n\u003Cp\u003EAs a malware analyst being able to detect when samples attempt to bypass the WOW64 layer can be very useful. The obvious technique to detect this is to place inline hooks on the 64-bit syscall stubs as well as the 32-bit syscall stubs. If the 64-bit hook detects an invocation that didn\u2019t also pass through the 32-bit hook, then it\u2019s known that a sample is utilizing Heaven\u2019s Gate. This technique can detect both evasion techniques previously detailed. However, in practice this is very difficult to implement. Looking at the requirements that must be satisfied to hook the 64-bit syscall stub we come up with this list:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EInstall 64-bit hook from a 32-bit module\u003Cul\u003E\n\u003Cli\u003EHow do you read\/write 64-bit address space from a 32-bit module?\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003Cli\u003EImplement a 64-bit callback from a 32-bit module\u003Cul\u003E\n\u003Cli\u003ETypically, inline hooking uses C functions as callback stubs, but we\u2019re compiling a 32-bit module so we\u2019ll have a 32-bit callback instead of the required 64-bit one.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003ETo solve the first challenge ntdll kindly provides the exports \u003Cspan class=\u0022code\u0022\u003ENtWow64ReadVirtualMemory64\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003ENtWow64WriteVirtualMemory64\u003C\/span\u003E, and \u003Cspan class=\u0022code\u0022\u003ENtWow64QueryInformationProcess64\u003C\/span\u003E. Using these it is possible to read memory, write memory, and retrieve the PEB of a 64-bit module from a 32-bit process. However, the second challenge is much harder as either shellcode or a JIT will be required to craft a callback stub of the right bitness. In practice ASMJIT may be utilized for this. This is however a very tedious technique to trace a large number of APIs. There are other challenges to this technique as well. For example, in modern Windows 10 the base address of ntdll64 is set to a high 64-bit address rather than a lower 32-bit address as in Windows 7. Due to this, supporting returns from callbacks back up to the original hooked stub and allocating a trampoline within the required memory range is difficult since the standard ret instruction doesn\u2019t have enough bits on the stack to represent the 64-bit return address.\u003C\/p\u003E\n\u003Cp\u003EAs an aside, it should be noted that the WOW64 layer contains what is likely a bug when dealing with the \u003Cspan class=\u0022code\u0022\u003ENtWow64*\u003C\/span\u003E functions. These APIs all take a \u003Cspan class=\u0022code\u0022\u003EHANDLE\u003C\/span\u003E as first argument, which \u003Ci\u003Eshould\u003C\/i\u003E be sign extended to 64-bits. However, this does not occur for these APIs, therefore when using the pseudo handle -1 the call fails with \u003Cspan class=\u0022code\u0022\u003ESTATUS_INVALID_HANDLE\u003C\/span\u003E. This bug was introduced in an unknown Windows 10 version. To successfully use these APIs \u003Cspan class=\u0022code\u0022\u003EOpenProcess\u003C\/span\u003E must be used to retrieve a real, positive valued handle.\u003C\/p\u003E\n\u003Cp\u003EI will not be covering the internals of how to inline hook the 64-bit syscall stub since this post is already very long. Instead I will show how my hooking library \u003Ca href=\u0022https:\/\/github.com\/stevemk14ebr\/PolyHook_2_0\u0022\u003EPolyHook2\u003C\/a\u003E can be extended to support cross-architecture hooking using these Windows APIs, and leave the rest as an exercise to the reader. This works because PolyHook\u2019s trampolines are not limited to +-2GB and do not spoil registers. The internals of how \u003Ci\u003Ethat\u003C\/i\u003E is achieved is a topic for another post. Figure 16 depicts how to overload the C++ API of polyhook to read\/write memory using the aforementioned WinAPIs.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure16.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 16: Overloading the memory operations to read\/write\/protect 64-bit memory\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce these inline hooks are in-place on the 64-bit syscall stubs, any application utilizing Heaven\u2019s Gate will be properly intercepted. This hooking technique is very invasive and complicated and can still be bypassed if a sample was to directly execute a syscall instruction rather than using the 64-bit module\u2019s syscalls stub. Therefore, a driver or hypervisor is more suitable to detect this evasion technique. Instead we can focus on the more common byte restoration evasion techniques and look for a way to hook the WOW64 layer itself. This doesn\u2019t involve assembly modifications at all.\u003C\/p\u003E\n\u003Ch4\u003EHooking WOW64 via LogService\u003C\/h4\u003E\n\u003Cp\u003EThinking back to the WOW64 layer\u2019s execution flow we know that all calls which are sent through the \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceEx\u003C\/span\u003E routine may invoke the routine \u003Cspan class=\u0022code\u0022\u003EWow64LogSystemService\u003C\/span\u003E if the logging DLL is loaded. We can utilize this logging DLL and routine to implement hooks which can be written the exact same way as inline hooks, without modifying any assembly.\u003C\/p\u003E\n\u003Cp\u003EThe first step to implementing this is to force all API call paths through the \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceEx\u003C\/span\u003E routine so that the log routine may be called. Remember earlier that those that support TurboThunks will not take this path. Lucky for us we know that any TurboThunk entry that points to \u003Cspan class=\u0022code\u0022\u003ETurboDispatchJumpAddressEnd\u003C\/span\u003E will take this path. Therefore, by pointing every entry in the TurboThunk table to point at that address, the desired behavior is achieved. Windows kindly implements this patching via \u003Cspan class=\u0022code\u0022\u003Ewow64cpu!BTCpuTurboThunkControl\u003C\/span\u003E as shown in Figure 17.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure17.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 17: Patching the TurboThunk table is implemented for us\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENote that in previous Windows versions the module which exported this and how it did is different to Windows 10, version 2004. After invoking this patch routine all syscall paths through WOW64 go through \u003Cspan class=\u0022code\u0022\u003EWow64SystemServiceEx\u003C\/span\u003E and we can focus on crafting a logging DLL that man-in-the-middles (MITMs) all calls. There are a couple of challenges to be considered here:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EHow do we determine which system call is currently occurring from the logging DLL?\u003C\/li\u003E\n\u003Cli\u003EHow are callbacks written? Wow64log is 64-bit DLL, we\u2019d like a 32-bit callback.\u003Cul\u003E\n\u003Cli\u003EIs shellcode required, or can we make nice C style function callbacks?\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003Cli\u003EWhat APIs may we call? All that\u2019s loaded is 64-bit ntdll.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EThe first concern is rather easy, from within the wow64log DLL we can read the syscall number from the syscall stubs to create a map of number to name. This is possible because syscall stubs always start with the same assembly and the syscall number is at a static offset of 0x4. Figure 18 shows how we can then compare the values in this map against the syscall number passed to \u003Cspan class=\u0022code\u0022\u003EWow64LogSystemService\u003C\/span\u003E\u2019s parameter structure \u003Cspan class=\u0022code\u0022\u003EWOW64_LOG_SERVICE\u003C\/span\u003E.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Etypedef uint32_t* WOW64_ARGUMENTS;\u003Cbr\u003E\n struct WOW64_LOG_SERVICE\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; uint64_t BtLdrEntry;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; WOW64_ARGUMENTS Arguments;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; ULONG ServiceTable;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; ULONG ServiceNumber;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; NTSTATUS Status;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; BOOLEAN PostCall;\u003Cbr\u003E\n };\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003EEXTERN_C\u003Cbr\u003E\n __declspec(dllexport)\u003Cbr\u003E\n NTSTATUS\u003Cbr\u003E\n NTAPI\u003Cbr\u003E\n Wow64LogSystemService(WOW64_LOG_SERVICE* service)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;for (uint32_t i = 0; i \u0026lt; LAST_SYSCALL_ID; i++) {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; const char* sysname = SysCallMap[i].name;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; uint32_t syscallNum = SysCallMap[i].SystemCallNumber;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; if (ServiceParameters-\u0026gt;ServiceNumber != syscallNum)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; continue;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/\/LOG sysname\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;}\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 18: Minimal example of determining which syscall is occurring\u2014in practice the service table must be checked too\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWriting callbacks is a bit more challenging. The wow64log DLL is executing in 64-bit mode and we\u2019d like to be able to write callbacks in 32-bit mode since it\u2019s very easy to load additional 32-bit modules into a WOW64 process. The best way to handle this is to write shellcode which is capable of transitioning back to 32-bit mode, execute the callback, then go back to 64-bit mode to continue execution in the wow64log DLL. The segment transitions themselves are rather easy at this point, we know we just need to use 0x23 or 0x33 segment selectors when jumping. But we also need to deal with the calling convention differences between 64-bit and 32-bit. Our shellcode will therefore be responsible for moving 64-bit arguments\u2019 register\/stack slots to the 32-bit arguments register\/stack slots. Enforcing that 32-bit callbacks may only be __cdecl makes this easier as all arguments are on the stack and the shellcode has full control of stack layout and cleanup. Figure 19 shows the locations of the arguments for each calling convention. Once the first 4 arguments are relocated all further arguments can be moved in a loop since it\u2019s simply moving stack values into lower slots. This is relatively easy to implement using external masm files in MSVC. Raw bytes will need to be emitted at points rather than using the assembler due to the mix of architectures. Alternatively, GCC or Clang inline assembly could be used. ReWolf\u2019s work achieves the opposite direction of 32-bit -\u0026gt; 64-bit and implements the shellcode via msvc inline asm. X64 MSVC doesn\u2019t support this and there are complications with REX prefixes when using that method. It\u2019s nicer to use external masm files and rely on the linker to implement this shellcode.\u003C\/p\u003E\n\u003Ctable border=\u00220\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 width=\u0022651\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022\u003E\u003Cp\u003E\u003Cb\u003EArg Number\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ECdecl Location\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EFastcall Location\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ESpecial Case?\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[ebp + 8]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Ercx\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EYes\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E1\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[ebp + 12]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Erdx\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EYes\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[ebp + 16]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Er8d\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EYes\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[ebp + 20]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Er9d\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EYes\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[ebp + 24]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[rbp + 32 + 8]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENo\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E5\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[ebp + 28]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[rbp + 32 + 16]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENo\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E6\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022163\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[ebp + 32]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E[rbp + 32 + 24]\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022129\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENo\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 19: Cdecl vs Fastcall argument positions\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce this shellcode is written and wrapped into a nice C++ function, it\u2019s possible for the wow64log DLL to invoke the callback via a simple C style function pointer call shown in Figure 20.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure20.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 20: call_function32 invokes shellcode to call a 32-bit callback from the 64-bit logging DLL\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFrom within the 32-bit callback any desired MITM operations can be performed, but restrictions exist on which APIs are callable. Due to the context saving that the WOW64 layer performs, 32-bit APIs that would re-enter the WOW64 layer may not be called as the context values would be corrupted. We are therefore limited to only APIs that won\u2019t re-enter WOW64, which are those that are exported from the 64-bit ntdll. The \u003Cspan class=\u0022code\u0022\u003ENtWriteFile\u003C\/span\u003E export may be used to easily write to stdout or a file, but we must re-enter the 64-bit execution mode and do the inverse argument mapping as before. This logging routine can be called from within the 32-bit callbacks and is shown in Figure 21 and Figure 22.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure21.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 21: call_function64 invokes shellcode to call the 64bit WriteFile from with the 32bit callback\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure22.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 22: 32bit callbacks must log via routines that only call non-reentrant WOW64 APIs\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe result is clean looking callback stubs that function exactly how inline hooks might, but with zero assembly modifications required. Arguments can easily be manipulated as well, but the return status may not be modified unless a little stack walk hackery is implemented. The only other consideration is that the wow64log DLL itself needs to be carefully crafted to not build with any CRT mechanisms. The flags required are:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EDisable CRT with \/NODEFAULT LIB (all C APIs now unavailable), set a new entry point name to not init CRT NtDllMain\u003C\/li\u003E\n\u003Cli\u003EDisable all CRT security routines \/GS-\u003C\/li\u003E\n\u003Cli\u003EDisable C++ exceptions\u003C\/li\u003E\n\u003Cli\u003ERemove default linker libraries, only link ntdll.lib\u003C\/li\u003E\n\u003Cli\u003EUse extern \u201cC\u201d __declspec(dllimport) \u0026lt;typedef\u0026gt; to link against the correct NtApis\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EAn example of a program hooking its own system calls via wow64log inline hooks is shown in Figure 23.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/wowhooks\/figure23.gif\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 23: Demonstration of inline hooks in action\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EUsing inline WOW64 hooks, wow64log hooks, and kernel\/hypervisor hooks, all techniques of usermode hook evasion can be identified easily and automatically. Detecting which layers of hooks are skipped or bypassed will give insight into which evasion technique is employed. The identifying table is:\u003C\/p\u003E\n\u003Ctable border=\u00220\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 width=\u0022624\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022194\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EEvasion Mode\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002287\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E32bit Inline\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002297\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003Ewow64Log\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002291\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E64bit Inline\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022156\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EKernel\/Hypervisor\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022194\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EPrologue Restore\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002287\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u274c\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002297\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E\u2714\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002291\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E\u2714\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022156\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E\u2714\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022194\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EHeavens Gate sys-stub\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002287\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u274c\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002297\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u274c\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002291\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E\u2714\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022156\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E\u2714\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022194\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EHeavens Gate direct syscall\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002287\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u274c\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002297\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u274c\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002291\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u274c\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022156\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003E\u2714\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Ch4\u003EStructure Appendix\u003C\/h4\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Estruct _WOW64_CPURESERVED\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; USHORT Flags;\u003Cbr\u003E\n \u0026nbsp; USHORT MachineType;\u003Cbr\u003E\n \u0026nbsp; WOW64_CONTEXT Context;\u003Cbr\u003E\n \u0026nbsp; char ContextEx[1024];\u003Cbr\u003E\n };\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Etypedef ULONG *WOW64_LOG_ARGUMENTS;\u003Cbr\u003E\n struct _WOW64_SYSTEM_SERVICE\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; unsigned __int32 SystemCallNumber : 12;\u003Cbr\u003E\n \u0026nbsp; unsigned __int32 ServiceTableIndex : 4;\u003Cbr\u003E\n \u0026nbsp; unsigned __int32 TurboThunkNumber : 5;\u003Cbr\u003E\n \u0026nbsp; unsigned __int32 AlwaysZero : 11;\u003Cbr\u003E\n };\u003Cbr\u003E\n #pragma pack(push, 1)\u003Cbr\u003E\n struct _WOW64_FLOATING_SAVE_AREA\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; DWORD ControlWord;\u003Cbr\u003E\n \u0026nbsp; DWORD StatusWord;\u003Cbr\u003E\n \u0026nbsp; DWORD TagWord;\u003Cbr\u003E\n \u0026nbsp; DWORD ErrorOffset;\u003Cbr\u003E\n \u0026nbsp; DWORD ErrorSelector;\u003Cbr\u003E\n \u0026nbsp; DWORD DataOffset;\u003Cbr\u003E\n \u0026nbsp; DWORD DataSelector;\u003Cbr\u003E\n \u0026nbsp; BYTE RegisterArea[80];\u003Cbr\u003E\n \u0026nbsp; DWORD Cr0NpxState;\u003Cbr\u003E\n };\u003Cbr\u003E\n #pragma pack(pop)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E#pragma pack(push, 1)\u003Cbr\u003E\n struct _WOW64_CONTEXT\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; DWORD ContextFlags;\u003Cbr\u003E\n \u0026nbsp; DWORD Dr0;\u003Cbr\u003E\n \u0026nbsp; DWORD Dr1;\u003Cbr\u003E\n \u0026nbsp; DWORD Dr2;\u003Cbr\u003E\n \u0026nbsp; DWORD Dr3;\u003Cbr\u003E\n \u0026nbsp; DWORD Dr6;\u003Cbr\u003E\n \u0026nbsp; DWORD Dr7;\u003Cbr\u003E\n \u0026nbsp; WOW64_FLOATING_SAVE_AREA FloatSave;\u003Cbr\u003E\n \u0026nbsp; DWORD SegGs;\u003Cbr\u003E\n \u0026nbsp; DWORD SegFs;\u003Cbr\u003E\n \u0026nbsp; DWORD SegEs;\u003Cbr\u003E\n \u0026nbsp; DWORD SegDs;\u003Cbr\u003E\n \u0026nbsp; DWORD Edi;\u003Cbr\u003E\n \u0026nbsp; DWORD Esi;\u003Cbr\u003E\n \u0026nbsp; DWORD Ebx;\u003Cbr\u003E\n \u0026nbsp; DWORD Edx;\u003Cbr\u003E\n \u0026nbsp; DWORD Ecx;\u003Cbr\u003E\n \u0026nbsp; DWORD Eax;\u003Cbr\u003E\n \u0026nbsp; DWORD Ebp;\u003Cbr\u003E\n \u0026nbsp; DWORD Eip;\u003Cbr\u003E\n \u0026nbsp; DWORD SegCs;\u003Cbr\u003E\n \u0026nbsp; DWORD EFlags;\u003Cbr\u003E\n \u0026nbsp; DWORD Esp;\u003Cbr\u003E\n \u0026nbsp; DWORD SegSs;\u003Cbr\u003E\n \u0026nbsp; BYTE ExtendedRegistersUnk[160];\u003Cbr\u003E\n \u0026nbsp; M128A Xmm0;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm1;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm2;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm3;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm4;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm5;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm6;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm7;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm8;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm9;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm10;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm11;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm12;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm13;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm14;\u003Cbr\u003E\n \u0026nbsp; M128A Xmm15;\u003Cbr\u003E\n };\u003Cbr\u003E\n #pragma pack(pop)\u003C\/span\u003E\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue Nov 10 2020 18:39:58 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EWe dive deep into the WOW64 system and\u0026nbsp;assess two hooking techniques and their effectiveness.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Nov 09 2020 18:19:41 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Mon Nov 16 2020 17:59:03 GMT+0000",
      "imageRotate": "0"
    }
  }
}
