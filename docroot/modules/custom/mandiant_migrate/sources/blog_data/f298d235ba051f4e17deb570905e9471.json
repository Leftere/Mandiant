{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed May 04 2016 09:03:34 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Tearing up the Windows Registry with python-registry",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "bd5a64e9-b2cf-4a85-9514-0a04b261853c",
    "author": "William Ballenthin",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "lynda.hall@fireeye.com",
    "focusKeyword": "forensics",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "441cbe61-07a9-438e-9368-2bc51ae91854"
    ],
    "jcr:created": "Tue Nov 01 2016 14:43:30 GMT-0400",
    "cq:lastReplicated": "Tue Nov 01 2016 14:43:30 GMT-0400",
    "cq:lastModified": "Tue Nov 01 2016 14:42:52 GMT-0400",
    "cq:distribute": true,
    "jcr:baseVersion": "441cbe61-07a9-438e-9368-2bc51ae91854",
    "jcr:isCheckedOut": true,
    "cq:createdBy": "admin",
    "cq:tags": [
      "fireeye-blog-authors:cap-william-ballenthin",
      "fireeye-blog-tags:incident-response",
      "fireeye-blog-tags:registry",
      "fireeye-blog-tags:python",
      "fireeye-blog-tags:forensics"
    ],
    "jcr:uuid": "72506bd4-1d9d-496b-b471-99589b361b28",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Wed Jul 20 2011 23:05:35 GMT-0500",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "lynda.hall@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
        "text": "\u003Cdiv class=\u0022c00 c00v1\u0022\u003E\u003Cp\u003ERecently, I wanted to dig deep into a forensic artifact resident in the Windows Registry. To make the task more interesting, I challenged myself to use only tools native to my favorite operating system: Linux. I was quickly disappointed, however, as there are few open and cross-platform tools for Windows Registry forensics beyond Perl\u0027s Win32::Registry. So, I wrote a tool to fill this void using Python - my favorite programming language. Python-registry is the result of this effort, and provides convenient access to Windows Registry files. Since it is pure Python, it can be used on all major operating systems.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003EBackground\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EThe Windows Registry file format consists of a set of allocation units, known as HBIN blocks. Each block is subdivided into cells, which form the basic unit of content in the format. Although cells may contain pure binary data, many cells are used solely for metadata storage. These include: nk-records (nodes in the tree-like structure of the Windows Registry), lf-records (point to children of a node), and vk-records (describe a single Registry value). Python-registry exposes a set of classes in the RegistryParse module that parse and read these low-level structures. One RegistryParse class maps to each structure, and each exposes a set of convenient methods for accessing metadata and other referenced structures.\u003C\/p\u003E\n\u003Cp\u003EFor example, once a Windows Registry file has been loaded by python-registry, you can select an HBIN block, and iterate through each cell. The following code listing shows how you can identify free cells, which may be extracted so you can search for deleted Registry keys.\u003C\/p\u003E\n\u003Cpre\u003E\nf = open(\u0026quot;NTUSER.DAT\u0026quot;)\nbuf = f.read()\nregf = RegistryParse.REGFBlock(buf, 0, false) \nfor HBIN in regf.hbins():\n    for cell in HBIN.cells():\n    if cell.is_free():\n    print \u0026quot;Unallocated cell at offset 0x%x\u0026quot; % (cell.offset())\n\u003C\/pre\u003E\n\u003Cp\u003EThere are few libraries in the wild that parse Windows Registry files and many fewer still that encourage interaction with the underlying structure. Enterprising forensicators should recognize the opportunity for using python-registry to enable future research in Registry key recovery.\u003C\/p\u003E\n\u003Cp\u003EIn addition to low-level parsing classes, python-registry provides a high-level interface similar to those exposed by the Microsoft Windows API. The Registry module abstraction layer removes from the user details about allocation units and records and provides familiar sounding RegistryKey and RegistryValue classes. Once a Windows Registry file has been loaded, instances of the RegistryKey class are organized into a tree structure, and may be associated with a list of RegistryValues. This tree mirrors the structure you would see if you were to explore the corresponding Windows Registry with RegEdit.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003EForensics with python-registry\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003ESimilar to Harlan Carvey\u0027s \u003Ca href=\u0022http:\/\/regripper.wordpress.com\/\u0022 target=\u0022_blank\u0022\u003ERegRipper\u003C\/a\u003E, python-registry is particularly suited for forensic analysis. Python-registry works directly with Registry hive files -- not the live hives -- so it can easily be used on a forensic workstation after an acquisition.\u003C\/p\u003E\n\u003Cp\u003ERecently, I used python-registry to help identify compromised servers during an incident response from Mandiant\u0027s New York City office. I suspected a system was infected with malware based on remote login events found on another system and wanted to do a deeper dive. I used \u003Ca href=\u0022\/content\/fireeye-www\/en_US\/services.html\u0022 target=\u0022_blank\u0022 adhocenable=\u0022false\u0022\u003EMandiant Intelligent Response\u003C\/a\u003E\u00ae (MIR) to acquire the Registry hive files, including C:WINDOWSsystem32configsoftware, from the remote system and downloaded them to my Linux laptop.\u003C\/p\u003E\n\u003Cp\u003ENext, I wrote the following ten-line Python script using python-registry to print out each key and its last modified date, while filtering on a suspicious time window.\u003C\/p\u003E\n\u003Cpre\u003E\nfrom Registry import Registry\ndef rec(key):\n    if MIN_DATE \u0026lt; key.timestamp() \u0026lt; MAX_DATE:\n    print \u0026quot;%s\n%s\u0026quot; % (key.timestamp(), key.path())\n    for subkey in key.subkeys():\n    rec(subkey)\nf = open(\u0026quot;software\u0026quot;, \u0026quot;rb\u0026quot;)\nr = Registry.Registry(f)\nrec(r.root())\n\u003C\/pre\u003E\n\u003Cp\u003EImmediately an entry with the path \u0026quot;$$$PROTO.HIVMicrosoftWindowsCurrentVersionRun\u0026quot; caught my eye. What was changed during the time window?\u003C\/p\u003E\n\u003Cp\u003EThe python-registry package contains a set of tools that have been built using python-registry to demonstrate its usage and are contained in the samples directory. The regview.py GUI tool (similar to RegEdit.exe) can be used to explore the \u0026quot;Run\u0026quot; key as seen in the following figure.\u003C\/p\u003E\n\u003Cp\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/RegistryFileViewer.png\u0022\u003E\u003Cimg class=\u0022aligncenter size-large wp-image-1826\u0022 src=\u0022https:\/\/www.fireeye.com\/content\/dam\/legacy\/ammo\/RegistryFileViewer-300x211.png\u0022 alt=\u0022Registry File Viewer\u0022 width=\u0022300\u0022 height=\u0022211\u0022\u003E\u003C\/a\u003E\u003C\/p\u003E\n\u003Cp\u003EA malicious entry showed that an attacker had gained persistence by adding his malware to execute on startup. The system was definitely compromised. I continued the Registry analysis with a few more experimental scripts I had been developing, including a shellbag parser, and the client was happy.\u003C\/p\u003E\n\u003Cp\u003EPython-registry is effective because it is flexible and intuitive. The package is a library that is easily integrated into both one-off scripts and larger projects. For example, I\u0027ve found that using python-registry with an interactive Python console (like IPython) is an effective environment for rapid triage and analysis. Python-registry converts Registry values into native data types, which makes manipulation of data familiar to a Python programmer. This means it is easy to pass the output of a python-registry method call to a decoding function developed elsewhere.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003EUsing the library\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003ELet\u0027s explore how you can easily make use of this library. You can recurse across all RegistryKeys and perform an action as seen in the following code snippet. This utility encapsulates this logic by applying a function to each RegistryKey.\u003C\/p\u003E\n\u003Cpre\u003E\ndef rec(key, f):\n    \u0026quot;\u0026quot;\u0026quot;\n    Recurses across all RegistryKeys and applies the function f.\n    key : A Registry.RegistryKey\n    f : A function taking one argument, a Registry.RegistryKey\n    returns : None\n    \u0026quot;\u0026quot;\u0026quot;\n    f(key)\n    for subkey in key.subkeys():\n    rec(subkey, f)\n\u003C\/pre\u003E\n\u003Cp\u003EMetadata about a particular RegistryKey can be accessed through the methods .name(), .path(), and .timestamp(). RegistryKey.subkeys() returns a list of child RegistryKey objects that are lazily parsed. By lazily parsing the file, python-registry reduces memory consumption and minimizes initial load time. The following code listing shows how to print out all Registry key paths.\u003C\/p\u003E\n\u003Cpre\u003E\nfrom Registry import Registry\ndef print_key(key):\n    \u0026quot;\u0026quot;\u0026quot;\n    Print the path of a RegistryKey.\n    key : A Registry.RegistryKey\n    returns : None\n    \u0026quot;\u0026quot;\u0026quot;\n    print key.path()\nf = open(\u0026quot;NTUSER.DAT\u0026quot;, \u0026quot;rb\u0026quot;)\nreg = Registry.Registry(f)\nrec(reg.root(), print_key)\n\u003C\/pre\u003E\n\u003Cp\u003EIn python-registry, a Registry file is initially loaded by constructing a Registry object. The .root() method returns the root RegistryKey, and serves as the starting point for most functions. Alternatively, a script may use the .open() method to attempt to open a RegistryKey by path.\u003C\/p\u003E\n\u003Cp\u003EI could have used a modified version of the print_key() function in the earlier example to identify the malicious \u0026quot;Run\u0026quot; key; however, a slightly more interesting application might be to print out all Registry values of string type that contain given string. In the following code listing, we iterate over the RegistryValues associated with each RegistryKey while filtering out non-string values. We apply the find_microsoft() function to each RegistryKey using our recursive utility rec(), and it prints out the RegistryValue hits.\u003C\/p\u003E\n\u003Cpre\u003E\ndef find_microsoft(key):\n    \u0026quot;\u0026quot;\u0026quot;\n    Prints Registry keys whose values contain the string \u0026quot;microsoft\u0026quot;.\n    key : A Registry.RegistryKey\n    returns : None\n    \u0026quot;\u0026quot;\u0026quot;\n    for value in [v.value() for v in key.values()\nif v.value_type() == Registry.RegSZ\nor v.value_type() == Registry.RegExpandSZ]:\n    if \u0026quot;microsoft\u0026quot; in value:\n    print key.path()\nrec(reg.root(), find_microsoft)\n\u003C\/pre\u003E\n\u003Cp\u003EThe .values() method of a RegistryKey returns a list of RegistryValues associated with the key. RegistryValues are a conceptually a tuple of (name, type, data), which map to the methods .name(), .value_type(), and .data(). The type of a RegistryValue is represented by an integer ranging from 0x0 to 0xB and may mean something like \u0026quot;string\u0026quot;, \u0026quot;binary\u0026quot;, or \u0026quot;dword\u0026quot;. Fortunately, python-registry provides a set of constants, like Registry.RegSZ, Registry.RegBin, and Registry.RegDWord, to improve readability. When the data is requested from the RegistryValue using the .data() method, it is first converted into the native Python datatype. For example, strings are converted from ASCII or Unicode into native strings, and numeric types into integers.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003EDocumentation\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EMost classes and methods have been documented; however, for the few that have not, the source code is written to be self-documenting. Python-registry is released under the Apache 2 license, so all users should feel encouraged to browse basic structure of the source. I hope that clear and accessible source code that implements the Windows Registry file format can serve to be a central repository for knowledge regarding the format.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003EConclusion\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EPython-registry is a package written for those who enjoy Python and Windows Registry forensics, and potentially platforms other than Microsoft Windows. It implements each of the lower level structures, yet also presents a high-level interface that encourages both one-off scripts and substantial processing. Since python-registry is released under the Apache 2 license, all are encouraged to examine and patch the source code. The homepage for python-registry is found here, and the latest source can be downloaded from GitHub here.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003EAcknowledgements\u003C\/b\u003E\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u0026quot;WinReg.txt\u0026quot; by B.D. found at http:\/\/pogostick.net\/~pnh\/ntpasswd\/WinReg.txt\u003C\/li\u003E\n\u003Cli\u003E\u0026quot;The Windows NT Registry File Format\u0026quot; by Timothy Morgan found at http:\/\/www.sentinelchicken.com\/research\/registry_format\u003C\/li\u003E\n\u003Cli\u003E\u0026quot;The Internal Structure of the Windows Registry\u0026quot; by Peter Morris found at http:\/\/amnesia.gtisc.gatech.edu\/~moyix\/suzibandit.ltd.uk\/MSc\/\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/div\u003E\n",
        "jcr:lastModified": "Tue Nov 01 2016 14:42:52 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
      "text": "\u003Cp\u003ERecently, I wanted to dig deep into a forensic artifact resident in the Windows Registry. To make the task more interesting, I challenged myself to use only tools native to my favorite operating system: Linux. I was quickly disappointed, however, as there are few open and cross-platform tools for Windows Registry forensics beyond Perl\u0027s Win32::Registry. So, I wrote a tool to fill this void using Python - my favorite programming language. Python-registry is the result of this effort, and provides convenient access to Windows Registry files. Since it is pure Python, it can be used on all major operating systems.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon May 09 2016 18:23:58 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
