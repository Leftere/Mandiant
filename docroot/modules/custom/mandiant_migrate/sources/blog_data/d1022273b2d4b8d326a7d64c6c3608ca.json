{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Thu Feb 28 2019 11:37:58 GMT-0500",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "FLARE Script Series: Recovering Stackstrings Using Emulation with ironstrings",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "3331034f-7757-482e-bbb2-ae4e740b5d5e",
    "author": "Moritz Raabe",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "bf63014f-a5fb-4500-9bf0-f8d11be6dc85"
    ],
    "jcr:created": "Thu Feb 28 2019 11:37:58 GMT-0500",
    "cq:lastReplicated": "Thu Feb 28 2019 11:37:55 GMT-0500",
    "cq:lastModified": "Mon Mar 04 2019 12:32:05 GMT-0500",
    "jcr:baseVersion": "bf63014f-a5fb-4500-9bf0-f8d11be6dc85",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:moritz-raabe",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:tools"
    ],
    "jcr:uuid": "87badcda-6163-4ce1-94da-f644cc9eb35b",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Feb 28 2019 11:30:00 GMT-0500",
    "cq:lastModifiedBy": "jeff.payne@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EThis blog post continues our Script Series where the FireEye Labs Advanced Reverse Engineering (FLARE) team shares tools to aid the malware analysis community. Today, we release\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-ida\/blob\/master\/python\/flare\/ironstrings\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u003C\/a\u003E: a new IDAPython script to recover stackstrings from malware. The script leverages code emulation to overcome this common string obfuscation technique. More precisely, it makes use of our\u0026nbsp;\u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2018\/12\/automating-objective-c-code-analysis-with-emulation.html\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u003C\/a\u003E\u0026nbsp;tool, which combines IDA Pro and the Unicorn emulation engine. In this blog post, I explain how our new script uses\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;to recover stackstrings from malware. In addition, I discuss\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u2019s event hooks and how you can use them to easily adapt the tool to your own analysis needs.\u003C\/p\u003E\n\u003Ch4\u003EIntroduction\u003C\/h4\u003E\n\u003Cp\u003EAnalyzing strings in binary files is an important part of malware analysis. Although simple, this reverse engineering technique can provide valuable information about a program\u2019s use and its capabilities. This includes indicators of compromise like file paths and domain names. Especially during advanced analysis, strings are essential to understand a disassembled program\u2019s functionality. Malware authors know this, and string obfuscation is one of the most common anti-analysis techniques reverse engineers encounter.\u003C\/p\u003E\n\u003Cp\u003EDue to the prevalence of obfuscated strings, the FLARE team has already developed and shared various tools and techniques to deal with them. In 2014 we published an IDA Pro plugin to\u0026nbsp;\u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2014\/08\/flare-ida-pro-script-series-automatic-recovery-of-constructed-strings-in-malware.html\u0022\u003Eautomate the recovery of constructed strings in malware\u003C\/a\u003E. In 2016, we released\u0026nbsp;\u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2016\/06\/automatically-extracting-obfuscated-strings.html\u0022\u003EFLOSS\u003C\/a\u003E; a standalone\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-floss\/\u0022\u003Eopen-source tool\u003C\/a\u003E\u0026nbsp;to automatically identify and decode strings in malware.\u003C\/p\u003E\n\u003Cp\u003EBoth solutions rely on\u0026nbsp;\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/vivisect\/vivisect\u0022\u003Evivisect\u003C\/a\u003E, a Python-based program analysis and emulation framework. Although vivisect is a robust tool, it may fail to completely analyze an executable file or emulate its code correctly. And just like any tool, vivisect is susceptible to anti-analysis techniques. With missing, incomplete, or erroneous processing by vivisect, dependent tools cannot provide the best results. Moreover, vivisect does not provide an easy-to-use graphical interface to interactively change and enhance program analysis.\u003C\/p\u003E\n\u003Cp\u003EI encountered all these shortcomings recently, when I analyzed a GandCrab ransomware sample (version 5.0.4, SHA256 hash: 72CB1061A10353051DA6241343A7479F73CB81044019EC9A9DB72C41D3B3A2C7). The malware contains various anti-analysis techniques to hinder disassembly and control-flow analysis. Before I could perform any efficient reverse engineering in IDA Pro, I had to overcome these hurdles. I used IDAPython to remove various anti-analysis instruction patterns which then allowed the disassembler to successfully identify all functions in the binary. Many of the recovered functions contained obfuscated strings. Unfortunately, my changes did not propagate to vivisect, because it performs its own independent analysis on the original binary. Consequently, vivisect still failed to recognize most functions correctly and I couldn\u2019t use one of our existing solutions to recover the obfuscated strings.\u003C\/p\u003E\n\u003Cp\u003EWhile I could have tried to feed my patches in IDA Pro back to vivisect or to create a modified binary, I instead created a new IDAPython script that does not depend on vivisect. Thus, circumventing the mentioned shortcomings. It uses IDA Pro\u2019s program analysis and Unicorn\u2019s emulation engine. The easy integration of these two tools is powered by\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-emu\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EUsing IDA Pro instead of vivisect resolves multiple limitations of our previous implementations. Now changes that users make in their IDB file, e.g. by patching instructions to manually enhance analysis, are immediately available during emulation. Moreover, the tool more robustly supports different architectures including x86, AMD64, and ARM.\u003C\/p\u003E\n\u003Ch4\u003EStackstrings: An Example\u003C\/h4\u003E\n\u003Cp\u003EThe disassembly listing in Figure 1 shows an example string obfuscation from the sample I analyzed. The malware creates a string at run-time by moving each character into adjacent stack addresses (gray highlights). Finally, the sample passes the string\u2019s starting offset as an argument to the InternetOpen API call (blue highlight). Manually following these memory moves and restoring strings by hand is a very cumbersome process. Especially if malware complicates value assignments using additional instructions like illustrated below.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ironstrings\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Disassembly listing showing stackstring creation and usage\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBecause malware often uses stack memory to create such strings, Jay Smith\u0026nbsp;\u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2014\/08\/flare-ida-pro-script-series-automatic-recovery-of-constructed-strings-in-malware.html\u0022\u003Ecoined the term stackstrings\u003C\/a\u003E\u0026nbsp;for this anti-analysis technique. Note that malware can also construct strings in global memory. Our new script handles both cases; strings constructed on the stack and in global memory.\u003C\/p\u003E\n\u003Ch4\u003Eironstrings: Stackstring Recovery Using flare-emu\u003C\/h4\u003E\n\u003Cp\u003EThe new IDAPython script is an evolution of our existing solutions. It combines FLOSS\u2019s stackstring recovery algorithm and functionality from our IDA Pro plugin. The script relies on IDA Pro\u2019s program analysis and emulates code using Unicorn. The combination of both tools is powered by\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E.\u0026nbsp;\u003Ci\u003EFe\u003C\/i\u003E, short for\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E, is the chemical symbol for iron and hence the script is named\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003ETo recover stackstrings,\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;enumerates all disassembled functions in a program except for library and thunk functions as identified by IDA Pro. For each function, the script emulates various code paths through the function and searches for stackstrings based on two heuristics:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EBefore all call instructions in the function. As stackstrings are often constructed and then passed to other functions, i.e. Windows APIs like \u003Cspan class=\u0022code\u0022\u003ECreateFile\u003C\/span\u003E or \u003Cspan class=\u0022code\u0022\u003EInternetOpenUrl\u003C\/span\u003E.\u003C\/li\u003E\n\u003Cli\u003EAt the end of a basic block containing more than five memory writes. The number of memory writes is configurable. This heuristic is helpful if the same memory buffer is used multiple times in a function and if the string construction spans multiple basic blocks.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EIf any of these conditions apply, the script searches the function\u2019s current stack frame for printable ASCII and UTF-16 strings. To detect strings in global memory, the script additionally searches for strings in all memory locations that have been written to.\u003C\/p\u003E\n\u003Ch4\u003EUsing flare-emu Hooks to Recover Stackstrings\u003C\/h4\u003E\n\u003Cp\u003EIf you\u2019re not already familiar with\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E, I recommend reading our\u0026nbsp;\u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2018\/12\/automating-objective-c-code-analysis-with-emulation.html\u0022\u003Eprevious blog post\u003C\/a\u003E. It discusses some of the interfaces the tool provides. Other helpful resources are the examples and the project documentation available on the\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-emu\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E GitHub\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EThe stackstrings script uses\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u2019s\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003EiterateAllPaths\u003C\/span\u003E\u0026nbsp;API. The function iterates multiple code paths through a function. It first finds possible paths from function start to function end. The tool then forces the emulation down all identified code paths independent from the actual program state. This extensive code coverage allows\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;to recover strings constructed from many different emulation runs.\u003C\/p\u003E\n\u003Cp\u003EA key feature of\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;are the various hook functions that get triggered by different emulation events. These hooks, or callbacks, enable the development of very powerful automation tasks. The available hooks are a combination of Unicorn\u2019s standard hooks, e.g., to hook memory access events, and multiple convenience hooks provided by\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E. The following section briefly describes the available callbacks in\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;and illustrates how the\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;script uses them to recover obfuscated strings.\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EinstructionHook: This Unicorn standard hook is triggered before an instruction is emulated. \u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E uses this hook to initiate the stackstrings extraction if a basic block contained enough memory writes, for example.\u003Csub\u003E\u003C\/sub\u003E\u003C\/li\u003E\n\u003Cli\u003EmemAccessHook: This Unicorn standard hook is triggered when memory read or write events occur during emulation. In the stackstrings script this function stores data about all memory writes.\u003C\/li\u003E\n\u003Cli\u003EcallHook: This\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;hook is activated before each function call. The hook\u2019s return value is ignored. In the stackstrings script this hook triggers the extraction of stackstrings.\u003C\/li\u003E\n\u003Cli\u003EpreEmuCallback: This\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;hook is called before each emulation run. It is only available in the iterate and the iterateAllPaths functions. The hook\u2019s return value is ignored.\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;does not use this hook.\u003C\/li\u003E\n\u003Cli\u003EtargetCallback: This\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;hook gets called whenever one of the specified target addresses is hit. It is only available in the iterate and the iterateAllPaths functions. The hook\u2019s return value is ignored. The stackstrings script does not use this hook.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EThe code in Figure 2 shows the callback functions that\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u2019s API currently supports, their signatures, and examples of how to use them. All callbacks receive an argument named hookData. This named dictionary allows the user to provide application specific data to use before, during, and after emulation. Often, this dictionary is named userData in the user-defined callbacks, as in the examples below, due to its naming in Unicorn.\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;uses this to access function analysis data and store recovered strings across its various hooks. The dictionary also provides access to the\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003EEmuHelper\u003C\/span\u003E\u0026nbsp;object and emulation meta data.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ironstrings\/Fig2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: flare-emu example hook implementations\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EInstallation\u003C\/h4\u003E\n\u003Cp\u003EDownload and install\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-emu\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u003C\/a\u003E\u0026nbsp;as described at the\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-emu#installation\u0022\u003EGitHub installation page\u003C\/a\u003E.\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;is available, along with our other IDA Pro plugins and scripts, at our\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-ida\/blob\/master\/python\/flare\/ironstrings\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;GitHub page\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003ENote that both\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;and\u0026nbsp;ironstrings\u0026nbsp;were written using the new IDAPython API available in IDA Pro 7.0 and higher. They are not backwards compatible with previous program versions.\u003C\/p\u003E\n\u003Ch4\u003EUsage and Options\u003C\/h4\u003E\n\u003Cp\u003ETo run the script in IDA Pro, go to File \u2013 Script File... (ALT+F7) and select\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings.py\u003C\/span\u003E. The script runs automatically on all functions, prints its results to IDA Pro\u0027s output window, and adds comments at the locations where it recovered stackstrings. Figure 3 shows the script\u2019s output of the recovered stackstring locations from the GandCrab sample. Analysis of this malware takes the script about 15 seconds.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ironstrings\/Fig3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Deobfuscated stackstrings and locations where they were identified\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 4 shows the disassembly listing of the stackstring creation example discussed at the beginning of this post after running\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ironstrings\/Fig4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Commented stackstring after running ironstrings\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAfter analyzing a sample, the script provides a summary and a unique listing of all recovered strings. The output for the ransomware sample is shown in Figure 5. Here the tool failed to analyze two functions due to invalid memory operations during Unicorn\u2019s code emulation.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ironstrings\/Fig5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Script summary and unique string listing\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENote that you can modify various options to change the script\u2019s behavior. For example, you can configure the output format at the top of the\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings.py\u003C\/span\u003E\u0026nbsp;file. The script\u2019s\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-ida\/blob\/master\/python\/flare\/ironstrings\/README.md\u0022\u003EREADME\u003C\/a\u003E\u0026nbsp;file explains the options in more detail.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EThis blog post explains how our new IDAPython script\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eironstrings\u003C\/span\u003E\u0026nbsp;works and how you can use it to automatically recover stackstrings in IDA Pro. Overcoming anti-analysis techniques is just one of many useful applications of code emulation for malware analysis. This post shows that\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u0026nbsp;provides the ideal base for this by integrating IDA Pro and Unicorn. The detailed discussion of\u0026nbsp;\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u2019s hook functions will help you to write your own powerful automation scripts. Please reach out to us with questions, suggestions and feedback via the\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-emu\/issues\u0022 adhocenable=\u0022false\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u003C\/a\u003E\u0026nbsp;and\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-ida\/issues\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-ida\u003C\/span\u003E\u003C\/a\u003E\u0026nbsp;GitHub issue trackers.\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Feb 28 2019 11:34:41 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EWe release ironstrings,\u0026nbsp;a new IDAPython script to recover stackstrings from malware.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Feb 27 2019 22:24:31 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Feb 28 2019 11:37:34 GMT-0500",
      "imageRotate": "0"
    },
    "sidebar": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "jeff.payne@fireeye.com",
      "jcr:lastModified": "Mon Mar 04 2019 12:32:05 GMT-0500",
      "sling:resourceType": "fireeye-www\/fdc\/components\/reuse\/reuse-blog-resources",
      "grid-33-right": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-parsys\/parsys-33-small\/parsys"
      }
    }
  }
}
