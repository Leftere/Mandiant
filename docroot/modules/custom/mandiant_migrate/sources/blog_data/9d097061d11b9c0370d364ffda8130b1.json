{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Fri May 20 2016 15:40:29 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "How RTF malware evades static signature-based detection",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "25584065-7f07-4500-b31b-6d3b57d7f120",
    "author": "Junfeng Yang",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "lynda.hall@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "df3f43e3-6e58-4c7f-8b86-2fa1c4eabfa7"
    ],
    "jcr:created": "Fri Jun 03 2016 22:49:52 GMT-0400",
    "cq:lastReplicated": "Fri Jun 03 2016 22:49:52 GMT-0400",
    "cq:lastModified": "Tue May 24 2016 17:25:19 GMT-0400",
    "cq:distribute": true,
    "jcr:description": "Our adversaries are familiar with the RTF format and the inner workings of Microsoft Word, and can devise obfuscation tricks to evade traditional signature-based detection. Understanding hackers perform obfuscation can in turn help us improve our detection of this type of malware.",
    "jcr:baseVersion": "df3f43e3-6e58-4c7f-8b86-2fa1c4eabfa7",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-tags:cyber",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:cyber-threat",
      "fireeye-doctypes:blog",
      "fireeye-blog-threat-research:threat-research\/malware-research",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:cybersecurity",
      "fireeye-blog-tags:malware-detection",
      "fireeye-blog-tags:malware",
      "fireeye-blog-authors:junfeng-yang"
    ],
    "jcr:uuid": "a588d40c-3088-45ea-925f-a688fdaddd13",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Fri May 20 2016 14:59:00 GMT-0400",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "lynda.hall@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
        "text": "\u003Ch4\u003E\u003Cb\u003EHistory\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003ERich Text Format (RTF) is a document format developed by Microsoft that has been widely used on various platforms for more than 29 years. The RTF format is very flexible and therefore complicated. This makes the development of a safe RTF parsers challenging. Some notorious vulnerabilities such as \u003Ca href=\u0022http:\/\/www.microsoft.com\/technet\/security\/Bulletin\/MS10-087.mspx\u0022\u003ECVE-2010-3333\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/blogs.mcafee.com\/mcafee-labs\/close-look-rtf-zero-day-attack-cve-2014-1761-shows-sophistication-attackers\/\u0022\u003ECVE-2014-1761\u003C\/a\u003E were caused by errors in implementing RTF parsing logic.\u003C\/p\u003E\n\u003Cp\u003EIn fact, RTF malware is not limited to exploiting RTF parsing vulnerabilities. Malicious RTF files can include other vulnerabilities unrelated to the RTF parser because RTF supports the embedding of objects, such as OLE objects and images. \u003Ca href=\u0022https:\/\/technet.microsoft.com\/en-us\/library\/security\/ms12-027.aspx\u0022\u003ECVE-2012-0158\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/blog.fortinet.com\/post\/the-curious-case-of-the-document-exploiting-an-unknown-vulnerability-part-1\u0022\u003ECVE-2015-1641\u003C\/a\u003E are two typical examples of such vulnerabilities \u2013 their root cause does not reside in the RTF parser and attackers can exploit these vulnerabilities through other file formats such as DOC and DOCX.\u003C\/p\u003E\n\u003Cp\u003EAnother type of RTF malware does not use any vulnerabilities. It simply contains embedded malicious executable files and tricks the user into launching those malicious files. This allows attackers to distribute malware via email, which is generally not a vector for sending executable files directly.\u003C\/p\u003E\n\u003Cp\u003EPlenty of malware authors prefer to use RTF as an attack vector because RTF is an obfuscation-friendly format. As such, their malware can easily evade static signature based detection such as YARA or Snort. This is a big reason why, in this scriptable exploit era, we still see such large volumes of RTF-based attacks.\u003C\/p\u003E\n\u003Cp\u003EIn this blog, we present some common evasive tricks used by malicious RTFs. \u003C\/p\u003E\n\u003Ch4\u003E\u003Cb\u003ECommon obfuscations\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003ELet\u2019s discuss a couple different RTF obfuscation strategies.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CVE-2010-3333\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EThis vulnerability, reported by Team509 in 2009, is a typical stack overflow bug. Exploitation of this vulnerability is so easy and reliable that it is still used in the wild, seven years after its discovery! Recently, attackers exploiting this vulnerability \u003Ca href=\u0022http:\/\/researchcenter.paloaltonetworks.com\/2016\/02\/new-malware-rover-targets-indian-ambassador-to-afghanistan\/\u0022\u003Etargeted an Ambassador of India\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EThe root cause of this vulnerability was that the Microsoft RTF parser has a stack-based buffer overflow in the procedure parsing the pFragments shape property. Crafting a malicious RTF to exploit this vulnerability allows attackers to execute arbitrary code. Microsoft has since addressed the vulnerability, but many old versions of Microsoft Office were affected, so its threat rate was very high.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab1.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab2.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003EThe Microsoft Office RTF parser lacks proper bounds checking when copying source data to a limited stack-based buffer. The pattern of this exploit can be simplified as follows:\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022415\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\rtf1{\\shp{\\sp{\\sn pFragments}{\\sv A;B;[word1][word2][word3][hex value array]}}}}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EBecause pFragments is rarely seen in normal RTF files, many firms would simply detect this keyword and the oversized number right after \\sv in order to catch the exploit using YARA or Snort rules. This method works for samples that are not obfuscated, including samples generated by Metasploit. However, against in-the-wild samples, such signature-based detection is insufficient. For instance, \u003Ca href=\u0022http:\/\/researchcenter.paloaltonetworks.com\/2016\/02\/new-malware-rover-targets-indian-ambassador-to-afghanistan\/\u0022\u003Ethe malicious RTF targeting the Ambassador of India\u003C\/a\u003E is a good sample to illustrate the downside of the signature based detection. Figure 1 shows this RTF document in a hex editor. We simplified Figure 1 because of the space limitations \u2013 there were plenty of dummy symbols such as { } in the initial sample.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Fig1.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1. Obfuscated sample of CVE-2010-3333\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAs we can see, the pFragments keyword has been split into many pieces that would bypass most signature based detection. For instance, most anti-virus products failed to detect this sample on first submission to VirusTotal. In fact, not only will the split pieces of \\sn be combined together, pieces of \\sv will be combined as well. The following example demonstrates this obfuscation:\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002278\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022337\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\rtf1{\\shp{\\sp{\\sn2 pF}{\\sn44 ragments}{\\sv 1;28}{\\sv ;fffffffffffff\u2026.}}}}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002278\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022337\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\rtf1{\\shp{\\sp{\\sn pFragments}{\\sv 1;28 ;fffffffffffff\u2026.}}}}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EWe can come up with a variety of ideas different from the aforementioned sample to defeat static signature based detection.\u003C\/p\u003E\n\u003Cp\u003ENotice the mixed \u2018\\x0D\u2019 and \u2018\\x0A\u2019 \u2013 they are \u2018\\r\u2019 and \u2018\\n\u2019 and the RTF parser would simply ignore them.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E2.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Embedded objects\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EUsers can embed variety of objects into RTF, such as OLE (Object Linking and Embedding) control objects. This makes it possible for OLE related vulnerabilities such as CVE-2012-0158 and CVE-2015-1641 to be accommodated in RTF files. In addition to exploits, it is not uncommon to see executable files such as PE, CPL, VBS and JS embedded in RTF files. These files require some form of social engineering to trick users into launching the embedded objects. We have even seen some Data Loss Prevention (DLP) solutions embedding PE files inside RTF documents. It\u2019s a bad practice because it cultivates poor habits in users.\u003C\/p\u003E\n\u003Cp\u003ELet\u2019s take a glance at \u003Ca href=\u0022https:\/\/www.microsoft.com\/en-sg\/download\/details.aspx?id=10725\u0022\u003Ethe embedded object syntax first\u003C\/a\u003E:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab3.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u0026lt;objtype\u0026gt; specifies the type of object. \\objocx is the most common type used in malicious RTFs for embedding OLE control objects; as such, let\u2019s take it as an example. The data right after \\objdata is OLE1 native data, \u003Ca href=\u0022https:\/\/www.microsoft.com\/en-sg\/download\/details.aspx?id=10725\u0022\u003Edefined as\u003C\/a\u003E:\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002264\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u0026lt;data\u0026gt;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022351\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E(\\binN #BDATA) | #SDATA\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002264\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E#BDATA\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022351\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EBinary data\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002264\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E#SDATA\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022351\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EHexadecimal data\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EAttackers would try to insert various elements into the \u0026lt;data\u0026gt; to evade static signature detection. Let\u2019s take a look at some examples to understand these tricks:\u003C\/p\u003E\n\u003Cp\u003Ea.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; For example, \\binN can be swapped with #SDATA. The data right after \\binN is raw binary data. In the following example, the numbers 123 will be treated as binary data and hence translated into hex values 313233 in memory.\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002242\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022337\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\uff5b\\object\\objocx\\objdata \\bin3 123\uff5d\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002242\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022337\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\uff5b\\object\\objocx\\objdata 313233\uff5d\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003ELet\u2019s look at another example:\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\uff5b\\object\\objocx\\objdata \\bin41541544011100001100000000000000000000000000000000000000000003 123\uff5d\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\uff5b\\object\\objocx\\objdata 313233\uff5d\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EIf we try to call atoi or atol with the numeric parameter string marked in red in the table above, we will get 0x7fffffff while its true value should be 3.\u003C\/p\u003E\n\u003Cp\u003EThis happens because \u003Ca href=\u0022https:\/\/www.microsoft.com\/en-sg\/download\/details.aspx?id=10725\u0022\u003E\\bin takes a 32-bit signed integer numeric parameter\u003C\/a\u003E. You would think that the RTF parser calls atoi or atol to convert the numeric string to an integer; however, that\u2019s is not the case. Microsoft Word\u2019s RTF parser does not use these standard C runtime functions. Instead, the atoi function in Microsoft Word\u2019s RTF parser is implemented as follows:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab4.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003Eb.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\ucN and \\uN\u003Cbr\u003E\nBoth of them are ignored, and the characters right after \\uN would not be skipped.\u003C\/p\u003E\n\u003Cp\u003Ec.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The space characters: 0x0D (\\n), 0x0A (\\r), 0x09 (\\t) are ignored.\u003C\/p\u003E\n\u003Cp\u003Ed.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Escaped characters\u003Cbr\u003E\nRTF has some special symbols that are reserved. For normal use, users will need to escape these symbols. Here\u0027s an incomplete list:\u003C\/p\u003E\n\u003Cp\u003E\\}\u0026nbsp; \u003Cbr\u003E\n\\{\u003Cbr\u003E\n\\%\u003Cbr\u003E\n\\+\u003Cbr\u003E\n\\-\u003Cbr\u003E\n\\\\\u003Cbr\u003E\n\\\u0027hh\u003C\/p\u003E\n\u003Cp\u003EAll of those escaped characters are ignored, but there\u2019s an interesting situation with \\\u2019hh. Let\u2019s look into an example first:\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002270\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022309\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 341\\\u2019112345 }\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002270\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022309\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 342345}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EWhen parsing \\\u201911, the parser will treat the 11 as an encoded hex byte. This hex byte is then discarded before it continues parsing the rest of objdata. The 1 preceding \\\u201911 has also been discarded. Once the RTF parser parses the 1 right before \\\u201911, which is the higher 4-bit of an octet, and then immediately encounters \\\u201911, the higher 4-bit would be discarded. That\u2019s because the internal state for decoding the hex string to binary bytes has been reset.\u003C\/p\u003E\n\u003Cp\u003EThe table below shows the processing procedure, the two 1s in the yellow rows are from \\\u201911. It\u2019s clear that the mixed \\\u201911 disorders the state variable, which causes the higher 4-bit of the second byte to be discarded:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab5.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003Ee.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Oversized control word and numeric parameter\u003Cbr\u003E\nThe \u003Ca href=\u0022https:\/\/www.microsoft.com\/en-sg\/download\/details.aspx?id=10725\u0022\u003ERTF specification\u003C\/a\u003E says that a control word\u2019s name cannot be longer than 32 letters and the numeric parameter associated with the control word must be a signed 16-bit integer or signed 32-bit integer, but the RTF parser of Microsoft Office doesn\u2019t strictly obey the specification. Its implementation only reserves a buffer of size 0xFF for storing the control word string and the numeric parameter string, both of which are null-terminated. All characters after the maximum buffer length (0xFF) will not remain as part of the control word or parameter string. Instead, the control word or parameter will be terminated.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab6.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003EIn the first obfuscated example, the length of the over-sized control word is 0xFE. By adding a null-terminator, the control word string will reach the maximum length of 0xFF, then the remaining data belongs to objdata.\u003C\/p\u003E\n\u003Cp\u003EFor the second obfuscated example, the total length of the \u201cbin\u201d control word and its parameter is 0xFD. By adding their null-terminator, the length equals 0xFF.\u003C\/p\u003E\n\u003Cp\u003Ef.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Additional techniques\u003C\/p\u003E\n\u003Cp\u003EThe program uses the last \\objdata control word in a list, as shown here:\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 554564{\\*\\objdata 4444}54545} OR\u003C\/p\u003E\n\u003Cp\u003E{\\object\\objocx\\objdata 554445\\objdata 444454545}\u003C\/p\u003E\n\u003Cp\u003E{\\object\\objocx{{\\objdata 554445}{\\objdata 444454545}}}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 444454545}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EAs we can see here, except for \\binN, other control words are ignored:\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 44444444{\\par2211 5555}6666}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; OR\u003C\/p\u003E\n\u003Cp\u003E{\\object\\objocx\\objdata 44444444{\\datastore2211 5555}6666} OR\u003C\/p\u003E\n\u003Cp\u003E{\\object\\objocx\\objdata 44444444\\datastore2211 55556666}\u0026nbsp;\u0026nbsp; OR\u003C\/p\u003E\n\u003Cp\u003E{\\object\\objocx\\objdata 44444444{\\unknown2211 5555}6666}\u0026nbsp;\u0026nbsp; OR\u003C\/p\u003E\n\u003Cp\u003E{\\object\\objocx\\objdata 44444444\\unknown2211 55556666}\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 4444444455556666}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EThere is another special case that makes the situation a bit more complicated. That is control symbol \\*. From RTF specification, we can get the description for \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.microsoft.com\/en-sg\/download\/details.aspx?id=10725\u0022 target=\u0022_blank\u0022\u003Ethis control symbol:\u003C\/a\u003E\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u003Ci\u003EDestinations added after the \u003Ca href=\u0022#RTF_Spec_1987\u0022\u003E1987 RTF Specification\u003C\/a\u003E may be preceded by the control symbol \u003Cb\u003E\\*\u003C\/b\u003E (backslash asterisk). This control symbol identifies destinations whose related text should be ignored if the RTF reader does not recognize the destination control word.\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003ELet\u2019s take a look at how it can be used in obfuscations:\u003C\/p\u003E\n\u003Cp\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 44444444{\\*\\par314 5555}6666}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 4444444455556666}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\\par is a known control word that does not accept any data. RTF parser will skip the control word and only the data that follows remains.\u003C\/p\u003E\n\u003Cp\u003E2.\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 44444444{\\*\\datastore314 5555}6666}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 444444446666}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003ERTF parser can also recognize \\datastore and understand that it can accept data, therefore the following data will be consumed by \\datastore.\u003C\/p\u003E\n\u003Cp\u003E3.\u003C\/p\u003E\n\u003Ctable cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EObfuscated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 44444444{\\*\\unknown314 5555}6666}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EClear\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022316\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E{\\object\\objocx\\objdata 444444446666}\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EFor an analyst, it\u2019s difficult to manually extract embedded objects from an obfuscated RTF, and no public tool can handle obfuscated RTF. However, winword.exe uses the OleConvertOLESTREAMToIStorage function to convert OLE1 native data to OLE2 structured storage object. Here\u2019s the prototype of OleConvertOLESTREAMToIStorage:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab9.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003EThe object pointed by lpolestream contains a pointer to OLE1 native binary data. We can set a breakpoint at OleConvertOLESTREAMToIStorage and dump out the object data which has been de-obfuscated by the RTF Parser:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/RFT%20malware%20Yang\/Tab10.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003EThe last command .writemem writes a section of memory to d:\\evil_objdata.bin. You can specify other paths as you want; 0e170020 is the start address of the memory range, and 831b6 is the size.\u003C\/p\u003E\n\u003Cp\u003EMost of the obfuscation techniques of \\objdata can also apply to embedded images, but for images, it seems there is no obvious technique as OleConvertOLESTREAMToIStorage. To extract an obfuscated picture, locate the RTF parsing code quickly using data breakpoint and that will reveal the best point to dump the whole data.\u003C\/p\u003E\n\u003Ch4\u003E\u003Cb\u003EConclusion\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003EOur adversaries are sophisticated and familiar with the RTF format and the inner workings of Microsoft Word.\u0026nbsp; They have managed to devise these obfuscation tricks to evade traditional signature-based detection. Understanding how our adversary is performing obfuscation can in turn help us improve our detection of such malware.\u003C\/p\u003E\n\u003Ch4\u003E\u003Cb\u003EAcknowledgements\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003EThanks to Yinhong Chang, Jonell Baltazar and Daniel Regalado for their contributions to this blog.\u003C\/p\u003E\n",
        "jcr:lastModified": "Fri May 20 2016 16:12:09 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
      "text": "\u003Cp\u003EOur adversaries are familiar with the RTF format and the inner workings of Microsoft Word, and can devise obfuscation tricks to evade traditional signature-based detection. Understanding hackers perform obfuscation can in turn help us improve our detection of this type of malware.\u003C\/p\u003E\n",
      "jcr:lastModified": "Fri May 20 2016 15:08:09 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
