{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Thu Jul 16 2020 19:40:38 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "capa: Automatically Identify Malware Capabilities",
    "jcr:versionHistory": "6b29ab73-ac42-4b1a-948f-c582afc35f8b",
    "author": "Willi Ballenthin",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "08c32efe-ec9a-4266-a978-cff0fc8dfe44"
    ],
    "jcr:created": "Thu Jul 16 2020 19:42:29 GMT+0000",
    "cq:lastModified": "Thu Jul 16 2020 19:42:21 GMT+0000",
    "jcr:baseVersion": "08c32efe-ec9a-4266-a978-cff0fc8dfe44",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:cap-willi-ballenthin",
      "fireeye-blog-authors:moritz-raabe",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:analysis",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware",
      "fireeye-blog-tags:tools"
    ],
    "jcr:uuid": "59b7a05f-dcd3-46ff-b613-a27822a55282",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Jul 16 2020 15:40:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003Ecapa is the FLARE team\u2019s newest open-source tool for analyzing malicious programs. Our tool provides a framework for the community to encode, recognize, and share behaviors that we\u2019ve seen in malware. Regardless of your background, when you use capa, you invoke decades of cumulative reverse engineering experience to figure out what a program does. In this post you will learn how capa works, how to install and use the tool, and why you should integrate it into your triage workflow starting today.\u003C\/p\u003E\n\u003Ch4\u003EProblem\u003C\/h4\u003E\n\u003Cp\u003EEffective analysts can quickly understand and prioritize unknown files in investigations. However, determining if a program is malicious, the role it plays during an attack, and its potential capabilities requires at least basic malware analysis skills. And often, it takes an experienced reverse engineer to recover a file\u2019s complete functionality and guess at the author\u2019s intent.\u003C\/p\u003E\n\u003Cp\u003EMalware experts can quickly triage unknown binaries to gain first insights and guide further analysis steps. Less experienced analysts, on the other hand, oftentimes don\u2019t know what to look for and have trouble distinguishing the usual from the unusual. Unfortunately, common tools like strings \/ \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-floss\/\u0022\u003EFLOSS\u003C\/a\u003E or PE viewers display the lowest level of detail, burdening their users to combine and interpret data points.\u003C\/p\u003E\n\u003Ch4\u003EMalware Triage 01-01\u003C\/h4\u003E\n\u003Cp\u003ETo illustrate this, let us look at Lab 01-01 from \u003Ca href=\u0022https:\/\/nostarch.com\/malware\u0022\u003EPractical Malware Analysis\u003C\/a\u003E (PMA) available \u003Ca href=\u0022https:\/\/practicalmalwareanalysis.com\/labs\/\u0022\u003Ehere\u003C\/a\u003E. Our goal is to understand the program\u2019s functionality. Figure 1 shows the file\u2019s strings and import table with interesting values highlighted.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa\/Picture1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Interesting strings and import information of example malware from PMA Lab 1-1\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWith this data, reverse engineers can hypothesize about the strings and imported API functions to guess at the program\u2019s functionality\u2014but no more. The sample may create a mutex, start a process, or communicate over the network\u2014potentially to IP address 127.26.152.13. The Winsock (WS2_32) imports make us think about network functionality, but the names are not available here because they are, as is common, imported by ordinal.\u003C\/p\u003E\n\u003Cp\u003EDynamically analyzing this sample can confirm or disprove initial suspicions and reveal additional functionality. However, sandbox reports or dynamic analysis tools are limited to capturing behavior from the exercised code paths. This, for example, excludes any functionality triggered after a successful connection to the command and control (C2) server. We don\u2019t usually recommend analyzing malware with a live Internet connection.\u003C\/p\u003E\n\u003Cp\u003ETo really understand this file, we need to reverse engineer it. Figure 2 shows IDA Pro\u2019s decompilation of the program\u2019s main function. While we use the decompilation instead of disassembly to simplify our explanation, similar concepts apply to both representations.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa\/Picture2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Key functionality in the decompiled main function of PMA Lab 1-1\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWith a basic understanding of programming and the Windows API, we observe the following functionality. The malware:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003Ecreates a mutex to ensure only one instance is running\u003C\/li\u003E\n\u003Cli\u003Ecreates a TCP socket; indicated by the constants 2 = \u003Cspan class=\u0022code\u0022\u003EAF_INET\u003C\/span\u003E, 1 = \u003Cspan class=\u0022code\u0022\u003ESOCK_STREAM\u003C\/span\u003E, and 6 = \u003Cspan class=\u0022code\u0022\u003EIPPROTO_TCP\u003C\/span\u003E\u003C\/li\u003E\n\u003Cli\u003Econnects to IP address 127.26.152.13 on port 80\u003C\/li\u003E\n\u003Cli\u003Esends and receives data\u003C\/li\u003E\n\u003Cli\u003Ecompares received data to the strings \u003Cspan class=\u0022code\u0022\u003Esleep\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Eexec\u003C\/span\u003E\u003C\/li\u003E\n\u003Cli\u003Ecreates a new process\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EAlthough not every code path may execute on each run, we say that the malware has the capability to execute these behaviors. And, by combining the individual conclusions, we can reason that the malware is a backdoor that can run an arbitrary program specified by a hard-coded C2 server. This high-level conclusion enables us to scope an investigation and decide how to respond to the threat.\u003C\/p\u003E\n\u003Ch4\u003EAutomating Capability Identification\u003C\/h4\u003E\n\u003Cp\u003EOf course, malware analysis is rarely as straight forward. The artifacts of intent may be spread through a binary that contains hundreds or thousands of functions. Furthermore, reverse engineering has a fairly steep learning curve and requires solid understanding of many low-level concepts such as assembly language and operating system internals.\u003C\/p\u003E\n\u003Cp\u003EHowever, with enough practice, we can recognize capabilities in programs simply from repetitive patterns of API calls, strings, constants, and other features. With capa, we demonstrate that some of our key analysis conclusions are actually feasible to perform automatically. The tool provides a common yet flexible way to codify expert knowledge and make it available to the entire community. When you run capa, it recognizes features and patterns as a human might, producing high-level conclusions that can drive subsequent investigative steps. For example, when capa recognizes the ability for unencrypted HTTP communication, this might be the hint you need to pivot into proxy logs or other network traces.\u003C\/p\u003E\n\u003Ch4\u003EIntroducing capa\u003C\/h4\u003E\n\u003Cp\u003EWhen we run capa against our example program, the tool output in Figure 3 almost speaks for itself. The main table shows all identified capabilities in this sample, with each entry on the left describing a capability. The associated namespace on the right helps to group related capabilities. capa did a fantastic job and described all the program capabilities we\u2019ve discussed in the previous section.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa\/Picture3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: capa analysis of PMA Lab 1-1\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe find that capa often provides surprisingly good results. That\u2019s why we want capa to always be able to show the evidence used to identify a capability. Figure 4 shows capa\u2019s detailed output for the \u201ccreate TCP socket\u201d conclusion. Here, we can inspect the exact locations in the binary where capa found the relevant features. We\u2019ll see the syntax of rules a bit later \u2013 in the meantime, we can surmise that they\u2019re made up of a logic tree combining low level features.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa\/Picture4.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Feature match details for \u0026quot;create TCP socket\u0026quot; rule in example malware\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EHow capa Works\u003C\/h4\u003E\n\u003Cp\u003Ecapa consists of two main components that algorithmically triage unknown programs. First, a code analysis engine extracts features from files, such as strings, disassembly, and control flow. Second, a logic engine finds combinations of features that are expressed in a common rule format. When the logic engine finds a match, capa reports on the capability described by the rule.\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003EFeature Extraction\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003EThe code analysis engine extracts low-level features from programs. All the features are consistent with what a human might recognize, such as strings or numbers, and enable capa to explain its work. These features typically fall into two large categories: file features and disassembly features.\u003C\/p\u003E\n\u003Cp\u003EFile features are extracted from the raw file data and its structure, e.g. the PE file header. This is information that you might notice by scrolling across the entire file. Besides the above discussed strings and imported APIs, these include exported function and section names.\u003C\/p\u003E\n\u003Cp\u003EDisassembly features are extracted from an advanced static analysis of a file \u2013 this means disassembling and reconstructing control flow. Figure 5 shows selected disassembly features including API calls, instruction mnemonics, numbers, and string references.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa\/Picture5.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Examples of file features in a disassembled code segment of PMA Lab 1-1\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBecause the advanced analysis can distinguish between functions and other scopes in a program, capa can apply its logic at an appropriate level of detail. For example, it doesn\u2019t get confused when unrelated APIs are used in different functions since capa rules can specify that they should be matched against each function independently.\u003C\/p\u003E\n\u003Cp\u003EWe\u2019ve designed capa with flexible and extendable feature extraction in mind. Additional code analysis backends can be integrated easily. Currently, the capa standalone version relies on the \u003Ca href=\u0022https:\/\/github.com\/vivisect\/vivisect\u0022\u003Evivisect\u003C\/a\u003E analysis framework. If you\u2019re using IDA Pro, you can also run capa using the IDAPython backend. Note that sometimes differences among code analysis engines may result in divergent feature sets and hence different results. Fortunately, this usually isn\u2019t a serious problem in practice.\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003Ecapa Rules\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003EA capa rule uses a structured combination of features to describe a capability that may be implemented in a program. If all required features are present, capa concludes that the program contains the capability.\u003C\/p\u003E\n\u003Cp\u003Ecapa rules are YAML documents that contain metadata and a tree of statements to express their logic. Among other things, the rule language supports logical operators and counting. In Figure 6, the \u201ccreate TCP socket\u201d rule says that the numbers 6, 1, and 2, \u003Ci\u003Eand\u003C\/i\u003E calls to either of the API functions \u003Cspan class=\u0022code\u0022\u003Esocket\u003C\/span\u003E or \u003Cspan class=\u0022code\u0022\u003EWSASocket\u003C\/span\u003E must be present in the scope of a single basic block. Basic blocks group assembly code at a very low level making them an ideal place to match tightly related code segments. Besides within basic blocks, capa supports matching at the function and the file level. The function scope ties together all features in a disassembled function, while the file scope contains all features across the entire file.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa\/Picture6.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: capa rule logic to identify TCP socket creation\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 7 highlights the rule metadata that enables capa to display high-level, meaningful results to its users. The rule name describes the identified capability while the \u003Cspan class=\u0022code\u0022\u003Enamespace\u003C\/span\u003E associates it with a technique or analysis category. We already saw the name and namespace in the capability table of capa\u2019s output. The metadata section can also include fields like \u003Cspan class=\u0022code\u0022\u003Eauthor\u003C\/span\u003E or \u003Cspan class=\u0022code\u0022\u003Eexamples\u003C\/span\u003E. We use examples to reference files and offsets where we know a capability to be present, enabling unit testing and validation of every rule. Moreover, capa rules serve as great documentation for behaviors seen in real-world malware, so feel free to keep a copy around as a reference. In a future post we will discuss other meta information, including capa\u2019s support for the ATT\u0026amp;CK and the Malware Behavior Catalog frameworks.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa\/Picture7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Rule meta information\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EInstallation\u003C\/h4\u003E\n\u003Cp\u003ETo make using capa as easy as possible, we provide \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/capa\/releases\u0022\u003Estandalone executables for Windows, Linux, and OSX\u003C\/a\u003E. The tool is written in Python and the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/capa\u0022\u003Esource code is available on our GitHub\u003C\/a\u003E. Additional and up-to-date \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/blob\/master\/doc\/installation.md\u0022\u003Einstallation instructions\u003C\/a\u003E are available in the capa repository.\u003C\/p\u003E\n\u003Cp\u003ENewer versions of \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2018\/11\/flare-vm-update.html\u0022\u003EFLARE-VM\u003C\/a\u003E (available on \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-vm\u0022\u003EGitHub\u003C\/a\u003E) include capa as well.\u003C\/p\u003E\n\u003Ch4\u003EUsage\u003C\/h4\u003E\n\u003Cp\u003ETo identify capabilities in a program run capa and specify the input file:\u003C\/p\u003E\n\u003Cp\u003E$ capa suspicious.exe\u003C\/p\u003E\n\u003Cp\u003Ecapa supports Windows PE files (EXE, DLL, SYS) and shellcode. To run capa on a shellcode file you must explicitly specify the file format and architecture, for example to analyze 32-bit shellcode:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cspan class=\u0022code\u0022\u003E$ capa -f sc32 shellcode.bin\u003C\/span\u003E\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003ETo obtain detailed information on identified capabilities, capa supports two additional verbosity levels. To get the most detailed output on where and why capa matched on rules use the very verbose option:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cspan class=\u0022code\u0022\u003E$ capa -vv suspicious.exe\u003C\/span\u003E\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EIf you only want to focus on specific rules you can use the tag option to filter on fields in the rule meta section:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cspan class=\u0022code\u0022\u003E$ capa -t \u0026quot;create TCP socket\u0026quot; suspicious.exe\u003C\/span\u003E\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EDisplay capa\u2019s help to see all supported options and consolidate the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/tree\/master\/doc\u0022\u003Edocumentation\u003C\/a\u003E:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cspan class=\u0022code\u0022\u003E$ capa -h\u003C\/span\u003E\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003EContributing\u003C\/h4\u003E\n\u003Cp\u003EWe hope that capa brings value to the community and encourage any type of contribution. Your feedback, ideas, and pull requests are very welcome. The \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/blob\/master\/.github\/CONTRIBUTING.md\u0022\u003Econtributing document\u003C\/a\u003E is a great starting point.\u003C\/p\u003E\n\u003Cp\u003ERules are the foundation of capa\u2019s identification algorithm. We want to make it easy and fun to write them. If you have any rule ideas, please open an issue or even better submit a pull request to \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa-rules\u0022\u003Ecapa-rules\u003C\/a\u003E. This way, everyone can benefit from the collective knowledge of our malware analysis community.\u003C\/p\u003E\n\u003Cp\u003ETo separate our work and discussions between the capa source code and the supported rules, we use a second GitHub repository for \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/capa-rules\u0022\u003Eall rules that come embedded within capa\u003C\/a\u003E.\u0026nbsp;The capa main repository embeds the rule repository as a git submodule. Please refer to the rules repository for further details, including the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa-rules\/blob\/master\/doc\/format.md\u0022\u003Erule format documentation\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EIn this blog post we have introduced the FLARE team\u2019s newest contribution to the malware analysis community. capa is an open-source framework to encode, recognize, and share behaviors seen in malware. We think that the community needs this type of tool to fight back against the volume of malware that we encounter during investigations, hunting, and triage. Regardless of your background, when you use capa, you invoke decades of cumulative experience to figure out what a program does.\u003C\/p\u003E\n\u003Cp\u003ETry out capa in your next malware analysis. The tool is extremely easy to use and can provide valuable information for forensic analysts, incident responders, and reverse engineers. If you enjoy the tool, run into issues using it, or have any other comments, please \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/capa\/\u0022\u003Econtact us via the projects GitHub page\u003C\/a\u003E.\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Jul 16 2020 19:42:21 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EThe FLARE team\u2019s newest open-source tool, capa, provides a framework for the community to encode, recognize and share behaviors that we\u0027ve seen in malware.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Jul 15 2020 21:40:23 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Jul 16 2020 19:34:21 GMT+0000",
      "imageRotate": "0"
    }
  }
}
