{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Mon Jul 19 2021 17:59:13 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "capa 2.0: Better, Faster, Stronger",
    "jcr:versionHistory": "4bc60a57-89e2-4b20-8421-655d59fe9055",
    "author": "William Ballenthin",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "0511d127-e7df-46a3-8895-b997bd51f5fc"
    ],
    "jcr:created": "Mon Jul 19 2021 18:37:04 GMT+0000",
    "cq:lastModified": "Mon Jul 19 2021 18:36:52 GMT+0000",
    "jcr:baseVersion": "0511d127-e7df-46a3-8895-b997bd51f5fc",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:cap-william-ballenthin",
      "fireeye-blog-authors:moritz-raabe",
      "fireeye-blog-authors:mike-hunhoff",
      "fireeye-blog-authors:ana-maria-martinez-gomez",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:analysis",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware",
      "fireeye-blog-tags:reverse-engineering"
    ],
    "jcr:uuid": "eacccee5-817d-4f68-969b-0372dd16257c",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Mon Jul 19 2021 14:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EWe are excited to announce version 2.0 of our open-source tool called capa. capa automatically identifies capabilities in programs using an extensible rule set. The tool supports both malware triage and deep dive reverse engineering. If you haven\u2019t heard of capa before, or need a refresher, check out our \u003Ca href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2020\/07\/capa-automatically-identify-malware-capabilities.html\u0022 adhocenable=\u0022false\u0022\u003Efirst blog post\u003C\/a\u003E. You can download capa 2.0 standalone binaries from the project\u2019s \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/releases\u0022\u003Erelease page\u003C\/a\u003E and checkout the source code on \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\u0022\u003EGitHub\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003Ecapa 2.0 enables anyone to contribute rules more easily, which makes the existing ecosystem even more vibrant. This blog post details the following major improvements included in capa 2.0:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003ENew features and enhancements for the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/tree\/master\/capa\/ida\/plugin\u0022\u003Ecapa explorer\u003C\/a\u003E IDA Pro plugin, allowing you to interactively explore capabilities and write new rules without switching windows\u003C\/li\u003E\n\u003Cli\u003EMore concise and relevant results via identification of library functions using FLIRT and the release of accompanying open-source FLIRT signatures\u003C\/li\u003E\n\u003Cli\u003EHundreds of new rules describing additional malware capabilities, bringing the collection up to 579 total rules, with more than half associated with ATT\u0026amp;CK techniques\u003C\/li\u003E\n\u003Cli\u003EMigration to Python 3, to make it easier to integrate capa with other projects\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003Ecapa explorer and Rule Generator\u003C\/h4\u003E\n\u003Cp\u003Ecapa explorer is an IDAPython plugin that shows capa results directly within IDA Pro. The version 2.0 release includes many additions and improvements to the plugin, but we\u0027d like to highlight the most exciting addition: capa explorer now helps you write new capa rules directly in IDA Pro!\u003C\/p\u003E\n\u003Cp\u003ESince we spend most of our time in reverse engineering tools such as IDA Pro analyzing malware, we decided to add a capa rule generator. Figure 1 shows the rule generator interface.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: capa explorer rule generator interface\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce you\u2019ve installed capa explorer using the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/tree\/master\/capa\/ida\/plugin#getting-started\u0022\u003EGetting Started\u003C\/a\u003E guide, open the plugin by navigating to \u003Ci\u003EEdit \u003C\/i\u003E\u0026gt; \u003Ci\u003EPlugins \u003C\/i\u003E\u0026gt; \u003Ci\u003EFLARE capa explorer\u003C\/i\u003E. You can start using the rule generator by selecting the \u003Ci\u003ERule Generator\u003C\/i\u003E tab at the top of the capa explorer pane. From here, navigate your IDA Pro Disassembly view to the function containing a technique you\u0027d like to capture and click the \u003Ci\u003EAnalyze\u003C\/i\u003E button. The rule generator will parse, format, and display all the capa features that it finds in your function. You can write your rule using the rule generator\u0027s three main panes: \u003Ci\u003EFeatures\u003C\/i\u003E, \u003Ci\u003EPreview\u003C\/i\u003E, and \u003Ci\u003EEditor\u003C\/i\u003E. Your first step is to add features from the \u003Ci\u003EFeatures\u003C\/i\u003E pane.\u003C\/p\u003E\n\u003Cp\u003EThe \u003Ci\u003EFeatures\u003C\/i\u003E pane is a tree view containing all the capa features extracted from your function. You can filter for specific features using the search bar at the top of the pane. Then, you can add features by double-clicking them. Figure 2 shows this in action.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig2.gif\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: capa explorer feature selection\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAs you add features from the \u003Ci\u003EFeatures\u003C\/i\u003E pane, the rule generator automatically formats and adds them to the \u003Ci\u003EPreview\u003C\/i\u003E and \u003Ci\u003EEditor\u003C\/i\u003E panes. The \u003Ci\u003EPreview\u003C\/i\u003E and \u003Ci\u003EEditor\u003C\/i\u003E panes help you finesse the features that you\u0027ve added and allow you to modify other information like the rule\u0027s metadata.\u003C\/p\u003E\n\u003Cp\u003EThe \u003Ci\u003EEditor\u003C\/i\u003E pane is an interactive tree view that displays the statement and feature hierarchy that forms your rule. You can reorder nodes using drag-and-drop and edit nodes via right-click context menus. To help humans understand the rule logic, you can add descriptions and comments to features by typing in the \u003Ci\u003EDescription\u003C\/i\u003E and \u003Ci\u003EComment\u003C\/i\u003E columns. The rule generator automatically formats any changes that you make in the \u003Ci\u003EEditor\u003C\/i\u003E pane and adds them to the \u003Ci\u003EPreview\u003C\/i\u003E pane. Figure 3 shows how to manipulate a rule using the \u003Ci\u003EEditor\u003C\/i\u003E pane.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig3.gif\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: capa explorer editor pane\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Ci\u003EPreview\u003C\/i\u003E pane is an editable textbox containing the final rule text. You can edit any of the text displayed. The rule generator automatically formats any changes that you make in the \u003Ci\u003EPreview\u003C\/i\u003E pane and adds them to the \u003Ci\u003EEditor\u003C\/i\u003E pane. Figure 4 shows how to edit a rule directly in the \u003Ci\u003EPreview \u003C\/i\u003Epane.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig4.gif\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: capa explorer preview pane\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAs you make edits the rule generator lints your rule and notifies you of any errors using messages displayed underneath the \u003Ci\u003EPreview \u003C\/i\u003Epane. Once you\u0027ve finished writing your rule you can save it to your capa rules directory by clicking the \u003Ci\u003ESave\u003C\/i\u003E button. The rule generator saves exactly what is displayed in the \u003Ci\u003EPreview \u003C\/i\u003Epane. It\u2019s that simple!\u003C\/p\u003E\n\u003Cp\u003EWe\u2019ve found that using the capa explorer rule generator significantly reduces the amount of time spent writing new capa rules. This tool not only automates most of the rule writing process but also eliminates the need to context switch between IDA Pro and your favorite text editor allowing you to codify your malware knowledge while it\u2019s fresh in your mind.\u003C\/p\u003E\n\u003Cp\u003ETo learn more about capa explorer and the rule generator check out the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/tree\/master\/capa\/ida\/plugin\u0022\u003EREADME\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch4\u003ELibrary Function Identification Using FLIRT\u003C\/h4\u003E\n\u003Cp\u003EAs we wrote hundreds of capa rules and inspected thousands of capa results, we recognized that the tool sometimes shows distracting results due to embedded library code. We believe that capa needs to focus its attention on the programmer\u2019s logic and ignore supporting library code. For example, highly optimized C\/C++ runtime routines and open-source library code enable a programmer to quickly build a product but are not the \u003Ci\u003Eproduct itself\u003C\/i\u003E. Therefore, capa results should reflect the programmer\u2019s intent for the program rather than a categorization of every byte in the program.\u003C\/p\u003E\n\u003Cp\u003ECompare the capa v1.6 results in Figure 5 versus capa v2.0 results in Figure 6. capa v2.0 identifies and skips almost 200 library functions and produces more relevant results.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig5.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: capa v1.6 results without library code recognition\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig6.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: capa v2.0 results ignoring library code functions\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ESo, we searched for a way to differentiate a programmer\u2019s code from library code.\u003C\/p\u003E\n\u003Cp\u003EAfter experimenting with a few strategies, we landed upon the Fast Library Identification and Recognition Technology (FLIRT) \u003Ca href=\u0022https:\/\/hex-rays.com\/products\/ida\/tech\/flirt\/in_depth\/\u0022\u003Edeveloped by Hex-Rays\u003C\/a\u003E. Notably, this technique has remained stable and effective since 1996, is fast, requires very limited code analysis, and enjoys a wide community in the IDA Pro userbase. We figured out how IDA Pro matches FLIRT signatures and \u003Ca href=\u0022https:\/\/crates.io\/crates\/lancelot-flirt\u0022\u003Ere-implemented a matching engine in Rust\u003C\/a\u003E with \u003Ca href=\u0022https:\/\/pypi.org\/project\/python-flirt\/\u0022\u003EPython bindings\u003C\/a\u003E. Then, we built an \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/siglib\/\u0022\u003Eopen-source signature set\u003C\/a\u003E that covers many of the library routines encountered in modern malware. Finally, we updated capa to use the new signatures to guide its analysis.\u003C\/p\u003E\n\u003Cp\u003Ecapa uses these signatures to differentiate library code from a programmer\u2019s code. While capa can extract and match against the names of embedded library functions, it will skip finding capabilities and behaviors within the library code. This way, capa results better reflect the logic written by a programmer.\u003C\/p\u003E\n\u003Cp\u003EFurthermore, library function identification drastically improves capa runtime performance: since capa skips processing of library functions, it can avoid the costly rule matching steps across a substantial percentage of real-world functions. Across our testbed of 206 samples, 28% of the 186,000 total functions are recognized as library code by our function signatures. As our implementation can recognize around 100,000 functions\/sec, library function identification overhead is negligible and capa is approximately 25% faster than in 2020!\u003C\/p\u003E\n\u003Cp\u003EFinally, we introduced a new feature class that rule authors can use to match recognized library functions: \u003Cspan class=\u0022code\u0022\u003Efunction-name\u003C\/span\u003E. This feature matches at the file-level scope. We\u2019ve already started using this new capability to recognize specific implementations of cryptography routines, such as AES provided by \u003Ca href=\u0022https:\/\/www.cryptopp.com\/\u0022\u003ECrypto++\u003C\/a\u003E, as shown in the example rule in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Example rule using function-name to recognize AES via Crypto++\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAs we developed rules for interesting behaviors, we learned a lot about where uncommon techniques are used legitimately. For example, as malware analysts, we most commonly see the \u003Cspan class=\u0022code\u0022\u003Ecpuid\u003C\/span\u003E instruction alongside anti-analysis checks, such as in VM detection routines. Therefore, we naively crafted rules to flag this instruction. But, when we tested it against our testbed, the rule matched most modern programs because this instruction is often legitimately used in high-optimized routines, such as \u003Cspan class=\u0022code\u0022\u003Ememcpy\u003C\/span\u003E, to opt-in to newer CPU features. In hindsight, this is obvious, but at the time it was a little surprising to see \u003Cspan class=\u0022code\u0022\u003Ecpuid\u003C\/span\u003E in around 15% of all executables. With the new FLIRT support, capa recognizes the optimized \u003Cspan class=\u0022code\u0022\u003Ememcpy\u003C\/span\u003E routine embedded by Visual Studio and won\u2019t flag the embedded \u003Cspan class=\u0022code\u0022\u003Ecpuid\u003C\/span\u003E instruction, as its not part of the programmer\u2019s code.\u003C\/p\u003E\n\u003Cp\u003EWhen a user upgrades to capa 2.0, they\u2019ll see that the tool runs faster and provides more precise results.\u003C\/p\u003E\n\u003Ch4\u003ESignature Generation\u003C\/h4\u003E\n\u003Cp\u003ETo provide the benefits of \u003Ca href=\u0022https:\/\/pypi.org\/project\/python-flirt\/\u0022\u003Epython-flirt\u003C\/a\u003E to all users (especially those without an IDA Pro license) we have spent significant time to create a comprehensive FLIRT signature set for the common malware analysis use-case. The signatures come included with capa and are also available at \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/siglib\u0022\u003Eour GitHub\u003C\/a\u003E\u0026nbsp;under the Apache 2.0 license. We believe that other projects can benefit greatly from this. For example, we expect the performance of \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-floss\u0022\u003EFLOSS\u003C\/a\u003E to improve once we\u2019ve incorporated library function identification. Moreover, you can use our signatures with IDA Pro to recognize more library code.\u003C\/p\u003E\n\u003Cp\u003EOur initial signatures include:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EFrom Microsoft Visual Studio (VS), for all major versions from VS6 to VS2019:\u003Cul\u003E\n\u003Cli\u003EC and C++ run-time libraries\u003C\/li\u003E\n\u003Cli\u003EActive Template Library (ATL) and Microsoft Foundation Class (MFC) libraries\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003Cli\u003EThe following open-source projects as compiled with VS2015, VS2017, and VS2019:\u003Cul\u003E\n\u003Cli\u003ECryptoPP\u003C\/li\u003E\n\u003Cli\u003Ecurl\u003C\/li\u003E\n\u003Cli\u003EMicrosoft Detours\u003C\/li\u003E\n\u003Cli\u003EMbed TLS (previously PolarSSL)\u003C\/li\u003E\n\u003Cli\u003EOpenSSL\u003C\/li\u003E\n\u003Cli\u003Ezlib\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EIdentifying and collecting the relevant library and object files took a lot of work. For the older VS versions this was done manually. For newer VS versions and the respective open-source projects we were able to automate the process using \u003Ca href=\u0022https:\/\/vcpkg.io\u0022\u003Evcpgk\u003C\/a\u003E and Docker.\u003C\/p\u003E\n\u003Cp\u003EWe then used the IDA Pro FLAIR utilities to convert gigabytes of executable code into pattern files and then into signatures. This process required extensive research and much trial and error. For instance, we spent two weeks testing and exploring the various FLAIR options to understand the best combination. We appreciate Hex-Rays for providing high-quality signatures for IDA Pro and thank them for sharing their research and tools with the community.\u003C\/p\u003E\n\u003Cp\u003ETo learn more about the pattern and signature file generation check out the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/siglib\u0022\u003Esiglib\u003C\/a\u003E repository. The FLAIR utilities are available in the protected download area on \u003Ca href=\u0022https:\/\/www.hex-rays.com\/products\/ida\/support\/download\/\u0022\u003EHex-Rays\u2019 website\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch4\u003ERule Updates\u003C\/h4\u003E\n\u003Cp\u003ESince the initial release, the community has more than doubled the total capa rule count from 260 to over \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa-rules\u0022\u003E570 capability detection rules\u003C\/a\u003E! This means that capa recognizes many more techniques seen in real-world malware, certainly saving analysts time as they reverse engineer programs. And to reiterate, we\u2019ve surfed a wave of support as almost 30 colleagues from a dozen organizations have volunteered their experience to develop these rules. Thank you!\u003C\/p\u003E\n\u003Cp\u003EFigure 8 provides a high-level overview of capabilities capa currently captures, including:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cb\u003EHost Interaction \u003C\/b\u003Edescribes program functionality to interact with the file system, processes, and the registry\u003C\/li\u003E\n\u003Cli\u003E\u003Cb\u003EAnti-Analysis\u003C\/b\u003E describes packers, Anti-VM, Anti-Debugging, and other related techniques\u003C\/li\u003E\n\u003Cli\u003E\u003Cb\u003ECollection\u003C\/b\u003E describes functionality used to steal data such as credentials or credit card information\u003C\/li\u003E\n\u003Cli\u003E\u003Cb\u003EData Manipulation\u003C\/b\u003E describes capabilities to encrypt, decrypt, and hash data\u003C\/li\u003E\n\u003Cli\u003E\u003Cb\u003ECommunication\u003C\/b\u003E describes data transfer techniques such as HTTP, DNS, and TCP\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/capa-2\/fig8.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Overview of capa rule categories\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EMore than half of capa\u2019s rules are associated with a \u003Ca href=\u0022https:\/\/attack.mitre.org\/\u0022\u003EMITRE ATT\u0026amp;CK\u003C\/a\u003E technique including all techniques introduced in ATT\u0026amp;CK \u003Ca href=\u0022https:\/\/medium.com\/mitre-attack\/attack-april-2021-release-39accaf23c81\u0022\u003Eversion 9\u003C\/a\u003E that lie within capa\u2019s scope. Moreover, almost half of the capa rules are currently associated with a \u003Ca href=\u0022https:\/\/github.com\/MBCProject\/mbc-markdown\u0022\u003EMalware Behavior Catalog\u003C\/a\u003E (MBC) identifier.\u003C\/p\u003E\n\u003Cp\u003EFor more than 70% of capa rules we have collected associated real-world binaries. Each binary implements interesting capabilities and exhibits noteworthy features. You can view the entire sample collection at our \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/capa-testfiles\u0022\u003Ecapa test files GitHub page\u003C\/a\u003E. We rely heavily on these samples for developing and testing code enhancements and rule updates.\u003C\/p\u003E\n\u003Ch4\u003EPython 3 Support\u003C\/h4\u003E\n\u003Cp\u003EFinally, we\u2019ve spent nearly three months migrating capa from Python 2.7 to Python 3. This involved working closely with \u003Ca href=\u0022https:\/\/github.com\/vivisect\/vivisect\u0022\u003Evivisect\u003C\/a\u003E and we would like to thank the team for their support. After extensive testing and a couple of releases supporting two Python versions, we\u2019re excited that capa 2.0 and future versions will be Python 3 only.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003ENow that you\u2019ve seen all the recent improvements to capa, we hope you\u2019ll upgrade to the newest capa version right away! Thanks to library function identification capa will report faster and more relevant results. Hundreds of new rules capture the most interesting malware functionality while the improved capa explorer plugin helps you to focus your analysis and codify your malware knowledge while it\u2019s fresh.\u003C\/p\u003E\n\u003Cp\u003EStandalone binaries for Windows, Mac, and Linux are available on the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/releases\u0022\u003Ecapa Releases page\u003C\/a\u003E. To install capa from \u003Ca href=\u0022https:\/\/pypi.org\/project\/flare-capa\/\u0022\u003EPyPi\u003C\/a\u003E use the command \u003Cspan class=\u0022code\u0022\u003Epip install flare-capa\u003C\/span\u003E. The source code is available at our \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/capa\u0022\u003Ecapa GitHub page\u003C\/a\u003E. The project page on GitHub contains detailed documentation, including thorough \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/blob\/master\/doc\/installation.md\u0022\u003Einstallation\u003C\/a\u003E instructions and a walkthrough of \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/blob\/master\/capa\/ida\/plugin\/README.md\u0022\u003Ecapa explorer\u003C\/a\u003E. Please use \u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa\/issues\u0022\u003EGitHub\u003C\/a\u003E to ask questions, discuss ideas, and submit issues.\u003C\/p\u003E\n\u003Cp\u003EWe highly encourage you to contribute to capa\u2019s rule corpus. The improved IDA Pro plugin makes it easier than ever before. If you have any issues or ideas related to rules, please let us know on the\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/capa-rules\u0022\u003EGitHub repository\u003C\/a\u003E. Remember, when you share a rule with the community, you scale your impact across hundreds of reverse engineers in dozens of organizations.\u003C\/p\u003E\n",
        "jcr:lastModified": "Mon Jul 19 2021 18:36:52 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EWe are excited to announce version 2.0 of our open-source tool, capa, which supports both malware triage and deep dive reverse engineering.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Jun 30 2021 16:41:54 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Mon Jul 19 2021 17:58:20 GMT+0000",
      "imageRotate": "0"
    }
  }
}
