{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed May 04 2016 09:04:19 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Operation Clandestine Wolf \u2013 Adobe Flash Zero-Day in APT3 Phishing Campaign ",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "fcd17498-5d70-42c1-b067-be680087283e",
    "author": "Erica Eng",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "todd.jackson",
    "focusKeyword": "APT3",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "7600b8a0-7b79-4670-a23b-3a4f80717d2c"
    ],
    "jcr:created": "Thu Dec 01 2016 16:15:12 GMT-0500",
    "cq:lastReplicated": "Thu Dec 01 2016 16:15:12 GMT-0500",
    "cq:lastModified": "Thu Dec 01 2016 16:14:52 GMT-0500",
    "cq:distribute": true,
    "jcr:baseVersion": "7600b8a0-7b79-4670-a23b-3a4f80717d2c",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-doctypes:blog",
      "fireeye-blog-threat-research:threat-research\/threat-intelligence",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:0day-exploits",
      "fireeye-blog-authors:cap-dan-caselden",
      "fireeye-blog-authors:cap-erica-eng"
    ],
    "jcr:uuid": "58006703-2a88-4bf1-a48c-29e3745adcdc",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Jun 23 2015 09:21:00 GMT-0700",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "todd.jackson",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "grid_33_66_full_293c": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "lynn.thorne@fireeye.com",
        "jcr:lastModifiedBy": "matthew.sawicki@FireEye.com",
        "nested": "true",
        "jcr:created": "Mon Jun 22 2015 19:21:09 GMT-0400",
        "jcr:lastModified": "Tue Jun 23 2015 12:14:19 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-33-66-full"
      },
      "grid_100_full_630": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "matthew.sawicki@FireEye.com",
        "jcr:lastModifiedBy": "matthew.sawicki@FireEye.com",
        "jcr:created": "Tue Jun 23 2015 17:30:32 GMT-0400",
        "jcr:lastModified": "Tue Jun 23 2015 17:30:32 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-100-full"
      },
      "grid_60_40_full_f016": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "matthew.sawicki@FireEye.com",
        "jcr:lastModifiedBy": "todd.jackson",
        "nested": "true",
        "jcr:created": "Tue Jun 23 2015 17:27:45 GMT-0400",
        "jcr:lastModified": "Thu Dec 01 2016 16:14:52 GMT-0500",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-60-40-full",
        "gutterwidth": " g-tight"
      },
      "grid_100_full_fefe": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "matthew.sawicki@FireEye.com",
        "jcr:lastModifiedBy": "matthew.sawicki@FireEye.com",
        "jcr:created": "Tue Jun 23 2015 17:31:10 GMT-0400",
        "jcr:lastModified": "Tue Jun 23 2015 17:31:10 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-100-full"
      },
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
        "text": "\u003Cp\u003EAdobe has already released a patch for CVE-2015-3113 with an out-of-band security bulletin (\u003Ca href=\u0022https:\/\/helpx.adobe.com\/security\/products\/flash-player\/apsb15-14.html\u0022\u003Ehttps:\/\/helpx.adobe.com\/security\/products\/flash-player\/apsb15-14.html\u003C\/a\u003E). FireEye recommends that Adobe Flash Player users update to the latest version as soon as possible.\u003C\/p\u003E\n\u003Cp\u003EFireEye MVX detects this threat as a web infection, the IPS engine reports the attack as CVE-2015-3113, and the SHOTPUT backdoor is reported as Backdoor.APT.CookieCutter.\u003C\/p\u003E\n\u003Ch2\u003EAPT3\u003C\/h2\u003E\n\u003Cp\u003EThe China-based threat group FireEye tracks as APT3, aka UPS, is responsible for this exploit and the activity identified in our previous blog post, \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2014\/04\/new-zero-day-exploit-targeting-internet-explorer-versions-9-through-11-identified-in-targeted-attacks.html\u0022\u003EOperation Clandestine Fox\u003C\/a\u003E. This group is one of the more sophisticated threat groups that FireEye Threat Intelligence tracks, and they have a history of introducing new browser-based zero-day exploits (e.g., Internet Explorer, Firefox, and Adobe Flash Player). After successfully exploiting a target host, this group will quickly dump credentials, move laterally to additional hosts, and install custom backdoors. APT3\u2019s command and control (CnC) infrastructure is difficult to track, as there is little overlap across campaigns.\u003C\/p\u003E\n\u003Ch2\u003EActivity Overview\u003C\/h2\u003E\n\u003Cp\u003EIn the last several weeks, APT3 actors launched a large-scale phishing campaign against organizations in the following industries:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EAerospace and Defense\u003C\/li\u003E\n\u003Cli\u003EConstruction and Engineering\u003C\/li\u003E\n\u003Cli\u003EHigh Tech\u003C\/li\u003E\n\u003Cli\u003ETelecommunications\u003C\/li\u003E\n\u003Cli\u003ETransportation\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EUpon clicking the URLs provided in the phishing emails, targets were redirected to a compromised server hosting JavaScript profiling scripts. Once a target host was profiled, victims downloaded a malicious Adobe Flash Player SWF file and an FLV file, detailed below. This ultimately resulted in a custom backdoor known as SHOTPUT, detected by FireEye as \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2014\/11\/operation_doubletap.html\u0022\u003EBackdoor.APT.CookieCutter\u003C\/a\u003E, being delivered to the victim\u2019s system.\u003C\/p\u003E\n\u003Cp\u003EThe payload is obscured using xor encoding and appended to a valid GIF file.\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Bubbles\/red%20dots.jpg\u0022\u003E\u003C\/p\u003E\n\u003Ch2\u003EAttack Vector\u003C\/h2\u003E\n\u003Cp\u003EThe phishing emails used by APT3 during this campaign were extremely generic in nature, almost appearing to be spam. An example email body:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003ESave between $200-450 by purchasing an Apple Certified Refurbished iMac through this link. Refurbished iMacs come with the same 1-year extendable warranty as new iMacs. Supplies are limited, but update frequently.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003EDon\u0027t hesitate . . .\u0026gt;Go to Sale\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe string \u201c\u0026gt;Go to Sale\u201d was a link that used the following URL structure:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Ehxxp:\/\/\u0026lt;subdomain\u0026gt;.\u0026lt;legitdomain\u0026gt;.\u0026lt;TLD\u0026gt;\/\u0026lt;directory\u0026gt;\/\u0026lt;alphanumericID\u0026gt;.html\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch2\u003EExploit Details\u003C\/h2\u003E\n\u003Cp\u003EThe attack exploits an unpatched vulnerability in the way Adobe Flash Player parses Flash Video (FLV) files. The exploit uses common vector corruption techniques to bypass Address Space Layout Randomization (ASLR), and uses Return-Oriented Programming (ROP) to bypass Data Execution Prevention (DEP).\u0026nbsp; A neat trick to their ROP technique makes it simpler to exploit and will evade some ROP detection techniques.\u003C\/p\u003E\n\u003Cp\u003EShellcode is stored in the packed Adobe Flash Player exploit file alongside a key used for its decryption. The payload is xor encoded and hidden inside an image.\u003C\/p\u003E\n\u003Ch3\u003EExploit Packaging\u003C\/h3\u003E\n\u003Cp\u003EThe Adobe Flash Player exploit is packed with a simple RC4 packer. The RC4 key and ciphertext are BinaryData blobs that the packer uses to decrypt the layer 2 Adobe Flash Player file. Once decrypted, layer 2 is executed with loader.loadBytes.\u003C\/p\u003E\n\u003Ch3\u003EVector Corruption\u003C\/h3\u003E\n\u003Cp\u003ELayer 2 uses a classic Adobe Flash Player Vector corruption technique to develop its heap corruption vulnerability to a full relative read\/write available to ActionScript3. In this technique, the attacker sprays Adobe Flash Player Vectors to the heap, and triggers a write vulnerability to change the size of one of the vectors. The attacker can then perform subsequent reads and writes to memory outside the intended boundaries of the corrupted Vector object from AS3. For more details on this technique, see \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2015\/03\/flash_in_2015.html\u0022\u003EFlash in 2015\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EOnce the attacker has limited read\/write access to memory, they choose to corrupt a second Vector to increase their access to a range of 0x3fffffff bytes. This second Vector is used for the remainder of the exploit.\u003C\/p\u003E\n\u003Ch3\u003EReturn-Oriented Programming\u003C\/h3\u003E\n\u003Cp\u003EThe attackers use a ROP chain to call kernel32!VirtualAlloc to mark their shellcode as executable before jumping to their shellcode.\u003C\/p\u003E\n\u003Cp\u003EInstead of writing their ROP chain to the heap along with their shellcode and payload, they used a different technique. Usually, exploit developers will corrupt a built-in Adobe Flash Player object such as a Sound object. Instead, the attackers chose to define their own class in AS3 with a function that takes a lot of arguments:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eclass CustomClass {\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u0026nbsp; public function victimFunction(arg1:uint, arg2:uint, \u2026, arg80:uint):uint\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThen, the attackers can simply overwrite the function pointer with a gadget that adds to the stack pointer and returns to pivot to ROP. They have no need to identify the absolute address of the ROP chain and preserve it in a register for a typical xchg reg32, esp pivot. Additionally, storing the ROP chain on the stack will evade ROP detection mechanisms designed around detecting when the stack pointer points outside of a thread\u2019s stack region.\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Ethis.customObj.victimFunction(\u003Cbr\u003E\n 6f73b68b, \/\/ ret; (ROPsled)\u003Cbr\u003E\n \u2026,\u003Cbr\u003E\n 6f73b68a, \/\/pop eax\u003Cbr\u003E\n 1f140100,\u003Cbr\u003E\n 6fd36da1, \/\/call Kernel32!VirtualAlloc(0x1f140000, 0x10000, 0x1000, 0x40)\u003Cbr\u003E\n 1f140000, \/\/ Address\u003Cbr\u003E\n 00010000, \/\/ Size\u003Cbr\u003E\n 00001000, \/\/ Type\u003Cbr\u003E\n 00000040, \/\/ Protection = RWX\u003Cbr\u003E\n 6f73b68b*9 \/\/ ret (ROPsled)\u003Cbr\u003E\n 6fd36da7*2 \/\/ ret\u003Cbr\u003E\n 6f73aff0 pop ecx\u003Cbr\u003E\n 6fd36da7\u003Cbr\u003E\n 6fd36da7 jmp [eax]\u003Cbr\u003E\n \u2026\u003Cbr\u003E\n )\u003Cbr\u003E\n this.customObj.victimFunction\u003C\/span\u003E pointer modified to:\u003Cspan class=\u0022code\u0022\u003E\u003Cbr\u003E\n 00000000`6de533dc 5e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; pop\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; rsi\u003Cbr\u003E\n 00000000`6de533dd 83c448\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; add\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; esp,48h\u003Cbr\u003E\n 00000000`6de533e0 c3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ret\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ELastly, the ROP chain has a ROPsled following the call to VirtualAlloc. This could just be an artifact of development, or it could be designed to bypass detection mechanisms that test for valid return addresses up to a limited depth at calls to VirtualAlloc.\u003C\/p\u003E\n\u003Ch3\u003EFull Exploit Flow\u003C\/h3\u003E\n\u003Cp\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Create a new Video object\u003C\/p\u003E\n\u003Cp\u003E2.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Fetch the payload\u003C\/p\u003E\n\u003Cp\u003E3.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Attach the video to a new NetStream\u003C\/p\u003E\n\u003Cp\u003E4.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Spray the heap with Adobe Flash Player Vectors\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Create a Vector containing 98688 Vectors containing 1022 uints\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Set the first two dwords in each Vector\u0026lt;uint\u0026gt; to 0x41414141, 0x42424242\u003C\/p\u003E\n\u003Cp\u003E5.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Create holes for the controlled FLV object\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Free approximately every 3\u003Csup\u003Erd\u003C\/sup\u003E Vector in the spray\u003C\/p\u003E\n\u003Cp\u003E6.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Spray custom class objects for future control transfer\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Define a new class CustomClass\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; i.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Define a function victimFunction with lots of arguments\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Create a Vector of 0x100 Vectors of 1007 references to an CustomClass instance\u003C\/p\u003E\n\u003Cp\u003E7.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Fetch and play the FLV exploit\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The FLV file will allocate an attacker controlled object in one of the holes from step 5\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The attacker controlled object will overwrite the length field of an adjacent vector\u003C\/p\u003E\n\u003Cp\u003E8.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Re-fill holes from step 5 with Vectors as in step 4\u003C\/p\u003E\n\u003Cp\u003E9.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Find the corrupted vector\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Search through Vectors from step 4\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Check the length of each Vector to find one that is abnormally large\u003C\/p\u003E\n\u003Cp\u003E10.\u0026nbsp; Corrupt a second Vector (Vector2)\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Using the corrupted Vector from step 9 to read\/write relative memory addresses\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; i.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Search memory for an adjacent vector\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ii.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Overwrite the length field with 0x3fffffff\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; iii.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Verify that a corrupted vector with length 0x3fffffff now exists in the spray\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; 1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If not, undo corruption and attempt to corrupt the next vector\u003C\/p\u003E\n\u003Cp\u003E11.\u0026nbsp; Decrypt shellcode and store it and the payload on the heap\u003C\/p\u003E\n\u003Cp\u003E12.\u0026nbsp; Overwrite the CustomClass.victimFunction function pointer\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Find the sprayed CustomClass object instance references from step 6\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The new function is a form of \u201cpivot\u201d that transfers control to the attacker\u003C\/p\u003E\n\u003Cp\u003E13.\u0026nbsp; Build ROP chain on the stack and call it\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Find ROP gadgets in memory using Vector2\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; i.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Including a call to kernel32!VirtualAlloc\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Call the corrupted CustomClass.victimFunction from step 6.a.i\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; i.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Arguments to the function are the gadgets of the ROP chain\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ii.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; They are conveniently pushed onto the stack\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; iii.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Corrupted vtable from step 12 calls a pivot\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; 1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The \u201cpivot\u201d just adds to to the stack pointer and returns because the ROP chain is on\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; the stack\u003C\/p\u003E\n\u003Cp\u003E14.\u0026nbsp; ROP chain calls shellcode\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Call kernel32!VirtualAlloc\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; jmp to shellcode\u003C\/p\u003E\n\u003Cp\u003E15.\u0026nbsp; Shellcode calls payload\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Shellcode searches memory for the payload, which is stored inside an image\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Shellcode decodes the payload by xoring each byte (that is not 0 or 0x17) with 0x17\u003C\/p\u003E\n\u003Ch2\u003EConclusion\u003C\/h2\u003E\n\u003Cp\u003EOnce APT3 has access to a target network, they work quickly and they are extremely proficient at enumerating and moving laterally to maintain their access. Additionally, this group uses zero-day exploits, continually updated custom backdoors, and throwaway CnC infrastructure, making it difficult to track them across campaigns.\u003C\/p\u003E\n\u003Ch2\u003EAcknowledgements\u003C\/h2\u003E\n\u003Cp\u003EThank you to the following contributors to this blog!\u003C\/p\u003E\n\u003Cp\u003E\u00b7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Joseph Obed, Ben Withnell, Kevin Zuk, Genwei Jiang, and Corbin Souffrant of FireEye\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue Jun 23 2015 16:13:06 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
      "text": "\u003Cp\u003EA new Adobe Flash zero-day uses phishing emails to access and move laterally through a network.\u003Cbr\u003E\n\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Jun 22 2015 16:04:19 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
