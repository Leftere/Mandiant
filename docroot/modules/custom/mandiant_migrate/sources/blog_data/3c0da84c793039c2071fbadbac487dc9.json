{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Thu Jun 23 2016 09:41:55 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Automatically Extracting Obfuscated Strings from Malware using the FireEye Labs Obfuscated String Solver (FLOSS)",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "8f5a1ac0-8c01-4c0f-8944-36733488dd4f",
    "author": "Moritz Raabe",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "b222902e-10a6-44fd-8b44-14456070f4b4"
    ],
    "jcr:created": "Wed May 08 2019 18:20:03 GMT-0400",
    "cq:lastReplicated": "Wed May 08 2019 18:20:01 GMT-0400",
    "cq:lastModified": "Wed May 08 2019 18:19:52 GMT-0400",
    "cq:distribute": true,
    "jcr:description": "The FireEye FLARE team\u2019s newest contribution to the malware analysis community, FLOSS, is an open-source tool to automatically detect, extract, and decode obfuscated strings in Windows Portable Executable files. FLOSS helps fight against malware authors who commonly obfuscate strings in their programs to deter static and dynamic analysis, and can extract strings that are deobfuscated by decoding routines, while recovering stackstrings and obtaining all static strings. ",
    "jcr:baseVersion": "b222902e-10a6-44fd-8b44-14456070f4b4",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-tags:obfuscation",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-authors:moritz-raabe",
      "fireeye-blog-tags:open-source",
      "fireeye-blog-tags:open-source-tools",
      "fireeye-doctypes:blog",
      "fireeye-blog-threat-research:threat-research\/malware-research",
      "fireeye-blog-authors:cap-william-ballenthin",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "0eca379c-6ad2-499e-a7f4-13e42ac915ff",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Jun 23 2016 09:00:00 GMT-0400",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
        "text": "\u003Ch4\u003EIntroduction and Motivation\u003C\/h4\u003E\n\u003Cp\u003EHave you ever run \u003Cspan class=\u0022code\u0022\u003Estrings.exe\u003C\/span\u003E on a malware executable and its output provided you with IP addresses, file names, registry keys, and other indicators of compromise (IOCs)? Great! No need to run further analysis or hire expensive experts to determine if a file is malicious, its intended usage, and how to find other instances. Unfortunately, malware authors have caught on and are trying to deter your analysis. Although these authors try to protect their executables, we will teach you to use the FireEye Labs Obfuscated Strings Solver (FLOSS) to recover sensitive strings from malware executables.\u003C\/p\u003E\n\u003Cp\u003EOne popular approach malware authors use to protect their software is packing. Packing a program transforms the executable into a compressed and\/or obfuscated form. Packed malware can impede your analysis since it requires you to restore the unpacked data first. On the other hand, since packing is unusual, simply flagging on packed files is a reliable way to identify suspicious executables. Packed files can be easily detected via features such as: a small number of imported functions, a high entropy level, or suspicious section header characteristics. So, while packing hides the strings, it makes a malicious binary stick out like a sore thumb.\u003C\/p\u003E\n\u003Cp\u003EInstead, attackers often encode sensitive strings individually without packing the entire binary file. This means that during runtime, the program decodes the strings prior to use. For example, the program may decode the strings unconditionally during the initialization routine or decode the strings immediately before their use. Either way, the strings are not visible in the on-disk executable and the file is not trivial to detect. Listing 1 shows pseudo-code of a simple decoding function that decodes obfuscated strings by applying a single-byte XOR with a key of 0x15 to each character.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLOSS%20Moritz\/List1.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EListing 1: Simple string obfuscation example using the XOR operation\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EManually constructing strings is another technique malware authors often use to hide strings. Instead of storing a consecutive sequence of bytes to form a string, a collection of instructions re-creates the strings byte-by-byte. Since strings.exe looks for a sequence of printable characters, it is unable to identify the human readable string because the characters are interspersed with the opcode data. Hiding strings such as file system paths and domain names makes it harder for forensic analysts to decide if a file is malicious or not.\u003C\/p\u003E\n\u003Cp\u003EFigure 1 shows a screenshot of IDA Pro illustrating the string \u201cgoodbye world\u201d being manually constructed on the stack. Although we call this technique \u201cstackstrings\u201d it can just as easily be applied to global memory or the heap.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLOSS%20Moritz\/Fig1.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Manually constructed string on the stack\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ECurrent Methods of Combatting Obfuscated Strings\u003Cbr\u003E\n\u003C\/h4\u003E\n\u003Cp\u003EReverse engineers have various possibilities when tasked with decoding obfuscated strings in malware. Two traditional techniques are to use a debugger to recover strings or to reimplement the decoding function. Both approaches require analysts to manually identify decoding functions first.\u003C\/p\u003E\n\u003Ch5\u003EUsing a Debugger\u003C\/h5\u003E\n\u003Cp\u003EAfter a decoding routine has been identified in a disassembler such as IDA Pro, analysts can use a debugger to execute every code path that yields a decoded string. They can do this by setting breakpoints and manipulating the CPU flags at important spots in the program. When the malware decodes a string, analysts dump the region of memory that contains this data. This technique uses the malware\u2019s string decoding implementation, which must decode strings properly if the malware works correctly. However, the debugging steps can be a daunting task to perform for every relevant code path. Complex initialization of decoding routines and inlined decoding functions further complicate this technique.\u003C\/p\u003E\n\u003Cp\u003EOur \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-dbg\/\u0022\u003Eflare-dbg project\u003C\/a\u003E can help to automate string decoding using WinDbg, as described in the blog post, \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2015\/12\/flare_script_series.html\u0022 target=\u0022_blank\u0022\u003EFLARE Script Series: Automating Obfuscating String Decoding\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch5\u003EReimplementing Decoding Routines\u003Cbr\u003E\n\u003C\/h5\u003E\n\u003Cp\u003EAn alternative static analysis technique is to reimplement the decoding routine in a scripting language, such as Python, based on the disassembly of the routine. This allows analysts to flexibly apply a decoding scheme to all obfuscated strings in a binary at their leisure. However, porting code is a tedious and error prone process. Additionally, it can be a challenge to extract the obfuscated data. For example, if the obfuscated data is manipulated before the decoding function initialization then it may be difficult to manually recreate the transformations.\u003C\/p\u003E\n\u003Ch5\u003ERecovering Stackstrings\u003C\/h5\u003E\n\u003Cp\u003EAlthough not challenging, manually recovering stackstrings in IDA Pro can be a cumbersome process. The FLARE team provides an \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2014\/08\/flare-ida-pro-script-series-automatic-recovery-of-constructed-strings-in-malware.html\u0022\u003EIDA Pro plugin\u003C\/a\u003E that automates the recovery of stackstrings.\u003C\/p\u003E\n\u003Cp\u003EDepending on the actual obfuscation implementation, each recovery method can take a considerable amount of time. Unfortunately, malware authors can drastically transform an encoding routine with trivial changes to the source code. Therefore, analysts have to repeat these procedures manually for every single malware sample with obfuscated strings. An automated system that extracts these strings would save dozens of hours per month for a reverse engineering team such as FLARE.\u003C\/p\u003E\n\u003Ch4\u003EIntroducting FLOSS\u003C\/h4\u003E\n\u003Cp\u003EThe FireEye Labs Obfuscated String Solver (FLOSS) is an open source tool that is released under Apache License 2.0. It automatically detects, extracts, and decodes obfuscated strings in Windows Portable Executable files. FLOSS is extremely easy to use and works against a large corpus of malware. You run it just as you did the \u003Cspan class=\u0022code\u0022\u003Estrings.exe\u003C\/span\u003E tool. Malware analysts, forensic investigators, and incident responders who already look for strings in a binary will benefit from FLOSS.\u003C\/p\u003E\n\u003Cp\u003EFigure 2 shows an example output of FLOSS run on a malware with obfuscated strings. For this executable the strings output shown in Figure 3 does not yield any useful information.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLOSS%20Moritz\/Fig2.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: FLOSS example output that provides valuable information to analysts\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLOSS%20Moritz\/Fig3.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Strings tool output that shows no indicators for this executable\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFor many obfuscated samples, FLOSS\u2019s output offers valuable insight into the program\u2019s functionality, whereas the \u003Cspan class=\u0022code\u0022\u003Estrings.exe\u003C\/span\u003E tool provides no useful information. FLOSS extracts higher value strings since strings that are obfuscated typically contain the most sensitive configuration resources, including command and control server addresses, names of dynamically resolved imports, suspicious file paths, and other indicators of compromise (IOCs).\u003C\/p\u003E\n\u003Cp\u003EIn fact, FLOSS entirely eliminates the need for\u003Cspan class=\u0022code\u0022\u003E strings.exe\u003C\/span\u003E as FLOSS can also extract all static ASCII and UTF-16LE strings from any file. And as we have learned, FLOSS also provides deobfuscated strings and recovered stackstrings from PE files. This means that there is no real reason to run \u003Cspan class=\u0022code\u0022\u003Estrings.exe\u003C\/span\u003E anymore.\u003C\/p\u003E\n\u003Ch5\u003EHow FLOSS Works\u003C\/h5\u003E\n\u003Cp\u003EFLOSS combines advanced static analysis techniques to automatically detect decoding functions and recover obfuscated strings. Here is the algorithm in detail:\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Analyze program to identify data, code, functions, basic blocks, cross-references, etc.\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EFLOSS uses \u003Ca href=\u0022https:\/\/github.com\/vivisect\/vivisect\u0022\u003Evivisect\u003C\/a\u003E to disassemble and analyze the control flow of a program. Vivisect is a program analysis library written in pure Python. You can think of it like an open-source IDA Pro instance.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E2.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Use heuristics to find potential decoding routines.\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EFLOSS uses plug-ins for defining heuristics. Each heuristic scores the likelihood that a function is a decoding routine. This approach allows us (and you) to easily extend FLOSS\u2019s identification capabilities. The most effective heuristics, which happen to be very simple, to date are:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EFunction contains non-zeroing XOR operation\u003C\/li\u003E\n\u003Cli\u003EThere are many code cross-references to a function\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003E\u003Cb\u003E3.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Brute-force emulate all code paths among basic blocks and functions.\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EFLOSS uses vivisect\u2019s CPU and memory modules to emulate x86 instructions. Each executable is emulated in the Python runtime. The goal of this step is to obtain the arguments that get passed into a decoding function. FLOSS emulates all code paths in the executable in a single-pass, brute-force manner.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E4.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Snapshot emulator state (registers and memory) at appropriate points.\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EWhenever FLOSS detects a call to a possible decoding function, it takes a snapshot of the memory and register state. This trick allows FLOSS to collect all relevant function input without knowing any details about the function, e.g., calling convention or the number of arguments.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E5.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Emulate decoder functions using emulator state snapshots.\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EBefore FLOSS performs emulation of possible decoding functions, it \u201creverts\u201d to each snapshot it created in the previous step. FLOSS emulates each decoding routine with all collected emulator state snapshots. The emulation stops once the routine returns, or until 10,000 instructions have been emulated, which avoids infinite loops during program emulation. This allows FLOSS to identify changes to the CPU and memory states introduced by the decoding routines.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E6.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Compare memory state from before and after function emulation.\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EFLOSS compares the emulator memory segments before and after emulating a decoding function. This results in a list of byte sequences with differing content. If a decoding routine exposed some data, the deobfuscated data must be found within these byte sequences.\u003C\/p\u003E\n\u003Cp\u003E\u003Cb\u003E7.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Extract human-readable strings from memory state difference.\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EFor each differing byte sequence, FLOSS extracts all human readable strings in ASCII and UTF-16LE format. This is what it displays to the user.\u003C\/p\u003E\n\u003Ch5\u003EInstallation\u003C\/h5\u003E\n\u003Cp\u003EWe provide standalone executable files of FLOSS for Windows and Linux at \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-floss\/releases\u0022\u003Ehttps:\/\/github.com\/fireeye\/flare-floss\/releases\u003C\/a\u003E. The tool is written in pure Python and the source code is available on GitHub at \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-floss\u0022\u003Ehttps:\/\/github.com\/fireeye\/flare-floss\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EYou can also install FLOSS via the standard Python package installer \u003Cspan class=\u0022code\u0022\u003Epip\u003C\/span\u003E. This will add an executable \u003Cspan class=\u0022code\u0022\u003Efloss.exe\u003C\/span\u003E (on Windows) or \u003Cspan class=\u0022code\u0022\u003Efloss\u003C\/span\u003E (on Linux) to your $PATH. As a third option, you can install FLOSS from source. Please see the GitHub page for the most up to date \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-floss\/blob\/master\/doc\/installation.md\u0022\u003Einstallation instructions\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch5\u003EUsage\u003C\/h5\u003E\n\u003Cp\u003ETo extract static ASCII and UTF-16LE strings, obfuscated strings, and stackstrings from an executable file, run:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe \/path\/to\/binary\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIf you want to exclude static strings from FLOSS\u2019s output provide the\u003Cspan class=\u0022code\u0022\u003E \u2013-no-static-strings\u003C\/span\u003E switch:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe \u2013-no-static-strings \/path\/to\/binary\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EYou can suppress FLOSS\u2019s headers and formatting output with the\u003Cspan class=\u0022code\u0022\u003E -q \u003C\/span\u003Eswitch. This mode is appropriate for piping to grep or other tools:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe \u2013q \/path\/to\/binary\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ETo display only strings with a minimum length use the \u003Cspan class=\u0022code\u0022\u003E-n\u003C\/span\u003E switch. The default minimum string length is four:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe \u2013n 8 \/path\/to\/binary\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIf you know a decoding function offset (or have a list of comma-separated function offsets), you can instruct FLOSS to only analyze the provided functions using the\u003Cspan class=\u0022code\u0022\u003E -f \u003C\/span\u003Eswitch:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe \/path\/to\/binary -f 0xF005BA11\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe \/path\/to\/binary -f 0xF005BA11,0xF00B005E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EUse the \u003Cspan class=\u0022code\u0022\u003E-i \u003C\/span\u003Eswitch to create an IDAPython script that annotates an IDA Pro IDB database with the decoded strings:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe -i SCRIPTOUTPUTPATH \/path\/to\/binary\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFLOSS can also create radare2 scripts via the\u003Cspan class=\u0022code\u0022\u003E \u2013r \u003C\/span\u003Eswitch:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe -r SCRIPTOUTPUTPATH \/path\/to\/binary\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003E-h\u003C\/span\u003E switch displays the entire help for all of FLOSS\u2019s functionality:\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ floss.exe -h\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ESummary\u003C\/h4\u003E\n\u003Cp\u003EIn this blog post we have introduced the FLARE team\u2019s newest contribution to the malware analysis community. FLOSS is an open-source tool to automatically detect, extract, and decode obfuscated strings in Windows Portable Executable files. The community needs this type of tool to fight back against malware authors who commonly obfuscate strings in their programs to deter static and dynamic analysis. In addition to extracting strings that are deobfuscated by decoding routines, FLOSS can recover stackstrings and obtain all static strings.\u003C\/p\u003E\n\u003Cp\u003ETry out FLOSS in your next malware analysis. The tool is extremely easy to use and can provide valuable information for forensic analysts, incident responders, and reverse engineers. If you enjoy the tool, run into issues using it, or have any other comments, please contact us via the projects GitHub page at \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-floss\/\u0022\u003Ehttps:\/\/github.com\/fireeye\/flare-floss\/.\u003C\/a\u003E\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Jun 23 2016 09:09:04 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
      "text": "\u003Cp\u003EThe FireEye FLARE team\u2019s newest contribution to the malware analysis community, FLOSS, is an open-source tool to automatically detect, extract, and decode obfuscated strings in Windows Portable Executable files. FLOSS helps fight against malware authors who commonly obfuscate strings in their programs to deter static and dynamic analysis, and can extract strings that are deobfuscated by decoding routines, while recovering stackstrings and obtaining all static strings. \u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Jun 23 2016 09:02:48 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed May 08 2019 18:19:52 GMT-0400",
      "imageRotate": "0"
    }
  }
}
