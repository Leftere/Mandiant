{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Thu Sep 24 2020 15:10:07 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Fuzzing Image Parsing in Windows, Part One: Color Profiles",
    "jcr:versionHistory": "799749b3-91b8-4e2c-8e0e-851612b15831",
    "author": "Dhanesh Kizhakkinan",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "18b58092-e86f-48b8-a9ac-2518faf236cb"
    ],
    "jcr:created": "Thu Sep 24 2020 15:10:07 GMT+0000",
    "cq:lastModified": "Wed Sep 23 2020 20:24:46 GMT+0000",
    "jcr:baseVersion": "18b58092-e86f-48b8-a9ac-2518faf236cb",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:dhanesh-kizhakkinan",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:vulnerabilities",
      "fireeye-blog-tags:windows",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "12e7a9f6-d19e-4c86-b7d3-1bf4ee795f05",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Sep 24 2020 11:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EImage parsing and rendering are basic features of any modern operating system (OS).\u0026nbsp;Image parsing is an easily accessible attack surface, and a vulnerability that may lead to remote code execution or information disclosure in such a feature is valuable to attackers. In this multi-part blog series, I am reviewing Windows OS\u2019\u0026nbsp;built-in\u0026nbsp;image parsers and related file formats: specifically looking at creating a harness, hunting for corpus and fuzzing to find vulnerabilities. In part one of this series I am looking at color profiles\u2014not an image format\u0026nbsp;itself, but something which is regularly embedded\u0026nbsp;within\u0026nbsp;images.\u0026nbsp;\u003C\/p\u003E\n\u003Ch4\u003EWhat is an\u0026nbsp;ICC Color Profile?\u003C\/h4\u003E\n\u003Cp\u003EWikipedia provides a more-than-adequate \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/en.wikipedia.org\/wiki\/ICC_profile\u0022\u003Edescription of ICC color profiles\u003C\/a\u003E: \u003Ci\u003E\u0026quot;In color management, an ICC profile is a set of data that characterizes a color input or output device, or a color space, according to standards promulgated by the International Color Consortium (ICC). Profiles describe the color attributes of a particular device or viewing requirement by defining a mapping between the device source or target color space and a profile connection space (PCS). This PCS is either CIELAB (L*a*b*) or CIEXYZ. Mappings may be specified using tables, to which interpolation is applied, or through a series of parameters for transformations.\u003C\/i\u003E\u201d\u003C\/p\u003E\n\u003Cp\u003EIn simpler terms, an ICC color profile is a binary file that gets embedded into images and parsed whenever ICC supported software processes the images.\u0026nbsp;\u003C\/p\u003E\n\u003Ch4\u003ESpecification\u003C\/h4\u003E\n\u003Cp\u003EThe \u003Ca adhocenable=\u0022false\u0022 href=\u0022http:\/\/www.color.org\/specification\/ICC1v43_2010-12.pdf \u0022\u003EICC specification\u003C\/a\u003E is around 100 pages and\u0026nbsp;should be easy to skim through. Reading through specifications gives\u0026nbsp;a better understanding of the file format, different types of color profiles, and math behind the color transformation. Furthermore, understanding of its file format internals provides us with information that can be used to optimize fuzzing, select\u0026nbsp;a\u0026nbsp;good corpus, and prepare\u0026nbsp;fuzzing dictionaries.\u003C\/p\u003E\n\u003Ch4\u003EHistory of Color Management in Windows\u003C\/h4\u003E\n\u003Cp\u003EWindows started to ship Image Color Management (ICM) version 1.0\u0026nbsp;on\u0026nbsp;Windows 95, and version 2.0 beginning with Windows 98 onwards. A major overhaul to Windows Color System (WCS) 1.0 happened in Windows Vista onwards. While ICC color profiles are binary files, WCS color profiles use XML as its file format. In this blog post,\u0026nbsp;I\u0026nbsp;am\u0026nbsp;going to concentrate on ICC color profiles.\u003C\/p\u003E\n\u003Cp\u003EMicrosoft has a list of \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/previous-versions\/windows\/desktop\/wcs\/alphabetical-list-of-all-wcs-functions \u0022\u003Esupported Windows APIs\u003C\/a\u003E. Looking into some of the obviously named APIs, such as\u0026nbsp;\u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/previous-versions\/windows\/desktop\/wcs\/opencolorprofile\u0022\u003EOpenColorProfile\u003C\/a\u003E,\u0026nbsp;we can\u0026nbsp;see that it is implemented in MSCMS.dll. This DLL is a generic entry point and supports loading of Microsoft\u2019s Color Management Module (CMM) and third-party CMMs\u0026nbsp;such as\u0026nbsp;Adobe\u2019s CMM. Microsoft\u2019s CMM\u2014the ICM\u2014can be found as ICM32.dll\u0026nbsp;in system32 directory.\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/image-fuzzing\/picture1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: ICM32\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWindows\u2019\u0026nbsp;CMM was written by a\u0026nbsp;third-party\u0026nbsp;during the Windows 95 era and\u0026nbsp;still ships more or less with the same code (with security fixes over the decades). Seeing such\u0026nbsp;an\u0026nbsp;old\u0026nbsp;module\u0026nbsp;gives me some hope of finding a new vulnerability. But\u0026nbsp;this is\u0026nbsp;also\u0026nbsp;a small module that may have gone through multiple rounds of review and fuzzing: both\u0026nbsp;by\u0026nbsp;internal\u0026nbsp;product security\u0026nbsp;teams and by external researchers, reducing my hopes to a certain degree.\u0026nbsp;Looking for any recent vulnerabilities in ICM32,\u0026nbsp;we can\u0026nbsp;see\u0026nbsp;multiple bugs from 2017-2018 by Project Zero and ZDI researchers, but then relative silence from 2019 onwards.\u003C\/p\u003E\n\u003Ch4\u003EMaking a Harness\u003C\/h4\u003E\n\u003Cp\u003EAlthough\u0026nbsp;there is\u0026nbsp;a list of ICM APIs in MSDN,\u0026nbsp;we need to find an API sequence used by\u0026nbsp;Windows\u0026nbsp;for\u0026nbsp;any ICC related operations. One of the ways to find\u0026nbsp;our API sequence is to search a disassembly of Windows DLLs and EXEs in hope to find the color profile APIs being used. Another approach is to find\u0026nbsp;a harness for open source Color Management Systems such as Little CMS (LCMS). Both of these end up pointing to very small set of APIs with functionality to\u0026nbsp;open color profiles and\u0026nbsp;create color\u0026nbsp;transformations.\u003C\/p\u003E\n\u003Cp\u003EGiven this information, a\u0026nbsp;simple\u0026nbsp;initial harness\u0026nbsp;was written:\u0026nbsp;\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr\u003E\n #include \u0026lt;Windows.h\u0026gt;\u003Cbr\u003E\n #include \u0026lt;Icm.h\u0026gt;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E#pragma comment(lib, \u0026quot;mscms.lib\u0026quot;)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eint main(int argc, char** argv)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; char dstProfilePath[] = \u0026quot;sRGB Color Space Profile.icm\u0026quot;;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; tagPROFILE destinationProfile;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; HPROFILE\u0026nbsp;\u0026nbsp; hDstProfile = nullptr;\u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; destinationProfile.dwType = PROFILE_FILENAME;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; destinationProfile.pProfileData = dstProfilePath;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; destinationProfile.cbDataSize = (strlen(dstProfilePath) + 1);\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; hDstProfile = OpenColorProfileA(\u0026amp;destinationProfile, PROFILE_READ,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; FILE_SHARE_READ, OPEN_EXISTING);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;if (nullptr == hDstProfile)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;return -1;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;}\u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; tagPROFILE sourceProfile;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; HPROFILE\u0026nbsp;\u0026nbsp; hSrcProfile = nullptr;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; HTRANSFORM hColorTransform = nullptr;\u0026nbsp; \u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; DWORD dwIntent[] = { INTENT_PERCEPTUAL, INTENT_PERCEPTUAL };\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; HPROFILE hProfileList[2];\u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; sourceProfile.dwType = PROFILE_FILENAME;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; sourceProfile.pProfileData = argv[1];\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; sourceProfile.cbDataSize = (strlen(argv[1]) + 1);\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; hSrcProfile = OpenColorProfileA(\u0026amp;sourceProfile, PROFILE_READ,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; FILE_SHARE_READ, OPEN_EXISTING);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;if (nullptr == hSrcProfile)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;return -1;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;}\u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; hProfileList[0] = hSrcProfile;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; hProfileList[1] = hDstProfile;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; hColorTransform = CreateMultiProfileTransform(\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; hProfileList,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; 2,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; dwIntent,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; 2,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; USE_RELATIVE_COLORIMETRIC | BEST_MODE,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; INDEX_DONT_CARE\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;);\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; if (nullptr == hColorTransform)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;return -1;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;}\u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; DeleteColorTransform(hColorTransform);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; CloseColorProfile(hSrcProfile);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; CloseColorProfile(hDstProfile);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;return 0;\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EListing 1: Harness\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EHunting for Corpus\u0026nbsp;and Dictionary\u003C\/h4\u003E\n\u003Cp\u003ESites \u003Ca adhocenable=\u0022false\u0022 href=\u0022http:\/\/www.color.org\/profiles2.xalter\u0022\u003Eoffering multiple color profiles\u003C\/a\u003E can be found all over the internet. One of the other main source of color profile is images; many image files contain a color profile but require some programming\/tools to dump their color profile to stand-alone files.\u003C\/p\u003E\n\u003Cp\u003ESimply skimming through the specification, we can also make sure the corpus contains at least one sample from all\u0026nbsp;of\u0026nbsp;the seven different color profiles.\u0026nbsp;This along with the code coverage information can\u0026nbsp;be used to\u0026nbsp;prepare\u0026nbsp;the first set of\u0026nbsp;corpuses\u0026nbsp;for fuzzing.\u003C\/p\u003E\n\u003Cp\u003EA dictionary, which helps the\u0026nbsp;fuzzer\u0026nbsp;to find additional code paths, can be prepared by combing through specifications and creating a list of unique tag names and values. One can also find dictionaries from open source fuzzing attempts on LCMS, etc.\u003C\/p\u003E\n\u003Ch4\u003EFuzzing\u003C\/h4\u003E\n\u003Cp\u003EI used a\u0026nbsp;16-core\u0026nbsp;machine to fuzz the harness with my first set of\u0026nbsp;corpuses. Code coverage information from MSCMS.dll and ICM32.dll was used as feedback for my\u0026nbsp;fuzzer. Crashes started to appear within a couple of days.\u003C\/p\u003E\n\u003Ch4\u003ECVE-2020-1117 \u2014 Heap Overflow in InitNamedColorProfileData\u003C\/h4\u003E\n\u003Cp\u003EThe following crash happens in \u003Cspan class=\u0022code\u0022\u003Eicm32!SwapShortOffset\u003C\/span\u003E while trying to read out of bounds:\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; r\u003Cbr\u003E\n rax=0000023690497000 rbx=0000000000000000 rcx=00000000000000ff\u003Cbr\u003E\n rdx=000000000000ffff rsi=0000023690496f00 rdi=0000023690496fee\u003Cbr\u003E\n rip=00007ffa46bf3790 rsp=000000c2a56ff5a8 rbp=0000000000000001\u003Cbr\u003E\n \u0026nbsp;r8=0000000000000014\u0026nbsp; r9=0000023690497002 r10=0000000000000014\u003Cbr\u003E\n r11=0000000000000014 r12=000000c2a56ff688 r13=0000023690492de0\u003Cbr\u003E\n r14=000000000000000a r15=000000004c616220\u003Cbr\u003E\n iopl=0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; nv up ei ng nz ac pe cy\u003Cbr\u003E\n cs=0033\u0026nbsp; ss=002b\u0026nbsp; ds=002b\u0026nbsp; es=002b\u0026nbsp; fs=0053\u0026nbsp; gs=002b\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; efl=00000293\u003Cbr\u003E\n icm32!SwapShortOffset+0x10:\u003Cbr\u003E\n 00007ffa`46bf3790 0fb610\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; movzx\u0026nbsp;\u0026nbsp; edx,byte ptr [rax] ds:00000236`90497000=??\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; !heap -p -a @rax\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; address 0000023690497000 found in\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; _DPH_HEAP_ROOT @ 23690411000\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; in busy allocation (\u0026nbsp; DPH_HEAP_BLOCK:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; UserAddr\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; UserSize -\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; VirtAddr\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; VirtSize)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;23690412b60:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 23690496f00\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 100 -\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 23690496000\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 2000\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa51644807 ntdll!RtlDebugAllocateHeap+0x000000000000003f\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa515f49d6 ntdll!RtlpAllocateHeap+0x0000000000077ae6\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa5157babb ntdll!RtlpAllocateHeapInternal+0x00000000000001cb\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa51479da0 msvcrt!malloc+0x0000000000000070\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf3805 icm32!SmartNewPtr+0x0000000000000011\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf37c8 icm32!SmartNewPtrClear+0x0000000000000014\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46c02d05 icm32!InitNamedColorProfileData+0x0000000000000085\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf6e39 icm32!Create_LH_ProfileSet+0x0000000000004e15\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf1973 icm32!PrepareCombiLUTs+0x0000000000000117\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf1814 icm32!CMMConcatInitPrivate+0x00000000000001f4\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf12a1 icm32!CWConcatColorWorld4MS+0x0000000000000075\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf11f4 icm32!CMCreateMultiProfileTransformInternal+0x00000000000000e8\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa46bf1039 icm32!CMCreateMultiProfileTransform+0x0000000000000029\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa48f16e6c mscms!CreateMultiProfileTransform+0x000000000000024c\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ff774651191 ldr+0x0000000000001191\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ff7746514b4 ldr+0x00000000000014b4\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa505a7bd4 KERNEL32!BaseThreadInitThunk+0x0000000000000014\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; 00007ffa515aced1 ntdll!RtlUserThreadStart+0x0000000000000021\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EListing 2: Crash info\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eicm32!SwapShortOffset\u003C\/span\u003E reads unsigned short values, \u003Cspan class=\u0022code\u0022\u003Ebswaps\u003C\/span\u003E them and stores at the same location, giving this crash both read and write primitives.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eunsigned __int16 *__fastcall SwapShortOffset(void *sourceBuff, unsigned int offset, unsigned int len)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; unsigned __int16 *endBuff; \/\/ r9\u003Cbr\u003E\n \u0026nbsp; unsigned __int16 *result; \/\/ rax\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp; endBuff = (sourceBuff + len);\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;for ( result = (sourceBuff + offset); result \u0026lt; endBuff; ++result )\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;*result = _byteswap_ushort(*result);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ read, bswap and write\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;return result;\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EListing 3: SwapShortOffset decompiled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe crashing function \u003Cspan class=\u0022code\u0022\u003Eicm32!SwapShortOffset\u003C\/span\u003E doesn\u2019t immediately point to the root cause of the bug. For that, we need to go one call up to \u003Cspan class=\u0022code\u0022\u003Eicm32!InitNamedColorProfileData\u003C\/span\u003E.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E__int64 __fastcall InitNamedColorProfileData(__int64 a1, void *hProfile, int a3, _DWORD *a4)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; errCode = CMGetPartialProfileElement(hProfile, \u0027ncl2\u0027, 0, pBuffSize, 0i64);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ getting size of ncl2 element\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;if ( errCode )\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;return errCode;\u003Cbr\u003E\n \u0026nbsp; minSize = pBuffSize[0];\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;if ( pBuffSize[0] \u0026lt; 0x55 )\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; minSize = 0x55;\u003Cbr\u003E\n \u0026nbsp; pBuffSize[0] = minSize;\u003Cbr\u003E\n \u0026nbsp; outBuff = SmartNewPtrClear(minSize, \u0026amp;errCode);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ allocating the buffer for ncl2\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; errCode = CMGetPartialProfileElement(hProfile, \u0027ncl2\u0027, 0, pBuffSize, outBuff);\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ reading ncl2 elements to buffer\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;if ( !errCode )\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; totalSizeToRead = count * totalDeviceCoord;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;if ( totalSizeToRead \u0026lt; 0xFFFFFFFFFFFFFFAEui64 \u0026amp;\u0026amp; totalSizeToRead + 0x51 \u0026lt;= pBuffSize[0] )\u0026nbsp; \/\/ totalSizeToRead + 0x51 \u0026lt;= element size?\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; currPtr = outBuff + 0x54;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ wrong offset of 0x54 is used\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;do\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;{\u0026nbsp; \u0026nbsp;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; SwapShortOffset((currPtr + 0x20), 0, 6u);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;--count;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;}while(count)\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EListing 4: InitNamedColorProfileData decompiled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EHere the code tries to read the \u2018ncl2\u2019 tag\/element and get the size of the stream from file. A buffer is allocated and the same call is made once again to read the complete content of the element \u2018ncl2\u2019. This buffer is parsed to find the count and number of device coordinates, and the values are verified by making sure read\/write ends up with in the buffer size. The vulnerability here is that the offset (0x51) used for verification is smaller than the offset (0x54) used to advance the buffer pointer. This error provides a 3 byte out of bound read and write.\u003C\/p\u003E\n\u003Cp\u003EThe fix for this was pretty straight forward\u2014change the verification offset to 0x54, which is how Microsoft fixed this bug.\u003C\/p\u003E\n\u003Ch4\u003EAdditional Vulnerabilities\u003C\/h4\u003E\n\u003Cp\u003EWhile looking at the previous vulnerability, one can see a pattern of using the \u003Cspan class=\u0022code\u0022\u003ECMGetPartialProfileElement\u003C\/span\u003E function for reading the size, allocation, and reading content. This sort of pattern can introduce bugs such as unconstrained size or integer overflow while adding an offset to the size, etc. I decided to pursue this function and see if such instances are present within ICM32.dll.\u003C\/p\u003E\n\u003Cp\u003EI found three instances which had an unchecked offset access: \u003Cspan class=\u0022code\u0022\u003ECMConvIndexToNameProfile\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003ECMConvNameToIndexProfile\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003ECMGetNamedProfileInfoProfile\u003C\/span\u003E. All of these functions are accessible through exported and documented MSCMS functions: \u003Cspan class=\u0022code\u0022\u003EConvertIndexToColorName\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003ECMConvertColorNameToIndex\u003C\/span\u003E, and \u003Cspan class=\u0022code\u0022\u003EGetNamedProfileInfo\u003C\/span\u003E respectively.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E__int64 __fastcall CMConvIndexToNameProfile(HPROFILE hProfile, __int64 a2, __int64 a3, unsigned int a4)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;...\u003Cbr\u003E\n \u0026nbsp; errCode = CMGetPartialProfileElement(hProfile, \u0027ncl2\u0027, 0, pBuffSize, 0i64);\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ read size\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;if ( !errCode )\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; allocBuff = SmartNewPtr(pBuffSize[0], \u0026amp;errCode);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;if ( !errCode )\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; errCode = CMGetPartialProfileElement(hProfile, \u0027ncl2\u0027, 0, pBuffSize, allocBuff);\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ read to buffer\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;if ( !errCode )\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;{\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; SwapLongOffset((allocBuff + 12), 0, 4u);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ 12 \u0026gt; *pBuffSize ?\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; SwapLongOffset((allocBuff + 16), v12, v13);\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EListing 5: CMConvIndexToNameProfile decompiled\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe bug discovered in \u003Cspan class=\u0022code\u0022\u003ECMConvIndexToNameProfile\u003C\/span\u003E and the other two functions is that there is no minimum length check for \u2018ncl2\u2019 elements and offsets 12 and 16 are directly accessed for both read and write\u2014providing out of bound read\/write to \u003Cspan class=\u0022code\u0022\u003EallocBuffer\u003C\/span\u003E, if the size of \u003Cspan class=\u0022code\u0022\u003EallocBuffer\u003C\/span\u003E is smaller than 12.\u003C\/p\u003E\n\u003Cp\u003EMicrosoft decided not to immediately fix these three vulnerabilities due to the fact that none of the Windows binaries use these functions. Independently, we did not find any Windows or third-party software using these APIs.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EIn part one of this blog series, we looked into color profiles, wrote a harness, hunted for corpus and successfully found multiple vulnerabilities. Stay tuned for part two, where we will be looking at a relatively less talked about vulnerability class: uninitialized memory.\u003C\/p\u003E\n",
        "jcr:lastModified": "Wed Sep 23 2020 18:43:03 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EImage parsing is a basic feature in operating systems, and a vulnerability could lead to remote code execution or information disclosure.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Sep 23 2020 18:33:22 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed Sep 23 2020 20:24:46 GMT+0000",
      "imageRotate": "0"
    }
  }
}
