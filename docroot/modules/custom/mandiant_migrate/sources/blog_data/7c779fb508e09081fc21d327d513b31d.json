{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Tue Jul 10 2018 11:59:02 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Malicious PowerShell Detection via Machine Learning",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "f1858255-ce35-43ba-a5d2-8120163e83c3",
    "author": "Victor Fang",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "81cc353a-7418-4886-9937-fd54f61366e5"
    ],
    "jcr:created": "Tue Jul 10 2018 12:09:30 GMT-0400",
    "cq:lastReplicated": "Tue Jul 10 2018 12:09:29 GMT-0400",
    "cq:lastModified": "Tue Jul 10 2018 12:09:20 GMT-0400",
    "jcr:baseVersion": "81cc353a-7418-4886-9937-fd54f61366e5",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:victor-fang",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:artificial-intelligence",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:machine-learning",
      "fireeye-blog-tags:powershell-attacks"
    ],
    "jcr:uuid": "9acfe1e8-b1c1-49bf-8294-144f95fa405e",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Jul 10 2018 12:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Ch4\u003EIntroduction\u003Cb\u003E\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003ECyber security vendors and researchers have reported for years how PowerShell is being used by cyber threat actors to \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/02\/spear_phishing_techn.html\u0022\u003Einstall backdoors\u003C\/a\u003E, \u003Ca href=\u0022https:\/\/www.csoonline.com\/article\/3227046\/malware\/what-is-a-fileless-attack-how-hackers-invade-systems-without-installing-software.html\u0022\u003Eexecute malicious code\u003C\/a\u003E, and otherwise achieve their objectives within enterprises. Security is a cat-and-mouse game between adversaries, researchers, and blue teams. The flexibility and capability of PowerShell has made conventional detection both challenging and critical. This blog post will illustrate how FireEye is leveraging artificial intelligence and machine learning to raise the bar for adversaries that use PowerShell.\u003C\/p\u003E\n\u003Cp\u003EIn this post you will learn:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EWhy malicious PowerShell can be challenging to detect with a traditional \u201csignature-based\u201d or \u201crule-based\u201d detection engine.\u003C\/li\u003E\n\u003Cli\u003EHow Natural Language Processing (NLP) can be applied to tackle this challenge.\u003C\/li\u003E\n\u003Cli\u003EHow our NLP model detects malicious PowerShell commands, even if obfuscated.\u003C\/li\u003E\n\u003Cli\u003EThe economics of increasing the cost for the adversaries to bypass security solutions, while potentially reducing the release time of security content for detection engines.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003EBackground\u003Cb\u003E\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003EPowerShell is one of the most \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/05\/cyber-espionage-apt32.html\u0022\u003Epopular tools\u003C\/a\u003E used to carry out attacks. Data gathered from FireEye Dynamic Threat Intelligence (DTI) Cloud shows malicious PowerShell attacks rising throughout 2017 (Figure 1).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/MachineLearningPowerShell\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: PowerShell attack statistics observed by FireEye DTI Cloud in 2017 \u2013 blue bars for the number of attacks detected, with the red curve for exponentially smoothed time series\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFireEye has been tracking the malicious use of PowerShell for years. In 2014, Mandiant incident response investigators published a Black Hat paper that covers the \u003Ca href=\u0022https:\/\/www.blackhat.com\/docs\/us-14\/materials\/us-14-Kazanciyan-Investigating-Powershell-Attacks-WP.pdf\u0022\u003Etactics, techniques and procedures (TTPs) used in PowerShell attacks\u003C\/a\u003E, as well as forensic artifacts on disk, in logs, and in memory produced from malicious use of PowerShell. In 2016, we published a blog post on how to \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2016\/02\/greater_visibilityt.html\u0022\u003Eimprove PowerShell logging\u003C\/a\u003E, which gives greater visibility into potential attacker activity. More recently, our in-depth report on \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/05\/cyber-espionage-apt32.html\u0022\u003EAPT32\u003C\/a\u003E highlighted this threat actor\u0026#39;s use of PowerShell for reconnaissance and lateral movement procedures, as illustrated in Figure 2.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/MachineLearningPowerShell\/Fig2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: APT32 attack lifecycle, showing PowerShell attacks found in the kill chain\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ELet\u2019s take a deep dive into an example of a malicious PowerShell command (Figure 3).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/MachineLearningPowerShell\/Fig3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Example of a malicious PowerShell command\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe following is a quick explanation of the \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/powershell\/scripting\/powershell-scripting?view=powershell-6\u0022\u003Earguments\u003C\/a\u003E:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003E-NoProfile \u2013 indicates that the current user\u2019s profile setup script should not be executed when the PowerShell engine starts.\u003C\/li\u003E\n\u003Cli\u003E-NonI \u2013 shorthand for -NonInteractive, meaning an interactive prompt to the user will not be presented.\u003C\/li\u003E\n\u003Cli\u003E-W Hidden \u2013 shorthand for \u201c-WindowStyle Hidden\u201d, which indicates that the PowerShell session window should be started in a hidden manner.\u003C\/li\u003E\n\u003Cli\u003E-Exec Bypass \u2013 shorthand for \u201c-ExecutionPolicy Bypass\u201d, which disables the execution policy for the current PowerShell session (default disallows execution). It should be noted that the Execution Policy isn\u2019t meant to be a security boundary.\u003C\/li\u003E\n\u003Cli\u003E-encodedcommand \u2013 indicates the following chunk of text is a base64 encoded command.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EWhat is hidden inside the Base64 decoded portion? Figure 4 shows the decoded command.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/MachineLearningPowerShell\/Fig4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: The decoded command for the aforementioned example\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EInterestingly, the decoded command unveils a stealthy fileless network access and remote content execution!\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003E\u003Ci\u003EIEX\u003C\/i\u003E is an alias for the \u003Ci\u003EInvoke-Expression\u003C\/i\u003E cmdlet that will execute the command provided on the local machine.\u003C\/li\u003E\n\u003Cli\u003E\u003Cb\u003EThe \u003Ci\u003Enew-object\u003C\/i\u003E\u003C\/b\u003E\u0026nbsp;cmdlet creates an instance of a .NET Framework or COM object, here a \u003Ci\u003Enet.webclient\u003C\/i\u003E object.\u003C\/li\u003E\n\u003Cli\u003EThe \u003Ci\u003Edownloadstring\u003C\/i\u003E will download the contents from \u0026lt;url\u0026gt; into a memory buffer (which in turn \u003Ci\u003EIEX\u003C\/i\u003E will execute).\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EIt\u2019s worth mentioning that a similar malicious PowerShell tactic was used in a recent cryptojacking attack exploiting \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2018\/02\/cve-2017-10271-used-to-deliver-cryptominers.html\u0022\u003ECVE-2017-10271 to deliver a cryptocurrency miner\u003C\/a\u003E. This attack involved the exploit being leveraged to deliver a PowerShell script, instead of downloading the executable directly. This PowerShell command is particularly stealthy because it leaves practically zero file artifacts on the host, making it hard for traditional antivirus to detect.\u003C\/p\u003E\n\u003Cp\u003EThere are several reasons why adversaries prefer PowerShell:\u003C\/p\u003E\n\u003Col style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EPowerShell has been widely adopted in Microsoft Windows as a powerful system administration scripting tool.\u003C\/li\u003E\n\u003Cli\u003EMost attacker logic can be written in PowerShell without the need to install malicious binaries. This enables a minimal footprint on the endpoint.\u003C\/li\u003E\n\u003Cli\u003EThe flexible PowerShell syntax imposes combinatorial complexity challenges to signature-based detection rules.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EAdditionally, from an economics perspective:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EOffensively, the cost for adversaries to modify PowerShell to bypass a signature-based rule is quite low, especially with \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/07\/revoke-obfuscation-powershell.html\u0022\u003Eopen source obfuscation tools\u003C\/a\u003E.\u003C\/li\u003E\n\u003Cli\u003EDefensively, updating handcrafted signature-based rules for new threats is time-consuming and limited to experts.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003ENext, we would like to share how we at FireEye are combining our PowerShell threat research with data science to combat this threat, thus raising the bar for adversaries.\u003C\/p\u003E\n\u003Ch4\u003ENatural Language Processing for Detecting Malicious PowerShell\u003Cb\u003E\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003ECan we use machine learning to predict if a PowerShell command is malicious?\u003C\/p\u003E\n\u003Cp\u003EOne advantage FireEye has is our repository of high quality PowerShell examples that we harvest from our global deployments of FireEye solutions and services. Working closely with our in-house PowerShell experts, we curated a large training set that was comprised of malicious commands, as well as benign commands found in enterprise networks.\u003C\/p\u003E\n\u003Cp\u003EAfter we reviewed the PowerShell corpus, we quickly realized this fit nicely into the NLP problem space. We have built an NLP model that interprets PowerShell command text, similar to how Amazon Alexa interprets your voice commands.\u003C\/p\u003E\n\u003Cp\u003EOne of the technical challenges we tackled was\u003Cb\u003E \u003C\/b\u003Esynonym, a problem studied in linguistics. For instance, \u201cNOL\u201d, \u201cNOLO\u201d, and \u201cNOLOGO\u201d have identical semantics in PowerShell syntax. In NLP, a \u003Ca href=\u0022https:\/\/en.wikipedia.org\/wiki\/Stemming\u0022\u003Estemming\u003C\/a\u003E algorithm will reduce the word to its original form, such as \u201cInnovating\u201d being stemmed to \u201cInnovate\u201d.\u003C\/p\u003E\n\u003Cp\u003EWe created a prefix-tree based stemmer for the PowerShell command syntax using an efficient data structure known as \u003Ca href=\u0022https:\/\/en.wikipedia.org\/wiki\/Trie\u0022\u003Etrie\u003C\/a\u003E, as shown in Figure 5. Even in a complex scripting language such as PowerShell, a trie can stem command tokens in nanoseconds.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/MachineLearningPowerShell\/Fig5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Synonyms in the PowerShell syntax (left) and the trie stemmer capturing these equivalences (right)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe overall NLP pipeline we developed is captured in the following table:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENLP Key Modules\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EFunctionality\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EDecoder\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EDetect and decode any encoded text\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENamed Entity Recognition (NER)\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EDetect and recognize any entities such as IP, URL, Email, Registry key, etc.\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ETokenizer\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ETokenize the PowerShell command into a list of tokens\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EStemmer\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EStem tokens into semantically identical token, uses trie\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EVocabulary Vectorizer\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EVectorize the list of tokens into machine learning friendly format\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ESupervised classifier\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EBinary classification algorithms:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EKernel Support Vector Machine\u003C\/li\u003E\n\u003Cli\u003EGradient Boosted Trees\u003C\/li\u003E\n\u003Cli\u003EDeep Neural Networks\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022258\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EReasoning\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022366\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EThe explanation of why the prediction was made. Enables analysts to validate predications.\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EThe following are the key steps when streaming the aforementioned example through the NLP pipeline:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EDetect and decode the Base64 commands, if any\u003C\/li\u003E\n\u003Cli\u003ERecognize entities using Named Entity Recognition (NER), such as the \u0026lt;URL\u0026gt;\u003C\/li\u003E\n\u003Cli\u003ETokenize the entire text, including both clear text and obfuscated commands\u003C\/li\u003E\n\u003Cli\u003EStem each token, and vectorize them based on the vocabulary\u003C\/li\u003E\n\u003Cli\u003EPredict the malicious probability using the supervised learning model\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/MachineLearningPowerShell\/Fig6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: NLP pipeline that predicts the malicious probability of a PowerShell command\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EMore importantly, we established a production end-to-end machine learning pipeline (Figure 7) so that we can constantly evolve with adversaries through re-labeling and re-training, and the release of the machine learning model into our products.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/MachineLearningPowerShell\/Fig7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: End-to-end machine learning production pipeline for PowerShell machine learning\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EValue Validated in the Field\u003Cb\u003E\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003EWe successfully implemented and optimized this machine learning model to a minimal footprint that fits into our research endpoint agent, which is able to make predictions in milliseconds on the host. Throughout 2018, we have deployed this PowerShell machine learning detection engine on incident response engagements. Early field validation has confirmed detections of malicious PowerShell attacks, including:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003ECommodity malware such as Kovter.\u003C\/li\u003E\n\u003Cli\u003ERed team penetration test activities.\u003C\/li\u003E\n\u003Cli\u003ENew variants that bypassed legacy signatures, while detected by our machine learning with high probabilistic confidence.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EThe unique values brought by the PowerShell machine learning detection engine include: \u0026nbsp;\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EThe machine learning model automatically learns the malicious patterns from the curated corpus. In contrast to traditional detection signature rule engines, which are Boolean expression and regex based, the NLP model has lower operation cost and significantly cuts down the release time of security content.\u003C\/li\u003E\n\u003Cli\u003EThe model performs probabilistic inference on unknown PowerShell commands by the implicitly learned non-linear combinations of certain patterns, which increases the cost for the adversaries to bypass.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EThe ultimate value of this innovation is to evolve with the broader threat landscape, and to create a competitive edge over adversaries.\u003C\/p\u003E\n\u003Ch4\u003EAcknowledgements\u003C\/h4\u003E\n\u003Cp\u003EWe would like to acknowledge:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EDaniel Bohannon, Christopher Glyer and Nick Carr for the support on threat research.\u003C\/li\u003E\n\u003Cli\u003EAlex Rivlin, HeeJong Lee, and Benjamin Chang from FireEye Labs for providing the DTI statistics.\u003C\/li\u003E\n\u003Cli\u003EResearch endpoint support from Caleb Madrigal.\u003C\/li\u003E\n\u003Cli\u003EThe FireEye ICE-DS Team.\u003C\/li\u003E\n\u003C\/ul\u003E\n",
        "jcr:lastModified": "Tue Jul 10 2018 12:09:20 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EThis blog post illustrates how FireEye is leveraging artificial intelligence and machine learning to raise the bar for adversaries that use PowerShell.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Jul 09 2018 17:51:06 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Tue Jul 10 2018 11:50:31 GMT-0400",
      "imageRotate": "0"
    }
  }
}
