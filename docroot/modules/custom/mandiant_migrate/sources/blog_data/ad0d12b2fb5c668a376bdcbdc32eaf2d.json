{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed May 04 2016 09:04:22 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "SYNful Knock - A Cisco router implant - Part I",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "8a39fb4e-379a-4a90-ae63-72de3849d6f1",
    "author": "Bill Hau",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "focusKeyword": "SYNful",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "7ba0f17a-5b3e-40d9-a09a-c9b2be5d1b21"
    ],
    "jcr:created": "Fri Sep 07 2018 16:24:07 GMT-0400",
    "cq:lastReplicated": "Fri Sep 07 2018 16:24:00 GMT-0400",
    "cq:lastModified": "Fri Sep 07 2018 16:23:50 GMT-0400",
    "cq:distribute": true,
    "jcr:baseVersion": "7ba0f17a-5b3e-40d9-a09a-c9b2be5d1b21",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-doctypes:blog",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-threat-research:threat-research\/malware-research",
      "fireeye-blog-authors:cap-bill-hau",
      "fireeye-blog-authors:cap-tony-lee",
      "fireeye-blog-authors:cap-josh-homan"
    ],
    "jcr:uuid": "e670617c-50be-4202-abe8-416b8f76c8c8",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Sep 15 2015 00:00:00 GMT-0700",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "grid_33_66_full_27d4": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "lynn.thorne@fireeye.com",
        "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
        "jcr:created": "Mon Sep 14 2015 11:46:00 GMT-0400",
        "jcr:lastModified": "Mon Sep 14 2015 11:46:00 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-33-66-full"
      },
      "grid_100_full_d79a": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "matthew.sawicki@fireeye.com",
        "jcr:lastModifiedBy": "matthew.sawicki@fireeye.com",
        "nested": "true",
        "jcr:created": "Mon Sep 14 2015 18:46:39 GMT-0400",
        "jcr:lastModified": "Mon Sep 14 2015 18:46:54 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-100-full"
      },
      "grid_66_33_full_f8e3": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "matthew.sawicki@fireeye.com",
        "jcr:lastModifiedBy": "matthew.sawicki@fireeye.com",
        "nested": "true",
        "jcr:created": "Mon Sep 14 2015 18:44:07 GMT-0400",
        "jcr:lastModified": "Mon Sep 14 2015 18:44:25 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-66-33-full"
      },
      "grid_100_full_abe5": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "matthew.sawicki@fireeye.com",
        "jcr:lastModifiedBy": "matthew.sawicki@fireeye.com",
        "nested": "true",
        "jcr:created": "Mon Sep 14 2015 18:47:31 GMT-0400",
        "jcr:lastModified": "Mon Sep 14 2015 18:47:31 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/grids\/grid-100-full"
      },
      "text_1bcc": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:createdBy": "lynn.thorne@fireeye.com",
        "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
        "jcr:created": "Mon Sep 14 2015 11:46:54 GMT-0400",
        "text": "\u003Cp\u003ESYNful Knock is a stealthy modification of the router\u0027s firmware image that can be used to maintain persistence within a victim\u0027s network. It is customizable and modular in nature and thus can be updated once implanted. Even the presence of the backdoor can be difficult to detect as it uses non-standard packets as a form of pseudo-authentication.\u003C\/p\u003E\n\u003Cp\u003EThe initial infection vector does not appear to leverage a zero-day vulnerability. It is believed that the credentials are either default or discovered by the attacker in order to install the backdoor. However, the router\u0027s position in the network makes it an ideal target for re-entry or further infection.\u003C\/p\u003E\n\u003Cp\u003EFinding backdoors within your network can be challenging; finding a router implant, even more so. This article not only dissects the implant, but also provides practical methods and tools for detecting a SYNful Knock compromise.\u003C\/p\u003E\n\u003Cp\u003EThe impact of finding this implant on your network is severe and most likely indicates the presence of other footholds or compromised systems. This backdoor provides ample capability for the attacker to propagate and compromise other hosts and critical data using this as a very stealthy beachhead.\u003C\/p\u003E\n\u003Ch5\u003EImplant Summary\u003C\/h5\u003E\n\u003Cp\u003EThe implant consists of a modified Cisco IOS image that allows the attacker to load different functional modules from the anonymity of the internet. The implant also provides unrestricted access using a secret backdoor password. Each of the modules are enabled via the HTTP protocol (not HTTPS), using a specifically crafted TCP packets sent to the routers interface. The packets have a nonstandard sequence and corresponding acknowledgment numbers.\u0026nbsp; The modules can manifest themselves as independent executable code or hooks within the routers IOS that provide functionality similar to the backdoor password. The backdoor password provides access to the router through the console and Telnet.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure1updated.jpg\u0022\u003E\u003C\/p\u003E\n\u003Ch5\u003EKnown Affected Hardware\u003C\/h5\u003E\n\u003Cul\u003E\n\u003Cli\u003ECisco 1841 router\u003C\/li\u003E\n\u003Cli\u003ECisco 2811 router\u003C\/li\u003E\n\u003Cli\u003ECisco 3825 router\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003ENote: Our initial identification revealed that other models are likely affected based on the similarity in core functionality and IOS code base.\u003Cbr\u003E\n\u003C\/p\u003E\n\u003Ch5\u003EPersistence\u003C\/h5\u003E\n\u003Cp\u003EThe implant resides within a modified Cisco IOS image and, when loaded, maintains its persistence in the environment, even after a system reboot. However, any further modules loaded by the attacker will only exist in the router\u2019s volatile memory and will not be available for use after reboot. From a forensic standpoint, if the modules are loaded in volatile memory, one can analyze them by obtaining a core dump of the router image\u003Ca name=\u0022_ftnref1\u0022\u003E\u003C\/a\u003E[1].\u003C\/p\u003E\n\u003Ch5\u003EDetails\u003C\/h5\u003E\n\u003Cp\u003EModifications to the IOS binary can be broken down into the following four functions:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EModify the translation lookaside buffer (TLB) Read\/Write attributes\u003C\/li\u003E\n\u003Cli\u003EModify a legitimate IOS function to call and initialize the malware\u003C\/li\u003E\n\u003Cli\u003EOverwrite legitimate protocol handling functions with malicious code\u003C\/li\u003E\n\u003Cli\u003EOverwrite strings referenced by legitimate functions with strings used by the malware\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch5\u003ETLB Read \/Write Attributes\u003C\/h5\u003E\n\u003Cp\u003EThe malware forces all TLB Read and Write attributes to be Read-Write (RW). We believe this change is made to support the hooking of IOS functions by loaded modules. If the TLB attributes are not set to RW, then modifications to the cached pages may not be propagated to the original page in memory.\u003C\/p\u003E\n\u003Cp\u003EThis is accomplished with two single-byte modifications made to the IOS function suspected to be responsible for configuring the TLB. The unmodified function set the first two bits of a register to 1, and the modified function sets the first three bits to 1. Mandiant believes that the third bit controls the Write permissions on the TLB entry. Figure 3 shows the modified instructions.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfig3.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Modification to TLB attributes\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis brings us to one of the host-based indicators discussed above. The TLB attributes can be examined using the enable mode command \u0026quot;show platform\u0026quot;. The TLB output of an unmodified IOS image is shown below in Figure 4.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfig4.jpg\u0022\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: TLB entries for a legitimate IOS image\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIf the router has been implanted with a modified IOS image, the RW attributes should be:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfig5.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: TLB entries for a modified IOS image\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EDepending on router hardware, certain ranges of memory addresses are typically read only executable code sections. The simplest way to determine if the router has been modified is to use the \u0026quot;show platform | include RO, Valid\u0026quot; command. The IOS image may have been tampered with to allow the modification of executable code if no results are displayed.\u003C\/p\u003E\n\u003Ch5\u003EInitialize the Malware\u003C\/h5\u003E\n\u003Cp\u003ETo execute the malware during IOS image loading, Mandiant believes that a function associated with process scheduling was modified. This was chosen because the modified function is called early on during the IOS boot sequence, and is always called, as long as the IOS boots correctly. The target address of a function call is modified to point to the malware hook processing function. Our research has shown that the malware is initialized after the hook processing function checks the calling function is valid in the modified IOS. Now that the malware is up and running, it executes the original IOS function so no one is the wiser.\u003C\/p\u003E\n\u003Cp\u003EMandiant believes the modified function is linked with the process scheduling task, the behavior is such that it enters an infinite loop once called. In addition, several of the sub functions reference strings associated with process scheduling, such as \u0026quot;Threshold: %s CPU Utilization(Total\/Intr):...\u0026quot;.\u003C\/p\u003E\n\u003Ch5\u003EMalware Executable Code Placement\u003C\/h5\u003E\n\u003Cp\u003ETo prevent the size of the image from changing, the malware overwrites several legitimate IOS functions with its own executable code. The attackers will examine the current functionality of the router and determine functions that can be overwritten without causing issues on the router. Thus, the overwritten functions will vary upon deployment.\u003C\/p\u003E\n\u003Ch5\u003EMalware Strings and Configuration\u003C\/h5\u003E\n\u003Cp\u003EKeeping with the theme mentioned above, since the image size cannot change, the implant also overwrote some reporting strings with its own configuration. This is another indicator of compromise that can be used for detection purposes. The legitimate strings that are overwritten are shown in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure6.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Strings associated with a valid function overwritten by the malware\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe contents shown in Figure 6 were replaced with the contents shown below in Figure 7. Clearly visible are the malware\u2019s strings included in the HTTP header used in Command and Control, along with the default password, which we have intentionally blanked. This will provide potential victims time to search their own networks for compromise and remediate the issue. Feel free to contact us via email at synfulknock-at-fireeye.com and we can provide the password after you suspect you have been compromised.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure7.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Malware strings\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAgain we arrive at another host-based indicator that can potentially be used to identify the presence of the implant; however, the location of the configuration strings may vary depending on deployment and must first be discovered.\u003C\/p\u003E\n\u003Cp\u003EA modified IOS image will produce a very different and suspicious result when running what would seem to be an ordinary IOS command.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulunnumbered.jpg\u0022\u003E\u003C\/p\u003E\n\u003Ch5\u003EBackdoor Password\u003C\/h5\u003E\n\u003Cp\u003EThe attacker can utilize the secret backdoor password in three different authentication scenarios. The implant will first check to see if the user input is the backdoor password. If so, access is granted. Otherwise, the implanted code will pass the credentials on for verification of potentially valid credentials. This ensures that the least amount of suspicion is raised. The following three instances were verified to enable access using the backdoor password:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfultable1.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003ETable 1:\u0026nbsp; Authentication functions in which the secret backdoor password can be used\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EResearch has shown that SSH or HTTPS sessions do not provide access for the backdoor password. This could be a configuration issue and may vary on compromise.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulupdated.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8:\u0026nbsp; Subtle difference between authenticating using a legitimate password and the backdoor password\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003ENetwork Command and Control (CnC)\u003C\/h5\u003E\n\u003Cp\u003EThe Command and Control portion of the implant is modular and allows additional functionality to be loaded into the IOS. The CnC functionality is stealthy because it requires a series of TCP trigger packets that the malware monitors for specific TCP header values and content. Even if filters are enabled on the router, the TCP trigger is processed by the malware. The malware will respond to trigger packets sent to three different addresses: the router interface, the broadcast IP, and the network address (the first IP in a subnet).\u003C\/p\u003E\n\u003Cp\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; To initiate the process, a uniquely crafted TCP SYN packet is sent to port 80 of the \u201cimplanted\u201d router. It is important to note that the difference between the sequence and acknowledgment numbers must be set to 0xC123D. Also the ACK number doesn\u2019t need to be zero.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure10.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9:\u0026nbsp; TCP SYN with sequence and acknowledgement offset of 0xC123D\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; As typical with a 3-way handshake, the malware responds with a TCP SYN-ACK message acknowledging the first SYN message. However, the following conditions will be present:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EThe differential between the acknowledgment and sequence numbers is now 0xC123E\u003C\/li\u003E\n\u003Cli\u003EThe following hard-coded TCP options are set: \u0026nbsp;\u0026quot;02 04 05 b4 01 01 04 02 01 03 03 05\u0026quot;\u003C\/li\u003E\n\u003Cli\u003EThe urgent pointer is also set to 0x0001 but the urgent flag is not set\u003C\/li\u003E\n\u003Cli\u003EThe malware also copies the acknowledgment number from the SYN packet for the sequence number. A typical server usually generates a random sequence number, thus this is not a standard TCP handshake.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EThese unique conditions are the anomalies that Mandiant used to write network detection signatures and tools.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure11.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10:\u0026nbsp; TCP SYN-ACK with sequence and acknowledgement offset of 0xC123E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; After the final ACK to complete the 3-way handshake, the controller then sends the following TCP message:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EThe PUSH and ACK flags are set\u003C\/li\u003E\n\u003Cli\u003EFrom the start of the TCP header, at offset 0x62, the string \u0026quot;text\u0026quot; is written\u003C\/li\u003E\n\u003Cli\u003EThe command shown below is at offset 0x67 from the TCP header\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EThe command is in the following format:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synful.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003EThe [CMD Data] is XOR encoded with a static key. There is a checksum algorithm, which is a four-byte XOR of the decoded [CMD Data].\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure12.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11:\u0026nbsp; Controller command packet\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The malware response is encapsulated in the following static HTTP\/HTML server response. Fortunately, the response from the malware is not XOR encoded and will be easy to decipher.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure12a.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/SYNful\/synfulfigure13.jpg\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12:\u0026nbsp; Victim response\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003ESupported Commands\u003C\/h5\u003E\n\u003Cp\u003EWe mentioned previous that this implant is modular. The five commands shown in the table below are used for loading additional modules and functionality on the victim router. A total of 100 additional modules can be loaded, however these modules are memory resident and will not persist after a reboot or reload.\u003C\/p\u003E\n\u003Cp\u003ECommand messages set the first WORD (4-byte big-endian) to zero. The second WORD identifies the message type (values zero through four). All message types will start with the following eight bytes:\u003C\/p\u003E\n\u003Ctable class=\u0022c09 has-data-label has-auto-width\u0022\u003E\n\u003Ctbody\u003E\u003Ctr class=\u0022c09_tr c09_tr-th\u0022\u003E\u003Cth scope=\u0022col\u0022 class=\u0022c09_td\u0022\u003EID\u003C\/th\u003E\n\u003Cth scope=\u0022col\u0022 class=\u0022c09_td\u0022\u003EDescription\u003C\/th\u003E\n\u003C\/tr\u003E\u003Ctr class=\u0022c09_tr\u0022\u003E\u003Cth class=\u0022c09_td c09_td-tdh\u0022 scope=\u0022row\u0022\u003E0\u003Cbr\u003E\n\u003C\/th\u003E\n\u003Ctd class=\u0022c09_td\u0022\u003E\u003Cspan class=\u0022is-visible-mml\u0022\u003E \u003Cspan\u003E\u003Cbold\u003EList loaded modules and their current state. The response contains a word representing the ID number followed by a word representing the state for each loaded module.\u003Cbr\u003E\n \u003Cbr\u003E\n Valid states are as follows:\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;00 - Memory is allocated\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;01 - Module is loaded into memory\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;02 - Module is activated\u003Cbr\u003E\n \u003Cbr\u003E\n For example, if the malware responds with this message:\u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E00 00 00 03 00 00 02\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n Then, the message would indicate module 03 is in the activated state (02).\u003Cbr\u003E\n\u003C\/bold\u003E\u003C\/span\u003E\u003C\/span\u003E \u003Cspan class=\u0022c09_td_value is-hidden-mml\u0022\u003E\u003Cbold\u003EList loaded modules and their current state. The response contains a word representing the ID number followed by a word representing the state for each loaded module.\u003Cbr\u003E\n \u003Cbr\u003E\n Valid states are as follows:\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;00 - Memory is allocated\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;01 - Module is loaded into memory\u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;02 - Module is activated\u003Cbr\u003E\n \u003Cbr\u003E\n For example, if the malware responds with this message:\u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E00 00 00 03 00 00 02\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n Then, the message would indicate module 03 is in the activated state (02). \u003Cbr\u003E\n \u003C\/bold\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr class=\u0022c09_tr\u0022\u003E\u003Cth class=\u0022c09_td c09_td-tdh\u0022 scope=\u0022row\u0022\u003E1\u003C\/th\u003E\n\u003Ctd class=\u0022c09_td\u0022\u003E\u003Cspan class=\u0022is-visible-mml\u0022\u003E \u003Cspan\u003E\u003Cbold\u003EAllocate space for an additional module to be loaded.\u003C\/bold\u003E The command provides the module size for two required buffers. The malware allocates the memory for two buffers and returns the addresses in the response. The first buffer is the executable code, and we suspect that the second buffer is for configuration and storage. The syntax for this message follows this format:\u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E[WORD ID][WORD first buffer length][WORD second buffer length]\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n An example command that tells the malware to allocate 0x0C bytes for the first buffer and 0x90 bytes for the second buffer of module ID 0x02: \u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E00 00 00 02 00 00 00 0C 00 00 00 90\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n An example response from the server shows the first buffer is at memory address 0x66012C4C and the second is at 0x650DCD20:\u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E66 01 2C 4C 65 0D CD 20\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n After executing this command, the module state is set to zero.\u003C\/span\u003E\u003C\/span\u003E \u003Cspan class=\u0022c09_td_value is-hidden-mml\u0022\u003E\u003Cbold\u003EAllocate space for an additional module to be loaded.\u003C\/bold\u003E The command provides the module size for two required buffers. The malware allocates the memory for two buffers and returns the addresses in the response. The first buffer is the executable code, and we suspect that the second buffer is for configuration and storage. The syntax for this message follows this format:\u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E[WORD ID][WORD first buffer length][WORD second buffer length]\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n An example command that tells the malware to allocate 0x0C bytes for the first buffer and 0x90 bytes for the second buffer of module ID 0x02: \u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E00 00 00 02 00 00 00 0C 00 00 00 90\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n An example response from the server shows the first buffer is at memory address 0x66012C4C and the second is at 0x650DCD20:\u003Cbr\u003E\n \u003Cbr\u003E\n \u0026nbsp;\u0026nbsp;\u003Cspan style=\u0022font-family: Courier New;\u0022\u003E66 01 2C 4C 65 0D CD 20\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n After executing this command, the module state is set to zero. \u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr class=\u0022c09_tr\u0022\u003E\u003Cth class=\u0022c09_td c09_td-tdh\u0022 scope=\u0022row\u0022\u003E2\u003Cbr\u003E\n\u003C\/th\u003E\n\u003Ctd class=\u0022c09_td\u0022\u003E\u003Cspan class=\u0022is-visible-mml\u0022\u003E \u003Cspan\u003E\u003Cbold\u003EPopulate the memory allocated for the module.\u003C\/bold\u003E This command is used to populate the executable code and suspected configuration data.\u003Cbr\u003E\n \u003Cbr\u003E\n \u003Cspan style=\u0022font-family: Courier New;\u0022\u003E[0x80 Bytes hook data][WORD first buffer length][WORD second buffer length] [First buffer...][Second buffer...]\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n Similar to how the default password hook functions, the hook data buffer is used to inject additional hooks into the IOS. The hook buffer provides addresses within the IOS where hooks should be installed, and the code that should be run when the hooks are executed.\u003Cbr\u003E\n \u003Cbr\u003E\n After executing this command, the module state is set to one. \u003Cbr\u003E\n\u003C\/span\u003E\u003C\/span\u003E \u003Cspan class=\u0022c09_td_value is-hidden-mml\u0022\u003E\u003Cbold\u003EPopulate the memory allocated for the module.\u003C\/bold\u003E This command is used to populate the executable code and suspected configuration data.\u003Cbr\u003E\n \u003Cbr\u003E\n \u003Cspan style=\u0022font-family: Courier New;\u0022\u003E[0x80 Bytes hook data][WORD first buffer length][WORD second buffer length] [First buffer...][Second buffer...]\u003C\/span\u003E\u003Cbr\u003E\n \u003Cbr\u003E\n Similar to how the default password hook functions, the hook data buffer is used to inject additional hooks into the IOS. The hook buffer provides addresses within the IOS where hooks should be installed, and the code that should be run when the hooks are executed.\u003Cbr\u003E\n \u003Cbr\u003E\n After executing this command, the module state is set to one. \u003Cbr\u003E\n \u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr class=\u0022c09_tr\u0022\u003E\u003Cth class=\u0022c09_td c09_td-tdh\u0022 scope=\u0022row\u0022\u003E3\u003Cbr\u003E\n\u003C\/th\u003E\n\u003Ctd class=\u0022c09_td\u0022\u003E\u003Cspan class=\u0022is-visible-mml\u0022\u003E \u003Cspan\u003E\u003Cbold\u003EActivate a loaded module.\u003Cbold\u003E The malware parses the hook data buffer and creates the necessary hooks within the OS to execute a module. The only argument is a WORD representing the module ID.\u003Cbr\u003E\n \u003Cbr\u003E\n After executing this command, the module state is set to two. \u003Cbr\u003E\n\u003C\/bold\u003E\u003C\/bold\u003E\u003C\/span\u003E\u003C\/span\u003E \u003Cspan class=\u0022c09_td_value is-hidden-mml\u0022\u003E\u003Cbold\u003EActivate a loaded module.\u003Cbold\u003E The malware parses the hook data buffer and creates the necessary hooks within the OS to execute a module. The only argument is a WORD representing the module ID.\u003Cbr\u003E\n \u003Cbr\u003E\n After executing this command, the module state is set to two. \u003Cbr\u003E\n \u003C\/bold\u003E\u003C\/bold\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr class=\u0022c09_tr\u0022\u003E\u003Cth class=\u0022c09_td c09_td-tdh\u0022 scope=\u0022row\u0022\u003E4\u003Cbr\u003E\n\u003C\/th\u003E\n\u003Ctd class=\u0022c09_td\u0022\u003E\u003Cspan class=\u0022is-visible-mml\u0022\u003E \u003Cspan\u003E\u003Cbold\u003ERemove a module.\u003C\/bold\u003E The memory allocated for the module is released and the state is set to zero. The module will no longer show up in the active modules command.\u003Cbr\u003E\n\u003C\/span\u003E\u003C\/span\u003E \u003Cspan class=\u0022c09_td_value is-hidden-mml\u0022\u003E\u003Cbold\u003ERemove a module.\u003C\/bold\u003E The memory allocated for the module is released and the state is set to zero. The module will no longer show up in the active modules command.\u003Cbr\u003E\n\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003ETable 2: Supported Commands\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIf the first WORD of a message is not zero, the code associated with the module ID of the first WORD is executed. This enables the execution of code that is not hooked into an IOS function.\u003C\/p\u003E\n\u003Ch5\u003E\u003Cb\u003EConclusion\u003C\/b\u003E\u003C\/h5\u003E\n\u003Cp\u003EWe hope that this post has advanced the understanding of this flexible and stealthy router implant. It should be evident now that this attack vector is very much a reality and will most likely grow in popularity and prevalence. In the next part of this series, we will examine methods that can be used to passively and actively detect this implant.\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003EThe following blog entry shows how to produce a Cisco IOS core dump: http:\/\/blogs.cisco.com\/security\/offline-analysis-of-ios-image-integrity\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n",
        "jcr:lastModified": "Wed Sep 23 2015 16:14:18 GMT-0400",
        "sling:resourceType": "fireeye-www\/fdc\/components\/text\/text",
        "textIsRich": "true"
      },
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
        "jcr:lastModified": "Tue Sep 15 2015 20:58:09 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    }
  }
}
