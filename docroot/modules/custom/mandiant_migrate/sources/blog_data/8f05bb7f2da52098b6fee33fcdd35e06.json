{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Fri Sep 01 2017 10:40:42 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Monitoring Windows Console Activity (Part 2)",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "e02bb217-4c5a-44b4-87b5-af2f62c90f0d",
    "author": "Andrew Davis",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "4d55b3c9-7bc1-44fa-a688-2444da4d62e8"
    ],
    "jcr:created": "Fri Sep 01 2017 10:43:11 GMT-0400",
    "cq:lastReplicated": "Fri Sep 01 2017 10:42:57 GMT-0400",
    "cq:lastModified": "Fri Sep 01 2017 10:42:45 GMT-0400",
    "cq:distribute": true,
    "jcr:baseVersion": "4d55b3c9-7bc1-44fa-a688-2444da4d62e8",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-authors:cap-andrew-davis",
      "fireeye-doctypes:blog",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:windows-incident-response"
    ],
    "jcr:uuid": "99ce1f4e-7e54-4227-ad5c-c2cbb6cd4997",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Fri Sep 01 2017 11:00:00 GMT-0400",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EThis is the second of two blogs that discuss the implementation of the Windows console architecture from years past, with a primary focus on the current implementation present on modern versions of Windows. Read our first blog,\u0026nbsp;\u0026quot;\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/08\/monitoring-windows-console-activity-part-one.html\u0022\u003EMonitoring Windows Console Activity Part 1\u003C\/a\u003E,\u0026quot; for more.\u003C\/p\u003E\n\u003Ch4\u003ECapturing the Data\u003C\/h4\u003E\n\u003Cp\u003EBefore we examine how to capture console data, an understanding of how this differs from capturing process arguments may be useful. After all, can\u0027t we just examine the Process Environment Block (PEB) for each process and gather the command line arguments? This would show us the command arguments that an attacker used when executing tasks on a compromised machine. However, if an attacker is using any command line tools that are interactive at runtime, this data structure can\u0027t show us what commands the attacker issued to the tool.\u003C\/p\u003E\n\u003Cp\u003EFor example, Figure 1 shows the command line used to execute an instance of the popular credential dumping tool, \u003Ca href=\u0022https:\/\/github.com\/gentilkiwi\/mimikatz\u0022\u003Emimikatz\u003C\/a\u003E. An attacker could use any of the several features of this tool, including credential stealing or hash dumping. Additionally, knowing what user accounts the attacker compromised is difficult because we can\u0027t see the output of mimikatz at the time it was executed. Later we will look at the value of gathering this data from the console and how this level of context is useful.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig1b.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Process explorer showing the command line used to execute an instance of mimikatz\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENow that we understand how all this works, how can we intercept the data? Doing so on Windows 7 and earlier seems pretty difficult. It seems possible (albeit a little impractical) that we could capture the data by synchronizing with the ConsoleEvent object we mentioned earlier, and then read data out of the section object containing the data. Another way could be sending the necessary ALPC messages to access the command data, and in fact there is an exported API in kernel32.dll that does exactly that. GetConsoleCommandHistory will retrieve commands from the current console session. The downside here is that you have to be executing in the context of a client process to use this API. This would require process injection or some other illicit means. Neither of these methods are particularly elegant.\u003C\/p\u003E\n\u003Cp\u003EThe console driver used in Windows 8 and later simplifies this quite a bit. Because the driver exposes a device object, we should be able to attach and filter on it. But then what? We need to understand how the feature is implemented in more detail and how the data is formatted.\u003C\/p\u003E\n\u003Cp\u003ELooking at the driver entry point, we see some pretty standard driver initialization. What is interesting, however, is the initialization of the Fast I\/O Device Control dispatch function. This function will be called by the kernel before the standard IRP-based IRP_MJ_DEVICE_CONTROL dispatch function. The fast version can then choose to mark the operation as complete, or pass it back and have an IRP generated. Figure 2 shows the interesting entry points for ConDrv.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig2b.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Entry points for the Windows Console Driver (ConDrv)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ESome quick poking around in the user code reveals that just about all data we are interested in is transferred by NtDeviceIoControlFile to ConDrv. Data is also transferred to the ConDrv device handles using NtReadFile and NtWriteFile, however, these same data buffers are also sent using NtDeviceIoControlFile when Conhost is sending or requesting new data.\u0026nbsp; Therefore, filtering on the FastIoDeviceControl routine should give up the I\/O data we are looking for (Figure 3).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig3b.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Function prototype for the \u003Ca href=\u0022http:\/\/www.osronline.com\/article.cfm?id=166\u0022\u003EFastIoDeviceControl\u003C\/a\u003E dispatch function\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAnalysis of this function reveals a switch statement for handling passed in IOCTL codes containing the bulk of the functionality exposed to user mode. Figure 4 shows the code that handles the IOCTL codes related to reading and writing data to the console.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig4b.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: IOCTL handler code in ConDrv\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThere are quite a few IOCTL codes supported by ConDrv, but for now we only care about a subset of them, which are listed in Table 1.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 width=\u0022473\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022234\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EIOCTL Code\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022239\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EFunction\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022234\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0x50000B\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022239\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EComplete pending I\/O\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022234\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0x50000F\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022239\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EData is available to be read from client (e.g. conhost.exe \u0026lt;- cmd.exe)\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022234\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0x500013\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022239\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EData is available to be written to client (e.g. conhost.exe -\u0026gt; cmd.exe)\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022234\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0x500037\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022239\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ELaunch a new conhost.exe process\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003ETable 1: Interesting IOCTL handlers supported by ConDrv\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe two IOCTL codes responsible for reading and writing data between clients and servers are most interesting (0x50000F and 0x500013). Setting a breakpoint on condrv!CdpFastIoDeviceControl and entering some text into a command prompt causes the debugger to break in the process context of conhost.exe.\u003C\/p\u003E\n\u003Cp\u003EExamining the function arguments using the prototype in Figure 3 shows the input buffer, size, and IOCTL code that Conhost supplied when sending the command string to cmd.exe. These arguments are highlighted in yellow, blue, and green respectively and shown in Figure 5. Note: The input buffer is a user mode address mapped into Conhost.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig5b.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: IOCTL Examining the function parameters for condrv!CdpFastIoDeviceControl\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EDereferencing the input buffer shows an opaque data structure. Analyzing more of the ConDrv code that processes the input buffer helps understand the format the data is in. This structure\u2019s format is shown in Figure 6. Note: this is an undocumented structure (from what I can tell) and its fields are based on analysis of the ConDrv code.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Message buffer structure inferred from condrv.sys on a Windows 10 system\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EEach I\/O message contains a buffer and buffer size of the command data. On output, this same structure is used to deliver the results of the executed command. Figure 7 shows the capture of a console command in Windbg by applying this structure definition to the data. Here we see a simple directory listing command being entered into a command prompt. These same steps can be used to capture the command output as well.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Displaying command data in Windbg\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENow that we understand the format of the I\/O data and how it is transferred, we can write a proof of concept filter driver to capture it and send it back to user mode for processing. Since we get this data inline, it should be possible to reconstruct all console sessions on the machine. We will attach to \\Device\\ConDrv and copy the data from the input buffers on every Conhost process on the system. We will then use a Python script to retrieve the captured I\/O data that is sent to it from the kernel driver.\u003C\/p\u003E\n\u003Cp\u003EFirst let\u0027s see if we can fully capture the data of a user executing an interactive Python session. Figure 8 shows a user\u0027s Python session. The command window on the bottom is a normal user session executing Python code. The window above shows the data that is captured from the ConDrv filter driver. The flow (input vs. output) is identified using the IOCTL codes shown in Table 1. This gives precise context on the commands since the data is sent to the driver inline.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Capturing a Python console session; user session shown below, captured data from condrv.sys shown above.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn the beginning of this post, we mentioned mimikatz and how reading its process arguments doesn\u2019t provide the commands if the attacker interacts with the console directly. Figure 1 demonstrates how all that is revealed by the PEB command line arguments is the path of the mimikatz process. Figure 9 demonstrates the captured console I\/O from this same mimikatz session. Now we can identify that an attacker was able to acquire NT LAN Manager (NTLM) hashes from the system. We can even tell exactly when they were stolen and what accounts were compromised. Having a timeline of activity like this is crucial during the incident response process, and acquiring this data through other means (such as process memory dumps) lacks valuable context.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Monitoring%20Windows\/Fig9.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Capturing a mimikatz console session; attacker session shown below, captured data from condrv.sys shown above.\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EPutting this all together, we can now intercept, modify, or outright deny all console input and output on a Windows 8 and later system. This can be used to capture not only I\/O from system utilities, but from any program that uses a console. This can range from interactive interpreters such as Python, Ruby, and Perl to security tools such as mimikatz and Metasploit. As attackers continue to act more brazenly on the systems they compromise, being able to identify this activity remains crucial.\u0026nbsp;\u003C\/p\u003E\n",
        "jcr:lastModified": "Fri Sep 01 2017 10:42:45 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Aug 31 2017 14:15:07 GMT-0400",
      "imageRotate": "0"
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EThis is the second of two blogs that discuss the implementation of the Windows console architecture from years past, with a primary focus on the current implementation present on modern versions of Windows.\u003C\/p\u003E\n",
      "jcr:lastModified": "Fri Sep 01 2017 10:39:57 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
