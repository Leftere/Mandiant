{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Thu Aug 18 2016 07:59:35 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "WMI vs. WMI: Monitoring for Malicious Activity",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "0886db0c-2ab7-46a7-9ef0-135bbcbf8d31",
    "author": "Timothy Parisi",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "lynda.hall@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "594ea0b3-95bd-46bb-9024-b22ca75f1c13"
    ],
    "jcr:created": "Thu Aug 25 2016 12:27:54 GMT-0400",
    "cq:lastReplicated": "Thu Aug 25 2016 12:27:53 GMT-0400",
    "cq:lastModified": "Thu Aug 18 2016 11:13:13 GMT-0400",
    "cq:distribute": true,
    "jcr:description": "When a Security Operations Center (SOC) doesn\u0027t have the capabilities to detect WMI activity from both a network and endpoint perspective, the lack of visibility can provide threat actors a perfect opening for attacks. Here\u0027s how FireEye solves the problem.\n\n",
    "jcr:baseVersion": "594ea0b3-95bd-46bb-9024-b22ca75f1c13",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-tags:cyber",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-threat-research:threat-research\/vulnerabilities",
      "fireeye-blog-authors:evan-pena",
      "fireeye-doctypes:blog",
      "fireeye-blog-tags:cybersecurity",
      "fireeye-blog-authors:cap-timothy-parisi",
      "fireeye-blog-tags:cyber-attacks",
      "fireeye-blog-tags:cyber-security",
      "fireeye-blog-tags:malicious-software",
      "fireeye-blog-tags:cyber-attack",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware"
    ],
    "jcr:uuid": "e3a1be5e-170f-4ff3-aaba-aa50aaf51fec",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Aug 18 2016 08:00:00 GMT-0400",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "lynn.thorne@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
        "text": "\u003Ch5\u003EHello my name is: WMI\u003C\/h5\u003E\n\u003Cp\u003EWMI has been a core component of Windows since Windows 98, but it is not exactly old wine in a new bottle. WMI more closely resembles that bottle of \u201861 Bordeaux wine that continues to impress us as it ages and matures. WMI was developed as Microsoft\u2019s interpretation of web-based enterprise management (WBEM) for system management and auditing; however, adversaries can use it for all stages of the Attack Lifecycle (shown in Figure 1), from creating the initial foothold on a system to stealing data from the environment and everything in-between. From an investigative perspective, WMI has only recently been used by a select few groups of attackers and it is an artifact that may be overlooked during investigations. Though WMI does not provide a default detailed tracing log\u003Ca name=\u0022_ftnref1\u0022\u003E\u003C\/a\u003E[1] of execution or persistence activity.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WMIvsWMI%20tim%20parisi\/Fig1.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1. The Attack Lifecycle\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn this blog post we will discuss how attackers can use WMI as a remote execution utility and as a persistence mechanism to execute malware, as well as what you can do to detect this activity at enterprise scale.\u003C\/p\u003E\n\u003Ch5\u003EThe Problem\u003C\/h5\u003E\n\u003Cp\u003EWe were recently onsite for a Red Teaming for Security Operations engagement, where our Red Team utilized WMI as a remote execution utility (similar to PsExec) and as a malware persistence mechanism (similar to a system service). We quickly realized that the client\u2019s Security Operations Center (SOC) did not have the capabilities to detect this activity from both a network and endpoint perspective, so we opted to pause the red teaming activities and work with the client to identify a solution to this lack of visibility.\u003C\/p\u003E\n\u003Ch5\u003EThe Solution\u003C\/h5\u003E\n\u003Cp\u003EWe determined that following the attacker adage of \u201cliving off the land\u201d was what we needed to solve the problem from a defense perspective. In other words, we leveraged WMI to monitor itself and feed WMI-invoked process creations and persistence activity directly into the system\u2019s Application event log. This allowed our client the ability to feed these logs from endpoints into their SIEM and achieve greater visibility into their entire environment.\u003C\/p\u003E\n\u003Cp\u003ETo accomplish this, we created a WMI subscription. A subscription is the term used for WMI persistence, and it consists of the following three items:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EAn Event Consumer: An action to perform upon triggering an event of interest\u003C\/li\u003E\n\u003Cli\u003EAn Event Filter: The event of interest\u003C\/li\u003E\n\u003Cli\u003EA Filter to Consumer Binding: The registration mechanism that binds a filter to a consumer\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EThis WMI Subscription is similar to the Subscriptions created by attackers for persistence; however, we\u2019re repurposing this method to perform a different type of action. Instead of executing malware when a condition is met, such as when the system uptime reaches 200 seconds, we\u2019re instructing WMI to log any newly created Consumers or WMI-induced process executions to the Application event log. We utilized PowerShell to configure WMI with these new instructions. At a high level, the PowerShell script performs the following:\u003C\/p\u003E\n\u003Cp\u003E1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Uses WMI Query Language (WQL) to identify:\u003Cbr\u003E\n\u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp; Recently created \u201c__EventConsumer\u201d events (persistence mechanisms)\u003Cbr\u003E\n\u0026nbsp;\u0026nbsp;\u0026nbsp; b.\u0026nbsp;\u0026nbsp;\u0026nbsp; WMI-based process executions\u003C\/p\u003E\n\u003Cp\u003E2.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Creates an Event Filter (condition), to perform an action if any of the above WQL conditions are true\u003C\/p\u003E\n\u003Cp\u003E3.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Creates an Event Consumer (action), to log details of the newly created \u201c__EventConsumer\u201d or executed process\u003Cbr\u003E\n\u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp; To log details, we call the \u201cNTEventLogEventConsumer\u201d WMI class that logs a custom message to the Application event log that contain the following details, depending on if this was a new Event Consumer or Process Creation:\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; i.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Event Consumer Name\u003Cbr\u003E\n\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp; ii.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Event Consumer Command\u003Cbr\u003E\n\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; iii.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Process Call Method\u003Cbr\u003E\n\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp; iv.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Process Call Command\u003C\/p\u003E\n\u003Cp\u003E4.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Creates and registers the Binding, which associates the Condition to the Action\u003C\/p\u003E\n\u003Ch5\u003EThe Result\u003C\/h5\u003E\n\u003Cp\u003EFigure 2 shows the general details of the newly created WMI Consumer that we aptly named \u201c_EvilConsumer_\u201d in the Application event log.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WMIvsWMI%20tim%20parisi\/Fig2.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2. General view of WMI Persistence event log\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 3 shows the detailed view of the event log, which contains the Consumer Name and Command Executed for the creation of the new WMI Consumer \u201c_EvilConsumer_\u201d.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WMIvsWMI%20tim%20parisi\/Fig3.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3. Detailed view of the WMI Persistence event log\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe following example illustrates another common use-case, demonstrating how attackers utilize WMI for process execution against remote systems. Figure 4 shows a command-line example of Windows Management Instrumentation Command-line (WMIC) usage to execute a remote PowerShell process. The command used the \u201cInvoke-Expression\u201d (IEX) cmdlet to download and execute the \u201cexecPayload.ps1\u201d script over HTTP on the remote system \u201cWIN-RD35VEB5LRT\u201d.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WMIvsWMI%20tim%20parisi\/Fig4.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4. WMIC command used to execute PowerShell on WIN-RD35VEB5LRT\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBecause the PowerShell process was ultimately executed via WMI, our WMI monitoring subscriber logged the process name and the process arguments. Figure 5 shows the general details of the WMI process execution in the Application event log on the victim system \u201cWIN- RD35VEB5LRT\u201d.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WMIvsWMI%20tim%20parisi\/Fig5.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5. General view of the WMI process creation event log\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 6 shows the detailed view of the event log, which contains the command executed \u201cpowershell.exe\u201d from the WMI-invoked process creation.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WMIvsWMI%20tim%20parisi\/Fig6.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6. Detailed view of the WMI process creation event log\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003EMonitoring in the Enterprise\u003C\/h5\u003E\n\u003Cp\u003ENow that we can log newly created Event Consumers and processes spawned via WMI, we can take steps to make this more enterprise-friendly. Our client\u2019s SOC used a third-party utility to inject log data into their SIEM. Our client could now feed the newly defined Application event logs into their SIEM and alert on these events to perform follow-up analysis. Environments of all sizes can follow these similar steps to enact this WMI persistence monitoring and alert on new events:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EDeploy the WMI monitoring PowerShell script to endpoints via GPO, SCCM or other third party utility. This creates a permanent WMI subscription that will monitor for newly created Event Consumers on endpoint systems.\u003C\/li\u003E\n\u003Cli\u003EPush or pull the Application event logs that match the WMI persistence or process creation events using Snare or a similar utility into a SIEM.\u003C\/li\u003E\n\u003Cli\u003EAlert on the WMI persistence or process creation logs through the SIEM. Note: some environments may heavily utilize WMI invoked process creations for system administration. In these cases, we recommend coordinating with your IT team to establish baselines for WMI activity, and only ingest anomalous events, such as process creations from \u201c%SYSTEMDRIVE%\\Windows\\Temp\u201d.\u003C\/li\u003E\n\u003Cli\u003EPerform follow-up analysis on the system(s) with newly created WMI event consumers or process creations.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EThis process provided an enterprise-friendly way to monitor and detect for certain WMI events in near-real time for our client, without having to perform endpoint forensic collection and analysis.\u003C\/p\u003E\n\u003Ch5\u003EDownload the Script\u003C\/h5\u003E\n\u003Cp\u003EYou can download the PowerShell script from the GitHub page \u003Ca href=\u0022https:\/\/github.com\/realparisi\/WMI_Monitor\u0022\u003Ehere\u003C\/a\u003E. Note: You must run PowerShell as administrator before using the script. The script requires PowerShell version 3 or above (most recent is version 5) and will run in its current state as two separate PowerShell functions. Figure 7 shows a screenshot of how to import the modules from the script and how to run each module.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WMIvsWMI%20tim%20parisi\/Fig7.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7. Screenshot showing the import of the WMIMonitor script modules and running each module\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch5\u003EAn Acknowledgment\u003C\/h5\u003E\n\u003Cp\u003EWe would like to thank Matt Graeber (@mattifestation) for his help with developing Windows Management Instrumentation (WMI) as an Intrusion Detection System. We combined and modified two PowerShell scripts \u2013 originally developed by Matt \u2013 to alert on WMI Event Consumers and process creations and output details of these events directly to the Application event log. Matt Graeber\u2019s WMI work that we used to identify and log malicious WMI actions can be found \u003Ca href=\u0022https:\/\/gist.github.com\/mattifestation\/aff0cb8bf66c7f6ef44a#file-example_wmi_detection_eventlogalert-ps1\u0022\u003Ehere\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/gist.github.com\/mattifestation\/fa2e3cea76f70b1e2267#file-wmi_attack_detection-ps1-L183\u0022\u003Ehere\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Ca name=\u0022_ftn1\u0022\u003E\u003C\/a\u003E[1] Windows 7 and above operating systems contain the WMI Activity Operational event log, however, this does not provide details of newly created Consumers, Filters or Bindings used for WMI persistence.\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Aug 18 2016 11:13:13 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "lynn.thorne@fireeye.com",
      "text": "\u003Cp\u003EWhen a Security Operations Center (SOC) doesn\u0027t have the capabilities to detect WMI activity from both a network and endpoint perspective, the lack of visibility can provide threat actors a perfect opening for attacks. Here\u0027s how FireEye solves the problem.\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Aug 18 2016 07:58:47 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
