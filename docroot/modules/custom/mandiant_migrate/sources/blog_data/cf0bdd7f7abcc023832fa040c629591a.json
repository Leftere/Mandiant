{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Thu Aug 22 2019 03:35:26 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Finding Evil in Windows 10 Compressed Memory, Part One: Volatility and Rekall Tools",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "697d8ca1-f130-4c8a-9b9a-6d1ad831b2c3",
    "author": "Blaine Stancill",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "6743819d-ed51-423b-82df-afbdd9129182"
    ],
    "jcr:created": "Thu Aug 22 2019 03:35:26 GMT+0000",
    "cq:lastReplicated": "Mon Aug 12 2019 11:27:20 GMT-0400",
    "cq:lastModified": "Mon Aug 12 2019 11:27:09 GMT-0400",
    "jcr:baseVersion": "6743819d-ed51-423b-82df-afbdd9129182",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:blaine-stancill",
      "fireeye-blog-authors:sebastian-vogl",
      "fireeye-blog-authors:omar-sardar",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:windows-10",
      "fireeye-blog-tags:tools",
      "fireeye-blog-tags:memory-forensics",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "9b8c0d43-b6f5-4ef1-9a01-42827ee76aef",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Jul 25 2019 15:15:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EPaging all digital forensicators, incident responders, and memory manager enthusiasts! Have you ever found yourself at a client site working around the clock to extract evil from a Windows 10 image? Have you hit the wall at \u003Ci\u003Estep zero\u003C\/i\u003E, running into difficulties viewing a process tree, or enumerating kernel modules? Or even worse, had to face the C-Suite and let them know you couldn\u2019t find any evil? Well fear no more\u0026nbsp;\u2013 FLARE has you covered. We\u0027ve analyzed Windows 10 and integrated our research into \u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003EVolatility\u003C\/span\u003E\u003C\/b\u003E\u0026nbsp;and\u0026nbsp;\u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003ERekall\u003C\/span\u003E\u003C\/b\u003E tools for your immediate consumption!\u003C\/p\u003E\n\u003Cp\u003EUntil August 2013, as a skilled consultant, you were generally in good shape. Your tools worked as you expected them to and you were able to forensicate rapidly. Windows 8.1 introduced changes that began to break the tools we know and love. This breakdown largely went unnoticed as most companies continued using Windows 7, but now corporate environments are rolling out Windows 10 images at an ever-increasing pace and forensic tools haven\u2019t kept up.\u003C\/p\u003E\n\u003Cp\u003EThis blog post is the first in a three-part series covering our Windows 10 memory forensics research. This post coincides with Omar Sardar and Blaine Stancill\u2019s presentation at \u003Ca href=\u0022https:\/\/www.sans.org\/event\/digital-forensics-summit-2019\/summit-agenda\u0022\u003ESANS DFIR Austin 2019\u003C\/a\u003E and is designed to introduce you to FLARE\u2019s updates to \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_volatility\u0022\u003EVolatility\u003C\/a\u003E and \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_rekall\u0022\u003ERekall\u003C\/a\u003E. The next post will coincide with our \u003Ca href=\u0022https:\/\/www.blackhat.com\/us-19\/briefings\/schedule\/#paging-all-windows-geeks--finding-evil-in-windows--compressed-memory-15582\u0022\u003EBlackHat USA 2019\u003C\/a\u003E presentation, in which Omar Sardar and Dimiter Andonov will dig into the nitty-gritty details of the Windows 10 memory manager. The final post will serve as a guide to those seeking to analyze the kernel on their own.\u003C\/p\u003E\n\u003Ch4\u003EOverview\u003C\/h4\u003E\n\u003Cp\u003ETraditionally, a complete Windows memory analysis only required forensic tools to parse physical memory and fill in any missing gaps from the pagefile. In Windows 8.1 Microsoft upended this paradigm with the introduction of memory compression and a new virtual store designed to contain compressed memory. While current tools can inspect traditional pagefiles on disk just fine, the virtual store poses a challenge due to sparse documentation and data compression.\u003C\/p\u003E\n\u003Cp\u003ETo enable a more complete memory analysis on Windows 10, FireEye\u2019s FLARE team analyzed the operating system\u2019s memory manager as well as the algorithms and structures used to retrieve compressed memory. The memory we\u2019re looking for is stored in a virtual store, created by the Store Manager kernel component. The Store Manager is responsible for managing data involved in performance optimization systems, including SuperFetch, ReadyBoost, and ReadyDrive. In this case, the Virtual Store is a RAM-backed entity, leveraging storage space in \u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003EMemCompression\u003C\/span\u003E\u003C\/b\u003E\u0026nbsp;for processes\u2019 compressed data. The results of this research have been ported to both Volatility and Rekall to benefit the security community.\u003C\/p\u003E\n\u003Ch4\u003EVolatility and Rekall\u003C\/h4\u003E\n\u003Cp\u003E\u003Ca href=\u0022https:\/\/github.com\/fireeye\/win10_volatility\u0022 adhocenable=\u0022false\u0022\u003EVolatility\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/github.com\/fireeye\/win10_rekall\u0022 adhocenable=\u0022false\u0022\u003ERekall\u003C\/a\u003E are two of the most popular open-source memory forensic frameworks available. With the introduction of Windows memory compression, both frameworks have been unable to read compressed pages \u2013 until now! The effects of compression were immediately noticeable as many plugins previously reported missing data or did not work altogether. To demonstrate, we will utilize a common plugin called \u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003Emodules\u003C\/span\u003E\u003C\/b\u003E that lists drivers loaded at the time of memory capture. In Figure 1, drivers loaded on the system are enumerated, but several paths to the files on disk are paged out to the compression store. These missing paths could very well be the evil you were hunting!\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/rampack1\/Picture1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Volatility \u0026amp; Rekall missing data stored in compressed pages\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ETo deal with missing data due to compressed pages, FireEye\u0027s FLARE team made multiple additions to \u003Ca href=\u0022https:\/\/github.com\/fireeye\/win10_volatility\u0022\u003EVolatility\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/github.com\/fireeye\/win10_rekall\u0022\u003ERekall\u003C\/a\u003E to support Windows 10 memory compression. First and foremost, we added the necessary overlays:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003E\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_rekall\/blob\/win10_compressed_memory\/rekall-core\/rekall\/plugins\/overlays\/windows\/win10_memcompression.py\u0022\u003Ewin10_rekall\/rekall-core\/rekall\/plugins\/overlays\/windows\/win10_memcompression.py\u003C\/a\u003E\u003C\/li\u003E\n\u003Cli\u003E\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_volatility\/blob\/win10_compressed_memory\/volatility\/plugins\/overlays\/windows\/win10_memcompression.py\u0022\u003Ewin10_volatility\/volatility\/plugins\/overlays\/windows\/win10_memcompression.py\u003C\/a\u003E\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EAn overlay describes the internal data structures used by the Windows 10 memory compression algorithm and makes them available in Python. For example, the overlays define the layout of the \u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003ESMKM_STORE\u003C\/span\u003E\u003C\/b\u003E structure and the \u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003EB+Trees\u003C\/span\u003E\u003C\/b\u003E used to lookup compressed pages. These structures, among others, will be described in additional detail in Part Two of this blog series.\u003C\/p\u003E\n\u003Cp\u003EThe undocumented Windows structures defined in the overlays are based on information we obtained through analyzing different versions of Windows 10. Being undocumented, these structures are susceptible to change across Windows builds, and even revisions. We currently support versions 1607, 1703, 1709, 1803, and 1809 on both 32-bit and 64-bit architectures. To support additional versions, the layout of the structures must be analyzed and the overlays updated accordingly. Analyzing the kernel to extract these structures will be discussed further in both Part Two and Part Three of this blog series.\u003C\/p\u003E\n\u003Cp\u003EThe second modification to support compressed pages includes new address spaces for each framework:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003E\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_rekall\/blob\/win10_compressed_memory\/rekall-core\/rekall\/plugins\/windows\/win10_memcompression.py\u0022\u003Ewin10_rekall\/rekall-core\/rekall\/plugins\/windows\/win10_memcompression.py\u003C\/a\u003E\u003Cul\u003E\n\u003Cli\u003EWindowsIA32CompressedPagedMemoryPae\u003C\/li\u003E\n\u003Cli\u003EWindowsAMD64CompressedPagedMemory\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003Cli\u003E\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_volatility\/blob\/win10_compressed_memory\/volatility\/plugins\/addrspaces\/win10_memcompression.py\u0022\u003Ewin10_volatility\/volatility\/plugins\/addrspaces\/win10_memcompression.py\u003C\/a\u003E\u003Cul\u003E\n\u003Cli\u003EWin10CompressedIA32PagedMemoryPae\u003C\/li\u003E\n\u003Cli\u003EWin10CompressedIA32PagedMemory\u003C\/li\u003E\n\u003Cli\u003EWin10CompressedAMD64PagedMemory\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EAddress spaces are responsible for satisfying memory read requests. When stacked on top of one another, each layer can translate the read request to an underlying base layer abstracting away the details of how the actual read is performed. An example translation is converting a virtual address to a physical address. Depending on the bottommost layer, the physical address may be an offset into a memory image, crash dump, or hibernate file. The takeaway is that an address space transparently resolves memory, regardless of its location and\u0026nbsp;\u2013 most importantly\u0026nbsp;\u2013 with zero effort on your part. Due to this seamless integration, users can interact with Volatility and Rekall just as before and, if a compressed page is detected, the new address spaces will take care of decompression in the background and return the decompressed data.\u003C\/p\u003E\n\u003Cp\u003EBack to our previous \u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003Emodules\u003C\/span\u003E\u003C\/b\u003E plugin example, Figure 2 demonstrates how the newly implemented address spaces properly decompress data located in compressed pages. No more hidden drivers or DLLs, among a plethora of other forensic artifacts. The data is now yours to continue your hunt for evil!\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/rampack1\/Picture2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Volatility \u0026amp; Rekall decompressing compressed data\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EGet It Today\u003Ci\u003E\u003C\/i\u003E\u003C\/h4\u003E\n\u003Cp\u003EHead over to our \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_volatility\u0022\u003EVolatility\u003C\/a\u003E and \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/win10_rekall\u0022\u003ERekall\u003C\/a\u003E GitHub repositories to start using them today. After downloading or cloning the repositories, follow any necessary installation instructions as outlined on each GitHub\u0027s \u003Cb\u003E\u003Cspan class=\u0022code\u0022\u003EREADME\u003C\/span\u003E\u003C\/b\u003E page and start finding that evil!\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EWindows 10 memory compression is a significant evolution in the design of the memory manager that increases system performance by making a more efficient use of physical memory. This increase in performance comes at the cost of a more complex memory management system that is currently not publicly documented. Up until now, Volatility and Rekall were unable to inspect memory stored in compressed pages, opening the door to malicious programs and forensics artifacts going undetected. FireEye\u2019s FLARE team hopes to fill the knowledge and technical gaps for Windows 10 compressed memory through contributions to Volatility and Rekall, as well as in presentations given at \u003Ca href=\u0022https:\/\/www.sans.org\/event\/digital-forensics-summit-2019\/summit-agenda\u0022\u003ESANS DIFR (Finding Evil in Windows 10 Compressed Memory)\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/www.blackhat.com\/us-19\/briefings\/schedule\/#paging-all-windows-geeks--finding-evil-in-windows--compressed-memory-15582\u0022\u003EBlackHat USA 2019\u003C\/a\u003E. We look forward to seeing you there and hearing your feedback, and we\u2019re excited to see how these frameworks develop as a result of our contributions! Stay tuned for Part Two of our Finding Evil in Windows 10 Compressed Memory blog series.\u003C\/p\u003E\n",
        "jcr:lastModified": "Mon Aug 12 2019 11:27:09 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003ELearn more about\u0026nbsp;FLARE\u2019s updates to Volatilty and Rekall.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Jul 24 2019 13:49:15 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Jul 25 2019 14:58:51 GMT-0400",
      "imageRotate": "0"
    }
  }
}
