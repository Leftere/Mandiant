{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Fri Mar 15 2019 12:07:59 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Dissecting a NETWIRE Phishing Campaign\u0027s Usage of Process Hollowing",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "0d53e6b6-6016-4054-8811-bce26ad17a7b",
    "author": "Sumith Maniath",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "bbde4587-c458-43cf-9ebd-7730bb79bc6d"
    ],
    "jcr:created": "Fri Mar 15 2019 13:33:34 GMT-0400",
    "cq:lastReplicated": "Fri Mar 15 2019 13:33:34 GMT-0400",
    "cq:lastModified": "Fri Mar 15 2019 13:33:25 GMT-0400",
    "jcr:baseVersion": "bbde4587-c458-43cf-9ebd-7730bb79bc6d",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:sumith-maniath",
      "fireeye-blog-authors:prashanth-krushna-kadam",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:phishing",
      "fireeye-blog-tags:powershell-attacks"
    ],
    "jcr:uuid": "7d8d2cfc-7e2b-453f-bb32-a7974179cb03",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Fri Mar 15 2019 12:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Ch4\u003EIntroduction\u003C\/h4\u003E\n\u003Cp\u003EMalware authors attempt to evade detection by executing their payload without having to write the executable file on the disk. One of the most commonly seen techniques of this \u0026quot;fileless\u0026quot; execution is code injection. Rather than executing the malware directly, attackers inject the malware code into the memory of another process that is already running.\u003C\/p\u003E\n\u003Cp\u003EDue to its presence on all Windows 7 and later machines and the sheer number of supported features, PowerShell has been a favorite tool of attackers for some time. FireEye has published multiple reports where \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.fireeye.com\/content\/dam\/fireeye-www\/global\/en\/solutions\/pdfs\/wp-lazanciyan-investigating-powershell-attacks.pdf\u0022\u003EPowerShell was used\u003C\/a\u003E during initial malware delivery or during post-exploitation activities. Attackers have abused PowerShell to easily interact with other Windows components to perform their activities with stealth and speed.\u003C\/p\u003E\n\u003Cp\u003EThis blog post explores a recent phishing campaign observed in February 2019, where an attacker targeted multiple customers and successfully executed their payload without having to write the executable dropper or the payload\u003Ci\u003E \u003C\/i\u003Eto the disk. The campaign involved the use of VBScript, PowerShell and the .NET framework to perform a code injection attack using a process hollowing technique. The attacker abused the functionality of loading .NET assembly directly into memory of PowerShell to execute malicious code without creating any PE files on the disk.\u003C\/p\u003E\n\u003Ch4\u003EActivity Summary\u003C\/h4\u003E\n\u003Cp\u003EThe user is prompted to open a document stored on Google Drive. The name of the file, shown in Figure 1, suggests that the actor was targeting members of the airline industry that use a particular aircraft model. We have observed an increasing number of attackers relying on cloud-based file storage services that bypass firewall restrictions to host their payload.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Malicious script hosted on Google Drive\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAs seen in Figure 2, attempting to open the script raises an alert from Internet Explorer saying that the publisher could not be verified. In our experience, many users will choose to ignore the warning and open the document.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Alert raised by Internet Explorer\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EUpon execution, after multiple levels of obfuscation, a PowerShell script is executed that loads a .NET assembly from a remote URL, functions of which are then used to inject the final payload (NETWIRE Trojan) into a benign Microsoft executable using process hollowing. This can potentially bypass application whitelisting since all processes spawned during the attack are legitimate Microsoft executables.\u003C\/p\u003E\n\u003Ch4\u003ETechnical Details\u003C\/h4\u003E\n\u003Cp\u003EThe initial document contains VBScript code. When the user opens it, Wscript is spawned by iexplore to execute this file. The script uses multiple layers of obfuscation to bypass static scanners, and ultimately runs a PowerShell script for executing the binary payload.\u003C\/p\u003E\n\u003Cp\u003EObfuscation techniques used during different levels of script execution are shown in Figure 3 and Figure 4.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Type 1 obfuscation technique, which uses log functions to resolve a wide character\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Type 2 obfuscation technique, which uses split and replace operations\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis script then downloads and executes another encoded .vbs script from a paste.ee URL, as seen in Figure 5. Paste.ee is a less regulated alternative to Pastebin and we have seen multiple attacks using this service to host the payload. Since the website uses TLS, most firewall solutions cannot detect the malicious content being downloaded over the network.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Downloading the second-stage script and creating a scheduled task\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe script achieves persistence by copying itself to Appdata\/Roaming and using schtasks.exe to create a scheduled task that runs the VBScript every 15 minutes.\u003C\/p\u003E\n\u003Cp\u003EAfter further de-obfuscation of the downloaded second-stage VBScript, we obtain the PowerShell script that is executed through a shell object, as shown in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: De-obfuscated PowerShell script\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe PowerShell script downloads two Base64-encoded payloads from paste.ee that contain binary executable files. The strings are stored as PowerShell script variables and no files are created on disk. \u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003EMicrosoft has provided multiple ways of interacting with the .NET framework in PowerShell to enhance it through custom-developed features. These .NET integrations with PowerShell are particularly attractive to attackers due to the limited visibility that traditional security monitoring tools have around the runtime behaviors of .NET processes. For this reason, exploit frameworks such as CobaltStrike and Metasploit have options to generate their implants in .NET assembly code.\u003C\/p\u003E\n\u003Cp\u003EHere, the attackers have used the \u003Ci\u003ELoad\u003C\/i\u003E method from the \u003Ci\u003ESystem.Reflection.Assembly\u003C\/i\u003E .NET Framework class. After the assembly is loaded as an instance of \u003Ci\u003ESystem.Reflection.Assembly\u003C\/i\u003E, the members can be accessed through that object similarly to C#, as shown in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Formatted PowerShell code\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe code identifies the installed version of .NET and uses it later to dynamically resolve the path to the .NET installation folder. The decoded dropper assembly is passed as an argument to the \u003Ci\u003ELoad\u003C\/i\u003E method. The resulting class instance is stored as a variable.\u003C\/p\u003E\n\u003Cp\u003EThe objects of the dropper are accessed through this variable and method \u003Ci\u003ER\u003C\/i\u003E is invoked. Method \u003Ci\u003ER\u003C\/i\u003E of the .NET dropper is responsible for executing the final payload.\u003C\/p\u003E\n\u003Cp\u003EThe following are the parameters for method \u003Ci\u003ER:\u003C\/i\u003E\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EPath to InstallUtil.exe (or other .NET framework tools)\u003C\/li\u003E\n\u003Cli\u003EDecoded NETWIRE trojan\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EWhen we observed the list of processes spawned during the attack (Figure 8), we did not see the payload spawned as a separate process. \u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Processes spawned during attack\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe observed that the InstallUtil.exe process was being created in suspended mode. Once it started execution, we compared its memory artifacts to a benign execution of InstallUtil.exe and concluded that the malicious payload is being injected into the memory of the newly spawned InstallUtil.exe process. We also observed that no arguments are passed to InstallUtil, which would cause an error under normal execution since InstallUtil always expects at least one argument.\u003C\/p\u003E\n\u003Cp\u003EFrom a detection evasion perspective, the attacker has chosen an interesting approach. Even if the PowerShell process creation is detected, InstallUtil.exe is executed from its original path. Furthermore, InstallUtil.exe is a benign file often used by internal automations. To an unsuspecting system administrator, this might not seem malicious.\u003C\/p\u003E\n\u003Cp\u003EWhen we disassembled the .NET code and removed the obfuscation to understand how code injection was performed, we were able to identify Windows win32 API calls associated with process hollowing (Figure 9).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture9.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Windows APIs used in .NET dropper for process hollowing\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAfter reversing and modifying the code of the C# dropper to invoke \u003Ci\u003ER\u003C\/i\u003E from main, we were able to confirm that when the method \u003Ci\u003ER\u003C\/i\u003E is invoked, InstallUtil.exe is spawned in suspended mode. The memory blocks of the suspended process are unmapped and rewritten with the sections of the payload program passed as an argument to method \u003Ci\u003ER.\u003C\/i\u003E The thread is allowed to continue after changes have been made to the entry point. When the process hollowing is complete, the parent PowerShell process is terminated.\u003C\/p\u003E\n\u003Ch4\u003EHigh-Level Analysis of the Payload\u003C\/h4\u003E\n\u003Cp\u003EThe final payload was identified by FireEye Intelligence as a NETWIRE backdoor. The backdoor receives commands from a command and control (C2) server, performs reconnaissance that includes the collection of user data, and returns the information to the C2 server.\u003C\/p\u003E\n\u003Cp\u003ECapabilities of the NETWIRE backdoor include key logging, reverse shell, and password theft. The backdoor uses a custom encryption algorithm to encrypt data and then writes it to a file created in the .\/LOGS directory.\u003C\/p\u003E\n\u003Cp\u003EThe malware also contains a custom obfuscation algorithm to hide registry keys, APIs, DLL names, and other strings from static analysis. Figure 10 provides the decompiled version of the custom decoding algorithm used on these strings.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fileless\/Picture10.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Decompiled string decoding algorithm\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFrom reversing and analyzing the behavior of the malware, we were able to identify the following capabilities:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003ERecord mouse and keyboard events\u003C\/li\u003E\n\u003Cli\u003ECapture session logon details\u003C\/li\u003E\n\u003Cli\u003ECapture system details\u003C\/li\u003E\n\u003Cli\u003ETake screenshots\u003C\/li\u003E\n\u003Cli\u003EMonitor CPU usage\u003C\/li\u003E\n\u003Cli\u003ECreate fake HTTP proxy\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EFrom the list of decoded strings, we were able to identify other features of this sample:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022312\u0022\u003E\u003Cp\u003E\u003Ci\u003E\u201cPOP3\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201cIMAP\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201cSMTP\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201cHTTP\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u0026quot;Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows Messaging Subsystem\\\\Profiles\\\\Outlook\\\\\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u0026quot;Software\\\\Microsoft\\\\Office\\\\15.0\\\\Outlook\\\\Profiles\\\\Outlook\\\\\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u0026quot;Software\\\\Microsoft\\\\Office\\\\16.0\\\\Outlook\\\\Profiles\\\\Outlook\\\\\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022289\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003EStealing data from an email client\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022312\u0022\u003E\u003Cp\u003E\u003Ci\u003E\u201c\\Google\\Chrome\\User Data\\Default\\Login Data\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201c\\Chromium\\User Data\\Default\\Login Data\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201c\\Comodo\\Dragon\\User Data\\Default\\Login Data\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201c\\Yandex\\YandexBrowser\\User Data\\Default\\Login Data\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201c\\Opera Software\\Opera Stable\\Login Data\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201cSoftware\\Microsoft\\Internet Explorer\\IntelliForms\\Storage2\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201cvaultcli.dll:\u003C\/i\u003E \u003Ci\u003EVaultOpenVault,VaultCloseVault,VaultEnumerateItem,VaultGetItem,VaultFree\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Ci\u003E\u201cselect *\u0026nbsp; from moz_login\u201d\u003C\/i\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022289\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003EStealing login details from browsers\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EA complete report on the NETWIRE backdoor family is available to customers who subscribe to the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/intelligence.fireeye.com\/sign_in\u0022\u003EFireEye Intelligence portal\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch4\u003EIndicators of Compromise\u003C\/h4\u003E\n\u003Cp\u003EHost-based indicators:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022300\u0022\u003E\u003Cp\u003Edac4ed7c1c56de7d74eb238c566637aa\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022298\u0022\u003E\u003Cp\u003EInitial attack vector .vbs file\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003ENetwork-based indicators:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022302\u0022\u003E\u003Cp\u003E178.239.21.]62:1919\u003C\/p\u003E\n\u003Cp\u003Ekingshakes[.]linkpc[.]net\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003E105.112.35[.]72:3575\u003C\/p\u003E\n\u003Cp\u003Ehomi[.]myddns[.]rocks\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022297\u0022\u003E\u003Cp\u003EC2 domains of NETWIRE Trojan\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Ch4\u003EFireEye Detection\u003C\/h4\u003E\n\u003Cp\u003EFireEye detection names for the indicators in the attack:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022299\u0022\u003E\u003Cp\u003EEndpoint security\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022299\u0022\u003E\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EExploit Guard: Blocks execution of wscript\u003C\/li\u003E\n\u003Cli\u003EIOC: POWERSHELL DOWNLOADER D (METHODOLOGY)\u003C\/li\u003E\n\u003Cli\u003EAV: Trojan.Agent.DRAI\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022299\u0022\u003E\u003Cp\u003ENetwork Security\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022299\u0022\u003E\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EBackdoor.Androm\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022299\u0022\u003E\u003Cp\u003EEmail Security\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022299\u0022\u003E\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EMalicious.URL\u003C\/li\u003E\n\u003Cli\u003EMalware.Binary.vbs\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EMalware authors continue to use different \u0026quot;fileless\u0026quot; process execution techniques to reduce the number of indicators on an endpoint. The lack of visibility into .NET process execution combined with the flexibility of PowerShell makes this technique all the more effective.\u003C\/p\u003E\n\u003Cp\u003EFireEye Endpoint Security and the FireEye Network Security detect and block this attack at several stages of the attack chain.\u003C\/p\u003E\n\u003Ch4\u003EAcknowledgement\u003C\/h4\u003E\n\u003Cp\u003EWe would like to thank Frederick House, Arvind Gowda, Nart Villeneuve and Nick Carr for their valuable feedback.\u003C\/p\u003E\n",
        "jcr:lastModified": "Fri Mar 15 2019 11:22:15 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EIn a recent phishing campaign, an attacker was able to execute a payload without writing anything to disk.\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Mar 14 2019 14:52:08 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Fri Mar 15 2019 13:33:25 GMT-0400",
      "imageRotate": "0"
    }
  }
}
