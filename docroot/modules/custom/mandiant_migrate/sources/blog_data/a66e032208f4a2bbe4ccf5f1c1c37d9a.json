{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Thu Jan 11 2018 11:43:22 GMT-0500",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "FLARE IDA Pro Script Series: Simplifying Graphs in IDA",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "e55b84ef-08a0-466b-91a4-3c2bb02cd1de",
    "author": "Jay Smith",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "3e94cc74-6c21-46b8-9368-30ff3598f713"
    ],
    "jcr:created": "Wed May 08 2019 18:14:59 GMT-0400",
    "cq:lastReplicated": "Wed May 08 2019 18:14:58 GMT-0400",
    "cq:lastModified": "Wed May 08 2019 18:14:50 GMT-0400",
    "jcr:baseVersion": "3e94cc74-6c21-46b8-9368-30ff3598f713",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:cap-jay-smith",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:ida-pro",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "3e2fce24-e489-4e1a-bb55-071925eb3fcb",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Jan 11 2018 11:45:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Ch4\u003EIntroduction\u003C\/h4\u003E\n\u003Cp\u003EWe\u2019re proud to release a new plug-in for IDA Pro users\u0026nbsp;\u2013 SimplifyGraph\u0026nbsp;\u2013 to help automate creation of groups of nodes in the IDA\u2019s disassembly graph view. Code and binaries are available from the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/SimplifyGraph\u0022\u003EFireEye GitHub repo\u003C\/a\u003E. Prior to this release we submitted it in the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.hex-rays.com\/contests\/2017\/index.shtml\u0022\u003E2017 Hex-Rays plugin contest\u003C\/a\u003E, where it placed third\u0026nbsp;overall.\u003C\/p\u003E\n\u003Cp\u003EMy personal preference is to use IDA\u2019s graph mode when doing the majority of my reverse engineering. It provides a graphical representation of the control flow graph and gives visual cues about the structure of the current function that helps me better understand the disassembly.\u003C\/p\u003E\n\u003Cp\u003EGraph mode is great until the function becomes complex. IDA is often forced to place adjacent nodes relatively far apart, or have edges in the graph cross and have complex paths. Using the overview graph becomes extremely difficult due to the density of nodes and edges, as seen in Figure 1.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: An annoying function\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIDA has a built-in mechanism to help simplify graphs: creating groups of nodes, which replaces all of the selected nodes with a new group node representative. This is done by selecting one or more nodes, right-clicking, and selecting \u201cGroup nodes\u201d, as shown in Figure 2. Doing this manually is certainly possible, but it becomes tedious to follow edges in complex graphs and correctly select all of the relevant nodes without missing any, and without making mistakes.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Manual group creation\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe SimplifyGraph IDA Pro plug-in we\u2019re releasing is built to automate IDA\u2019s node grouping capability. The plug-in is source-compatible with the legacy IDA SDK in 6.95, and has been ported to the new SDK for IDA 7.0. Pre-built binaries for both are available on the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/SimplifyGraph\u0022\u003EReleases tab for the project repository\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EThe plug-in has several parts, which are introduced below. By combining these together it\u2019s possible to isolate parts of a control flow graph for in-depth reverse engineering, allowing you to look at Figure 3 instead of Figure 1.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Isolated subgraph to focus on\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ECreate Unique-Reachable (UR) Subgraph\u003C\/h4\u003E\n\u003Cp\u003EUnique-Reachable nodes are all nodes reachable in the graph from a given start node and that are not reachable from any nodes not currently in the UR set. For example, in Figure 4, all of the Unique-Reachable nodes starting at the green node are highlighted in blue. The grey node is reachable from the green node, but because it is reachable from other nodes not in the current UR set it is pruned prior to group creation.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Example Unique Reachable selection\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe plug-in allows you to easily create a new group based on the UR definition. Select a node in IDA\u0026#39;s graph view to be the start of the reachable search. Right click and select \u0026quot;SimplifyGraph -\u0026gt; Create unique-reachable group\u0026quot;. The plug-in performs a graph traversal starting at this node, identifies all reachable nodes, and prunes any nodes (and their reachable nodes) that have predecessor nodes not in the current set. It then prompts you for the node text to appear in the new group node.\u003C\/p\u003E\n\u003Cp\u003EIf you select more than one node (by holding the Ctrl key when selecting nodes) for the UR algorithm, each additional node acts as a sentry node. Sentry nodes will not be included in the new group, and they halt the graph traversal when searching for reachable nodes. For example, in Figure 5, selecting the green node first treats it as the starting node, and selecting the red node second treats it as a sentry node. Running the \u201cCreate unique-reachable group\u201d plug-in option creates a new group made of the green node and all blue nodes. This can be useful when you are done analyzing a subset of the current graph, and wish to hide the details behind a group node so you can concentrate on the rest of the graph.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Unique reachable with sentry\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe UR algorithm operates on the currently visible graph, meaning that you can run the UR algorithm repeatedly and nest groups.\u003C\/p\u003E\n\u003Ch4\u003ESwitch Case Groups Creation\u003C\/h4\u003E\n\u003Cp\u003ESwitch statements implemented as jump tables appear in the graph as nodes with a large fan-out, as shown in Figure 6. The SimplifyGraph plug-in detects when the currently selected node has more than two successor nodes and adds a right-click menu option \u201cSimplifyGraph -\u0026gt; Create switch case subgraphs\u201d. Selecting this runs the Unique-Reachable algorithm on each separate case branch and automatically uses IDA\u2019s branch label as the group node text.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Switch jumptable use\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 7 shows a before and after graph overview of the same function when the switch-case grouping is run.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Before and after of switch statement groupings\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EIsolated Subgraphs\u003C\/h4\u003E\n\u003Cp\u003ERunning Edit -\u0026gt; Plugins -\u0026gt; SimplifyGraph brings up a new chooser named \u0026quot;SimplifyGraph - Isolated subgraphs\u0026quot; that begins showing what I call isolated subgraphs of the current graph, as seen in Figure 8.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Example isolated subgraphs chooser\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EA full definition appears later in the appendix including how these are calculated, but the gist is that an isolated subgraph in a directed graph is a subset of nodes and edges such that there is a single entrance node, a single exit node, and none of the nodes (other than the subgraph entry node) is reachable by nodes not in the subgraph.\u003C\/p\u003E\n\u003Cp\u003EFinding isolated subgraphs was originally researched to help automatically identify inline functions. It does this, but it turns out that this graph construct occurs naturally in code without inline functions. This isn\u2019t a bad thing as it shows a natural grouping of nodes that could be a good candidate to group to help simplify the overall graph and make analysis easier.\u003C\/p\u003E\n\u003Cp\u003EOnce the chooser is active, you can double click (or press Enter) on a row in the chooser to highlight the nodes that make up the subgraph, as seen in Figure 9.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig9.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Highlighted isolated subgraph\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EYou can create a group for an isolated subgraph by:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003ERight-clicking on the chooser row and selecting \u0026quot;Create group\u0026quot;, or pressing Insert while a row is selected.\u003C\/li\u003E\n\u003Cli\u003ERight-clicking in a highlighted isolated subgraph node and selecting \u0026quot;SimplifyGraph -\u0026gt; Create isolated subgraph\u0026quot;.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EDoing either of these prompts you for text for the new graph node to create.\u003C\/p\u003E\n\u003Cp\u003EIf you manually create\/delete groups using IDA you may need to refresh the chooser\u0026#39;s knowledge of the current function groups (right-click and select \u0026quot;Refresh groups\u0026quot; in the chooser). You can right click in the chooser and select \u0026quot;Clear highlights\u0026quot; to remove the current highlights. As you navigate to new functions the chooser updates to show isolated subgraphs in the current function. Closing the chooser removes any active highlights. Any custom colors you applied prior to running the plug-in are preserved and reapplied when the current highlights are removed.\u003C\/p\u003E\n\u003Cp\u003EIsolated subgraph calculations operates on the original control flow graph, so isolated subgroups can\u0026#39;t be nested. As you create groups, rows in the chooser turn red indicating a group already exists, or can\u0026#39;t be created because there is an overlap with an existing group.\u003C\/p\u003E\n\u003Cp\u003EAnother note: this calculation does not currently work on functions that do not return (those with an infinite loop). See the Appendix for details.\u003C\/p\u003E\n\u003Ch4\u003EGraph Complement\u003C\/h4\u003E\n\u003Cp\u003ECreating groups to simplify the overall control flow graph is nice, but it doesn\u2019t help understand the details of a group that you create. To assist with this, the last feature of the plug-in hides everything but the group you\u2019re interested in allowing you to focus on your reverse engineering. Right clicking on a collapsed group node, or a node that that belongs to an uncollapsed group (as highlighted by IDA in yellow), brings up the plug-in option \u201cComplement \u0026amp; expand group\u201d and \u201cComplement group\u201d, respectively. When this runs the plug-in creates a group of all nodes other than the group you\u2019re interested in. This has the effect of hiding all graph nodes that you aren\u2019t currently examining and allows you to better focus on analysis of the current group. As you can see, we\u2019re abusing group creation a bit so that we can avoid creating a custom graph viewer, and instead stay within the built-in IDA graph disassembly view which allows us to continue to markup the disassembly as you\u2019re used to.\u003C\/p\u003E\n\u003Cp\u003EComplementing the graph gives you the view seen in Figure 10, where the entire graph is grouped into a node named \u201cComplement of group X\u201d. When you\u2019re done analyzing the current group, right click on the complement node and select IDA\u2019s \u201cUngroup nodes\u201d command.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig10.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Group complement\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EExample Workflow\u003C\/h4\u003E\n\u003Cp\u003EAs an example that exercises the plug-in, let\u2019s revisit the function in Figure 1. This is a large command-and-control dispatch function for a piece of malware. It contains a large if-else-if series of inlined strcmp comparisons that branch to the logic for each command when the input string matches the expected command.\u003C\/p\u003E\n\u003Col style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EFind all of the inline strcmp\u2019s and create groups for those. Run Edit -\u0026gt; Plugins -\u0026gt; SimplifyGraph to bring up the plug-in chooser. In this function nearly every isolated subgraph is a 7-node inlined strcmp implementation. Go through in the chooser to verify, and create a group. This results in a graph similar to Figure 11.\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig11.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Grouped strcmp\u003Cbr\u003E\n \u003C\/span\u003E\u003Cbr\u003E\n\u003C\/li\u003E\n\u003Cli\u003EWhen an input string matches a command string, the malware branches to code that implements the command. To further simplify the graph and make analysis easier, run the Unique-Reachable algorithm on each separate command by right clicking on the first node after each string-comparison and selecting SimplifyGraph -\u0026gt; Create unique-reachable group. After this we now have a graph as in Figure 12.\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig12.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: Grouped command logic\u003Cbr\u003E\n \u003C\/span\u003E\u003Cbr\u003E\n\u003C\/li\u003E\n\u003Cli\u003ENow perform your reverse engineering on each separate branch in the dispatch function. For each command handler group node that we created, right click that node and select \u201cSimplifyGraph -\u0026gt; Complement \u0026amp; expand group\u201d. A result of complementing a single command handler node is shown in Figure 13, which is much easier to analyze.\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig13.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 13: Group complement\u003Cbr\u003E\n \u003C\/span\u003E\u003Cbr\u003E\n\u003C\/li\u003E\n\u003Cli\u003EWhen done analyzing the current command handler, delete the complement group by right clicking the \u201cComplement of group X\u201d node and use IDA\u2019s built-in \u201cUngroup nodes\u201d command. Repeat for the remaining command handler grouped nodes.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch4\u003EConfig\u003C\/h4\u003E\n\u003Cp\u003EYou can tweak some of the configuration by entering data in a file named %IDAUSR%\/SimplifyGraph.cfg, where %IDAUSR% is typically %APPDATA%\/Hex-Rays\/IDA Pro\/ unless explicitly set to something else. All of the config applies to the isolated subgraph component. Options:\u003C\/p\u003E\n\u003Cp\u003E* SUBGRAPH_HIGHLIGHT_COLOR: Default 0xb3ffb3: The color to apply to nodes when you double click\/press enter in the chooser to show nodes that make up the currently selected isolated subgraph. Not everyone agrees that my IDA color scheme is best, so you can set your own highlight color here.\u003C\/p\u003E\n\u003Cp\u003E* MINIMUM_SUBGRAPH_NODE_COUNT: Default 3: The minimum number of nodes for a valid isolated subgraph. If a discovered subgraph has fewer nodes than this number it is not included in the shown list. This prevents trivial two-node subgraphs from being shown.\u003C\/p\u003E\n\u003Cp\u003E* MAXIMUM_SUBGRAPH_NODE_PERCENTAGE: Default 95: The maximum percent of group nodes (100.0 *(subgroup_node_count \/ total_function_node_count)) allowed. This filters out isolated subgraphs that make up (nearly) the entire function, which are typically not interesting.\u003C\/p\u003E\n\u003Cp\u003EExample SimplifyGraph.cfg contents\u003C\/p\u003E\n\u003Cp\u003E```\u003C\/p\u003E\n\u003Cp\u003E\u0026quot;MINIMUM_SUBGRAPH_NODE_COUNT\u0026quot;=5\u003C\/p\u003E\n\u003Cp\u003E\u0026quot;MAXIMUM_SUBGRAPH_NODE_PERCENTAGE\u0026quot;=75\u003C\/p\u003E\n\u003Cp\u003E\u0026quot;SUBGRAPH_HIGHLIGHT_COLOR\u0026quot;=0x00aa1111\u003C\/p\u003E\n\u003Cp\u003E```\u003C\/p\u003E\n\u003Cp\u003EPrior work:\u003C\/p\u003E\n\u003Cp\u003EI came across semi-related work while working on this: \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/lallousx86\/GraphSlick\u0022\u003EGraphSlick\u003C\/a\u003E from the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.hex-rays.com\/contests\/2014\/index.shtml\u0022\u003E2014 Hex-Rays contest\u003C\/a\u003E.\u0026nbsp;That plug-in had different goals to automatically identifying (nearly) identical inline functions via CFG and basic block analysis, and patching the program to force mock function calls to the explicit function. It had a separate viewer to present information to the user.\u003C\/p\u003E\n\u003Cp\u003ESimplifyGraph is focused on automating tasks when doing manual reverse engineering (group creation) to reduce the complexity of disassembly in graph mode. Future work may incorporate the same prime-products calculations to help automatically identify isolated subgraphs.\u003C\/p\u003E\n\u003Ch4\u003EInstallation\u003C\/h4\u003E\n\u003Cp\u003EPrebuilt Windows binaries are available from the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/SimplifyGraph\u0022\u003EReleases tab of the GitHub project page\u003C\/a\u003E. The ZIP files contain both IDA 32 and IDA 64 plug-ins for each of the new IDA 7.0 SDK and for the legacy IDA 6.95 SDK. Copy the two plug-ins for your version of IDA to the %IDADIR%\\plugins directory.\u003C\/p\u003E\n\u003Ch4\u003EBuilding\u003C\/h4\u003E\n\u003Cp\u003EThis plug-in \u0026amp; related files were built using Visual Studio 2013 Update 5.\u003C\/p\u003E\n\u003Cp\u003EEnvironment Variables Referenced by project:\u003C\/p\u003E\n\u003Cp\u003E* IDASDK695: path to the extracted IDA 6.95 SDK. This should have `include` and `lib` paths beneath it.\u003C\/p\u003E\n\u003Cp\u003E* IDASDK: path to the extracted IDA 7.0 (or newer) SDK. This Should have `include` and `lib` paths beneath it.\u003C\/p\u003E\n\u003Cp\u003E* BOOSTDIR: path to the extracted Boost library. Should have `boost` and `libs` paths beneath it.\u003C\/p\u003E\n\u003Cp\u003EThe easiest way is to use the Microsoft command-line build tools:\u003C\/p\u003E\n\u003Cp\u003E* For IDA7.0: Launch VS2013 x64 Native Tools Command Prompt, then run:\u003C\/p\u003E\n\u003Cp\u003E```\u003C\/p\u003E\n\u003Cp\u003Emsbuild SimplifyGraph.sln \/property:Configuration=ReleaseIDA70_32 \/property:Platform=x64\u003C\/p\u003E\n\u003Cp\u003Emsbuild SimplifyGraph.sln \/property:Configuration=ReleaseIDA70_64 \/property:Platform=x64\u003C\/p\u003E\n\u003Cp\u003E```\u003C\/p\u003E\n\u003Cp\u003E* For IDA6.95: Launch VS2013 x86 Native Tools Command Prompt, then run:\u003C\/p\u003E\n\u003Cp\u003E```\u003C\/p\u003E\n\u003Cp\u003Emsbuild SimplifyGraph.sln \/property:Configuration=ReleaseIDA695_32 \/property:Platform=Win32\u003C\/p\u003E\n\u003Cp\u003Emsbuild SimplifyGraph.sln \/property:Configuration=ReleaseIDA695_64 \/property:Platform=Win32\u003C\/p\u003E\n\u003Cp\u003E```\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EI hope this blog has shown the power of automatically grouping nodes within a disassembly graph view, and viewing these groups in isolation to help with your analysis. This plug-in has become a staple of my workflow, and we\u2019re releasing it to the community with the hope that others find it useful as well.\u003C\/p\u003E\n\u003Ch4\u003EAppendix: Isolated Subgraphs\u003C\/h4\u003E\n\u003Cp\u003EFinding isolated subgraphs relies on calculating the immediate dominator and immediate post-dominator trees for a given function graph.\u003C\/p\u003E\n\u003Cp\u003EA node d dominates n if every path to n must go through d.\u003C\/p\u003E\n\u003Cp\u003EThe immediate dominator p of node n is basically the closest dominator to n, where there is no node t where p dominates t, and t dominates n.\u003C\/p\u003E\n\u003Cp\u003EA node z post-dominates a node n if every path from n to the exit node must go through z.\u003C\/p\u003E\n\u003Cp\u003EThe immediate post-dominator x of node n is the closest post-dominator, where there is no node t where t post-dominates n and x post-dominates t.\u003C\/p\u003E\n\u003Cp\u003EThe immediate dominator relationship forms a tree of nodes, where every node has an immediate dominator other than the entry node.\u003C\/p\u003E\n\u003Cp\u003EThe Lengauer-Tarjan algorithm can efficiently calculate the immediate dominator tree of a graph. It can also calculate the immediate post-dominator tree by reversing the direction of each edge in the same graph.\u003C\/p\u003E\n\u003Cp\u003EThe plug-in calculates the immediate dominator tree and immediate post-dominator tree of the function control flow graph and looks for the situations where the (idom[i] == j) and (ipdom[j] == i). This means all paths from the function start to node i must go through node j, and all paths from j to the function terminal must go through i. A candidate isolated subgraph thus starts at node j and ends at node i.\u003C\/p\u003E\n\u003Cp\u003EFor each candidate isolated subgraph, the plug-in further verifies only the entry node has predecessor nodes not in the candidate subgraph. The plug-in also filters out candidate subgraphs by making sure they have a minimum node count and cover a maximum percentage of nodes (see MINIMUM_SUBGRAPH_NODE_COUNT and MAXIMUM_SUBGRAPH_NODE_PERCENTAGE in the config section).\u003C\/p\u003E\n\u003Cp\u003EOne complication is that functions often have more than one terminal node \u2013 programmers can arbitrarily return from the current function at any point. The immediate post-dominator tree is calculated for every terminal node, and any inconsistencies are marked as indeterminate and are not possible candidates for use. Functions with infinite loops do not have terminal nodes, and are not currently handled.\u003C\/p\u003E\n\u003Cp\u003EFor a simple example, consider the graph in Figure 14. It has the following immediate dominator and post-dominator trees:\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig14.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 14: Example graph\u003C\/span\u003E\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENode\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Eidom\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENone\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E1\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E1\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E1\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E5\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E6\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E7\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E6\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E8\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022101\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENode\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Eipdom\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E8\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E1\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E3\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E6\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E6\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E5\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E6\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E6\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E7\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E7\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E8\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E8\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022105\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ENone\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003ELooking for pairs of (idom[i] == j) and (ipdom[j] == i) gives the following:\u003C\/p\u003E\n\u003Cp\u003E(0, 8) (1, 3) (3, 6) (6,7)\u003C\/p\u003E\n\u003Cp\u003E(0, 8) is filtered because it makes up all of the nodes of the graph.\u003C\/p\u003E\n\u003Cp\u003E(1,3) and (6, 7) are filtered out because they contain nodes reachable from nodes not in the set: for (1, 3) node 2 is reachable from node 6, and for (6, 7) node 2 is reachable from node 1.\u003C\/p\u003E\n\u003Cp\u003EThis leaves (3, 6) as the only isolate subgraph in this example, shown in Figure 15.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/ida-simplifying-graphs\/Fig15.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 15: Example graph with isolated subgraph\u003C\/span\u003E\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Jan 11 2018 11:49:27 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed May 08 2019 18:14:50 GMT-0400",
      "imageRotate": "0"
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EWe\u2019re proud to release a new plug-in for IDA Pro users\u0026nbsp;\u2013 SimplifyGraph\u0026nbsp;\u2013 to help automate creation of groups of nodes in the IDA\u2019s disassembly graph view.\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Jan 11 2018 11:48:59 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
