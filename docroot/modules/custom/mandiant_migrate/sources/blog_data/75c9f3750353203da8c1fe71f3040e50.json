{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Mon Jun 18 2018 11:42:20 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Bring Your Own Land (BYOL) \u2013 A Novel Red Teaming Technique",
    "jcr:versionHistory": "c351dfe8-8293-403f-a0c0-86989e6043ed",
    "author": "Nathan Kirk",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "2bf6f802-5601-4449-8936-0e896edf072d"
    ],
    "jcr:created": "Tue Oct 22 2019 15:38:21 GMT+0000",
    "cq:lastModified": "Tue Oct 22 2019 15:37:58 GMT+0000",
    "jcr:baseVersion": "2bf6f802-5601-4449-8936-0e896edf072d",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:nathan-kirk",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:techniques",
      "fireeye-blog-tags:red-team"
    ],
    "jcr:uuid": "641f112e-e829-4ee9-9e80-d4cf63fd13ff",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Mon Jun 18 2018 11:45:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Ch4\u003EIntroduction\u003C\/h4\u003E\n\u003Cp\u003EOne of most significant recent developments in sophisticated offensive operations is the use of \u201cLiving off the Land\u201d (LotL) techniques by attackers. These techniques leverage legitimate tools present on the system, such as the PowerShell scripting language, in order to execute attacks. The popularity of PowerShell as an offensive tool culminated in the development of entire Red Team frameworks based around it, such as Empire and \u003Ca href=\u0022https:\/\/github.com\/PowerShellMafia\/PowerSploit\u0022\u003EPowerSploit\u003C\/a\u003E. In addition, the execution of PowerShell can be obfuscated through the use of tools such as \u201c\u003Ca href=\u0022https:\/\/github.com\/danielbohannon\/Invoke-Obfuscation\u0022\u003EInvoke-Obfuscation\u003C\/a\u003E\u201d. In response, defenders have developed detections for the malicious use of legitimate applications. These detections include suspicious parent\/child process relationships, suspicious process command line arguments, and even deobfuscation of malicious PowerShell scripts through the use of Script Block Logging.\u003C\/p\u003E\n\u003Cp\u003EIn this blog post, I will discuss an alternative to current LotL techniques. With the most current build of Cobalt Strike (version 3.11), it is now possible to execute .NET assemblies entirely within memory by using the \u201cexecute-assembly\u201d command. By developing custom C#-based assemblies, attackers no longer need to rely on the tools present on the target system; they can instead write and deliver their own tools, a technique I call Bring Your Own Land (BYOL). I will demonstrate this technique through the use of a custom .NET assembly that replicates some of the functionality of the PowerSploit project. I will also discuss how detections can be developed around BYOL techniques.\u003C\/p\u003E\n\u003Ch4\u003EBackground\u003C\/h4\u003E\n\u003Cp\u003EAt DerbyCon last year, I had the pleasure of meeting Raphael Mudge, the developer behind the Cobalt Strike Remote Access Tool (RAT). During our discussion, I mentioned how useful it would be to be able to load .NET assemblies into Cobalt Strike beacons, similar to how PowerShell scripts can be imported using the \u201cpowershell-import\u201d command. During a previous Red Team engagement I had been involved in, the use of PowerShell was precluded by the Endpoint Detection and Response (EDR) agent present on host machines within the target environment. This was a significant issue, as much of my red teaming methodology at the time was based on the use of various PowerShell scripts. For example, the \u201cGet-NetUser\u201d cmdlet of the \u003Ca href=\u0022https:\/\/github.com\/PowerShellMafia\/PowerSploit\/blob\/master\/Recon\/PowerView.ps1\u0022\u003EPowerView\u003C\/a\u003E script allows for the enumeration of domain users within an Active Directory environment. While the use of PowerShell was not an option, I found that no application-based whitelisting was occurring on hosts within the target\u2019s environment. Therefore, I started converting the PowerShell functionality into C# code, compiling assemblies locally as Portable Executable (PE) files, and then uploading the PE files onto target machines and executing them. This tactic was successful, and I was able to use these custom assemblies to elevate privileges up to Domain Admin within the target environment.\u003C\/p\u003E\n\u003Cp\u003ERaphael agreed that the ability to load these assemblies in-memory using a Cobalt Strike beacon would be useful, and about 8 months later this functionality was incorporated into Cobalt Strike version 3.11 via the \u201cexecute-assembly\u201d command.\u003C\/p\u003E\n\u003Ch4\u003E\u201cexecute-assembly\u201d Demonstration\u003C\/h4\u003E\n\u003Cp\u003EFor this demonstration, a custom C# .NET assembly named \u201cget-users\u201d was used. This assembly replicated some of the functionality of the PowerView \u201cGet-NetUser\u201d cmdlet; it queried the Domain Controller of the specified domain for a list of all current domain accounts. Information obtained included the \u201cSAMAccountName\u201d, \u201cUserGivenName\u201d, and \u201cUserSurname\u201d properties for each account. The domain is specified by passing its FQDN as an argument, and the results are then sent to stdout. The assembly being executed within a Cobalt Strike beacon is shown in \u003Ca name=\u0022OLE_LINK16\u0022 id=\u0022OLE_LINK16\u0022\u003E\u003C\/a\u003EFigure 1.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Using the \u201cexecute-assembly\u201d command within a Cobalt Strike beacon.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ESimple enough, now let\u2019s take a look at how this technique works under the hood.\u003C\/p\u003E\n\u003Ch4\u003EHow \u201cexecute-assembly\u201d Works\u003C\/h4\u003E\n\u003Cp\u003EIn order to discover more about how the \u201cexecute-assembly\u201d command works, the execution performed in Figure 1 was repeated with the host running \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/sysinternals\/downloads\/procmon\u0022\u003EProcMon\u003C\/a\u003E. The results of the process tree from ProcMon after execution are shown in \u003Ca name=\u0022OLE_LINK18\u0022 id=\u0022OLE_LINK18\u0022\u003E\u003C\/a\u003EFigure 2.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Process tree from ProcMon after executing \u201cexecute-assembly\u201d command.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn Figure 2, The \u201cpowershell.exe (2792)\u201d process contains the beacon, while the \u201crundll32.exe (2708)\u201d process is used to load and execute the \u201cget-users\u201d assembly. Note that \u201cpowershell.exe\u201d is shown as the parent process of \u201crundll32.exe\u201d in this example because the Cobalt Strike beacon was launched by using a PowerShell one-liner; however, nearly any process can be used to host a beacon by leveraging various process migration techniques. From this information, we can determine that the \u201cexecute-assembly\u201d command is similar to other \u003Ca href=\u0022https:\/\/blog.cobaltstrike.com\/2016\/07\/22\/why-is-rundll32-exe-connecting-to-the-internet\/\u0022\u003ECobalt Strike post-exploitation jobs\u003C\/a\u003E. In Cobalt Strike, some functions are offloaded to new processes, in order to ensure the stability of the beacon. The rundll32.exe Windows binary is used by default, although this setting can be changed. In order to migrate the necessary code into the new process, the \u003Ca name=\u0022OLE_LINK20\u0022 id=\u0022OLE_LINK20\u0022\u003E\u003C\/a\u003E\u003Ca name=\u0022OLE_LINK19\u0022 id=\u0022OLE_LINK19\u0022\u003E\u003C\/a\u003E\u003Ca href=\u0022https:\/\/msdn.microsoft.com\/en-us\/library\/windows\/desktop\/ms682437(v=vs.85).aspx\u0022\u003ECreateRemoteThread\u003C\/a\u003E function is used. We can confirm that this function is utilized by monitoring the host with \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/sysinternals\/downloads\/sysmon\u0022\u003ESysmon\u003C\/a\u003E while the \u201cexecute-assembly\u201d command is performed. The event generated by the use of the CreateRemoteThread function is shown in Figure 3.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: CreateRemoteThread Sysmon event, created after performing the \u201cexecute-assembly\u201d command.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EMore information about this event is shown in Figure 4.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Detailed information about the Sysmon CreateRemoteThread event shown in Figure 3.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn order to execute the provided assembly, the Common Language Runtime (CLR) must be loaded into the newly created process. From the ProcMon logs, we can determine the exact DLLs that are loaded during this step. A portion of these DLLs are shown in Figure 5.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Example of DLLs loaded into rundll32 for hosting the CLR.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn addition, DLLs loaded into the rundll32 process include those necessary for the get-users assembly, such as those for LDAP communication and Kerberos authentication. A portion of these DLLs are shown in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Example of DLLs loaded into rundll32 for Kerberos authentication.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe ProcMon logs confirm that the provided assembly is never written to disk, making the \u201cexecute-assembly\u201d command an entirely in-memory attack.\u003C\/p\u003E\n\u003Ch4\u003EDetecting and Preventing \u201cexecute-assembly\u201d\u003C\/h4\u003E\n\u003Cp\u003EThere are several ways to protect against the \u201cexecute-assembly\u201d command. As previously detailed, because the technique is a post-exploitation job in Cobalt Strike, it uses the CreateRemoteThread function, which is commonly detected by EDR solutions. However, it is possible that other implementations of BYOL techniques would not require the use of the CreateRemoteThread function.\u003C\/p\u003E\n\u003Cp\u003EThe \u201cexecute-assembly\u201d technique makes use of the native LoadImage function in order to load the provided assembly. The \u003Ca href=\u0022https:\/\/github.com\/endgameinc\/ClrGuard\u0022\u003ECLRGuard\u003C\/a\u003E project hooks into the use of this function, and prevents its execution. An example of CLRGuard preventing the execution of the \u201cexecute-assembly\u201d command is shown in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: CLRGuard blocking the execution of the \u201cexecute-assembly\u201d technique.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe resulting error is shown on the Cobalt Strike teamserver in Figure 8.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/BYOL\/Fig8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Error shown in Cobalt Strike when \u201cexecute-assembly\u201d is blocked by CLRGuard.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWhile CLRGuard is effective at preventing the \u201cexecute-assembly\u201d command, as well as other BYOL techniques, it is likely that blocking all use of the LoadImage function on a system would negatively impact other benign applications, and is not recommended for production environments.\u003C\/p\u003E\n\u003Cp\u003EAs with almost all security issues, baselining and correlation is the most effective means of detecting this technique. Suspicious events to correlate could include the use of the LoadImage function by processes that do not typically utilize it, and unusual DLLs being loaded into processes.\u003C\/p\u003E\n\u003Ch4\u003EAdvantages of BYOL\u003C\/h4\u003E\n\u003Cp\u003EDue to the prevalent use of PowerShell scripts by sophisticated attackers, detection of malicious PowerShell activity has become a primary focus of current detection methodology. In particular, version 5 of PowerShell allows for the use of \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2016\/02\/greater_visibilityt.html\u0022\u003EScript Block Logging\u003C\/a\u003E, which is capable of recording exactly what PowerShell scripts are executed by the system, regardless of obfuscation techniques. In addition, Constrained Language mode can be used to restrict PowerShell functionality. While bypasses exist for these protections, such as PowerShell downgrade attacks, each bypass an attacker attempts is another event that a defender can trigger off of. BYOL allows for the execution of attacks normally performed by PowerShell scripts, while avoiding all potential PowerShell-based alerts entirely.\u003C\/p\u003E\n\u003Cp\u003EPowerShell is not the only native binary whose malicious use is being tracked by defenders. Other common binaries that can generate alerts on include WMIC, schtasks\/at, and reg. The functionality of all these tools can be replicated within custom .NET assemblies, due to the flexibility of C# code. By being able to perform the same functionality as these tools without using them, alerts that are based on their malicious use are rendered ineffective.\u003C\/p\u003E\n\u003Cp\u003EFinally, thanks to the use of reflective loading, the BYOL technique can be performed entirely in-memory, without the need to write to disk.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EBYOL presents a powerful new technique for red teamers to remain undetected during their engagements, and can easily be used with Cobalt Strike\u2019s \u201cexecute-assembly\u201d command. In addition, the use of C# assemblies can offer attackers more flexibility than similar PowerShell scripts can afford. Detections for CLR-based techniques, such as hooking of functions used to reflectively load assemblies, should be incorporated into defensive methodology, as these attacks are likely to become more prevalent as detections for LotL techniques mature.\u003C\/p\u003E\n\u003Ch4\u003EAcknowledgement\u003C\/h4\u003E\n\u003Cp\u003ESpecial thanks to Casey Erikson, who I have worked closely with on developing C# assemblies that leverage this technique, for his contributions to this blog.\u003C\/p\u003E\n",
        "jcr:lastModified": "Mon Jun 18 2018 11:37:48 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EBy developing custom C#-based assemblies, attackers no longer need to rely on the tools present on the target system; they can instead write and deliver their own tools using a technique we call Bring Your Own Land (BYOL).\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Jun 18 2018 11:39:11 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Tue Oct 22 2019 15:37:58 GMT+0000",
      "imageRotate": "0"
    }
  }
}
