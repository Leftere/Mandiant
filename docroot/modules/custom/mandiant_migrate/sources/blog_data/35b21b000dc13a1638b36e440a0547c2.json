{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Tue Jan 09 2018 11:31:25 GMT-0500",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Debugging Complex Malware that Executes Code on the Heap",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "e770eb48-9f7d-4fca-89c5-90e7a52969ce",
    "author": "Michael Bailey",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "e6da03b9-25ed-4331-affd-18aaaf664a88"
    ],
    "jcr:created": "Wed May 08 2019 18:26:55 GMT-0400",
    "cq:lastReplicated": "Wed May 08 2019 18:26:50 GMT-0400",
    "cq:lastModified": "Wed May 08 2019 18:26:42 GMT-0400",
    "jcr:baseVersion": "e6da03b9-25ed-4331-affd-18aaaf664a88",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:michael-bailey",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:Analyst",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware-analysis",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "63750ffb-b846-4dab-b321-408fe885c6ac",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Jan 04 2018 11:30:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Ch4\u003EIntroduction\u003C\/h4\u003E\n\u003Cp\u003EIn this blog, I will share a simple debugging tactic for creating \u201csave points\u201d during iterative remote debugging of complex multi-stage samples that execute code in heap memory at non-deterministic addresses. I\u2019ll share two examples: one contrived, and the other a complex, modular malware sample (MD5 hash: 830a09ff05eac9a5f42897ba5176a36a) from a family that we call POISONPLUG. I will focus on IDA Pro and WinDbg, but I\u2019ll explain how to achieve the same effect with other tools as well. With this tactic, you can also hand off program execution between multiple debuggers using the strengths of different tools (e.g. unpacking a binary, dumping memory maps, combatting anti-RE, or normal debugging).\u003C\/p\u003E\n\u003Cp\u003EThe essence is merely suspending the malware. To set the stage, I must first explain how malware influences our debugging tactics to necessitate this. This explanation will serve as a review of common techniques that make malware debugging easier and culminate in the case study of POISONPLUG. If you\u2019re already a seasoned analyst using IDA Pro to remotely debug malware, and you\u2019re only interested in the bottom line of how to suspend and snapshot live malware, then skip to the Summary section at the end.\u003C\/p\u003E\n\u003Ch4\u003EVMs and Snapshots as Save Points\u003C\/h4\u003E\n\u003Cp\u003ETo prevent malware from doing damage, most malware reverse engineers debug in an isolated VM. This gives rise to the powerful tactic of capturing VM snapshots throughout the debugging process to be able to return to a \u201csave point\u201d after making a mistake. The analyst is then free to be aggressively experimental about exploring malware behavior. The only consequence of an error is that the analyst must revert the VM and avoid making the same mistake again.\u003C\/p\u003E\n\u003Ch4\u003ERemote Debugging\u003C\/h4\u003E\n\u003Cp\u003EDebugging malware on the same system where static analysis artifacts are stored is dangerous; malware (e.g. ransomware) can destroy notes and disassembly databases, or malware anti-RE measures can inflict data loss (e.g. by rebooting). Consequently, it makes sense to use separate systems for debugging versus disassembly and note-taking. Depending on the tools used, this can force the analyst to flip back and forth between viewing disassembler output and the debugger, like a spectator at a tennis match. These transitions are distracting.\u003C\/p\u003E\n\u003Ch4\u003EUnifying Static and Dynamic Analysis with IDA Pro as a Front-End\u003C\/h4\u003E\n\u003Cp\u003EFortunately, IDA Pro (and probably most modern disassemblers) can act as a debugging front-end, superimposing disassembly annotations over live memory and register state in a running program. This lets the analyst see and directly alter disassembly annotations in response to their observations, without switching back and forth.\u003C\/p\u003E\n\u003Ch4\u003EMalware that Modifies its Memory Map at Runtime\u003C\/h4\u003E\n\u003Cp\u003EThere is one frequent scenario that further shapes the requirements for a dynamic analysis methodology: malware that allocates heap memory, writes code to that memory, and executes that code. Consider Figure 1, which shows a simple program written in C.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Simple shellcode example program\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe program allocates memory using malloc, copies six bytes to that location using memcpy, logically inverts each byte, calls the buffer as a function, and finally returns the shellcode\u2019s return value (error checking omitted both for brevity and realism). Figure 2 shows the decoded shellcode in memory.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Simple shellcode function returns 42\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWithout this code, the disassembly database is missing useful information about the malware\u2019s code, leaving its behavior as a bit of a black box. This simple example demonstrates a common pattern, but its trivial nature isn\u2019t compelling enough to consider this a serious problem. A more realistic example will provide more substantial motivation for the debugging tactic at hand.\u003C\/p\u003E\n\u003Ch4\u003ECase Study: POISONPLUG\u003C\/h4\u003E\n\u003Cp\u003EFor a realistic example, consider the sample with MD5 hash 830a09ff05eac9a5f42897ba5176a36a (which is available from VirusTotal). This malware creates a thread that decodes and calls shellcode, which unpacks and calls into the entry point of a modified DLL module. The module in turn unpacks six additional modules before finally calling a function within one of those modules. The DllEntryPoint functions of several modules each create several anti-RE threads that attempt to detect common analyst tools and terminate the malware in response. After completely unpacking the malware, tools such as Tyler Dean\u2019s \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2016\/02\/flare_script_series.html\u0022\u003Einjectfind for flare-dbg\u003C\/a\u003E or my own \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/01\/flare_script_series.html\u0022\u003Eflare-qdb (Query-Oriented Debugger)\u003C\/a\u003E can expose all the read\/write\/execute (R\/W\/X) mappings in memory that, in this case, point directly to the malware modules. Figure 3 shows the output from flare-qdb debugging a subset of the malware to this point and dumping its R\/W\/X allocations.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: POISONPLUG R\/W\/X memory locations after unpacking\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 4 shows the unpacked shellcode-based loader from this sample, which is intricate, obfuscated, and time-consuming to annotate.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: POISONPLUG\u2019s shellcode-based loader\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis shellcode implements several anti-RE features specific to this malware family, and a copy of this is used to unpack seven modules altogether with modified\/custom PE-COFF headers. A common response to finding an entire executable file in memory is to dump the file and create its own disassembly database. However, the modules use a list of function pointers stashed in a mapping of the paging file to locate and call into one-another\u2019s function \u201cexports\u201d in spaghetti code fashion to deliberately obfuscate control flow and functional semantics. Figure 5 shows an example, where each lane represents one executable code module, and the boxes inside each lane represent distinct function entry point RVAs within that module.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Partial interaction diagram for retrieving and decoding configuration\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe code at offset 0x11f2 in module 0 is simply calling into other modules to eventually arrive at code within its own module (at offset 0x1d42). Dumping to separate disassembly databases creates distractions for the analyst as they must Alt+Tab between entirely different disassembly databases to follow the path of execution.\u003C\/p\u003E\n\u003Cp\u003EThese types of complex samples create a dual problem for the debugging tactics described so far\u2026\u003C\/p\u003E\n\u003Ch4\u003EChallenge 1: Syncing Code from the Heap\u003C\/h4\u003E\n\u003Cp\u003EThe first problem is that the code written to memory is generally not readily available in the original disassembly output, and dumping to separate disassembly databases is not always appropriate. It can also be a lot of work to neutralize anti-reversing measures and shepherd a sample to the point where it has unpacked all its encoded modules into heap memory. A debugging mistake can entail a lot of additional work to fix and resume analysis. Live memory is a resource that could hasten reverse engineering if it can be preserved beyond the life of the debug session. Luckily, this first problem of making unpacked modules conveniently available in a single disassembly database can be solved trivially, at least in IDA Pro:\u003C\/p\u003E\n\u003Col style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EVisit each dynamically allocated code region to change its segment attributes (Alt+S) and mark each as a \u003Cu\u003EL\u003C\/u\u003Eoader segment\u003C\/li\u003E\n\u003Cli\u003EPull the dynamically allocated memory into the disassembly database (Deb\u003Cu\u003Eu\u003C\/u\u003Egger \u0026gt; Take \u003Cu\u003Em\u003C\/u\u003Eemory snapshot \u0026gt; \u003Cu\u003EL\u003C\/u\u003Eoader Segments)\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EIf you are following along without having started a debugging session, IDA\u2019s Change segment attributes dialog will omit the \u003Cu\u003EL\u003C\/u\u003Eoader segment checkbox. Figure 6 shows this dialog during a debugging session, with the \u003Cu\u003EL\u003C\/u\u003Eoader segment checkbox highlighted.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Change segment attributes dialog during debugging session\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAfter pulling in live memory, it is possible to read and annotate unpacked modules and code in heap allocations even after terminating the debugging session, as shown in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Function code from heap saved from a debug memory snapshot\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EChallenge 2: Non-Deterministic Memory Maps\u003C\/h4\u003E\n\u003Cp\u003EA second problem arises from samples that execute code in dynamically allocated memory. Recovering from a debugging mistake still requires debugging the program again, but modules frequently occupy varying addresses across different executions. Consequently, the helpful annotations created in IDA Pro at the original addresses are absent from the new code locations. Figure 8 shows an example containing the same code as in Figure 7, but loaded at a different address during a subsequent execution of the program. The analyst must then recognize and\/or relabel everything to continue the analysis. This can be scripted, but it is a time-consuming distraction.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Same code at a different address lacks annotations\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe reason the code appears at varying addresses across debugging sessions is that Windows\u2019 memory allocation functions such as VirtualAlloc do not always return consistent addresses from one execution of a program to the next. For example, the first time a program runs, it may obtain memory at address 0xe000, the second time at 0x11a000, et cetera. For complex malware with several modules, this presents a problem.\u003C\/p\u003E\n\u003Cp\u003EWe\u2019d like the memory map to be uniform from one debug session to another so we can continue to build on our existing static analysis annotations, each of which IDA Pro has associated with a single virtual address. Alas, even though VirtualAlloc accepts an optional lpAddress parameter to indicate the starting address of the region to allocate, this is merely a suggestion unless memory was already reserved and uncommitted at that address. Forcing the lpAddress parameter to a desired value rarely (in my experience, never) yields success.\u003C\/p\u003E\n\u003Cp\u003EAlternately, it would be nice to go back to using virtual machine snapshots to create \u201csave points\u201d like before. Unfortunately, when debugging remotely over a network, the process of reverting a virtual machine snapshot breaks the TCP connection between the debug server and IDA Pro and prevents the malware from continuing under the control of the debugger.\u003C\/p\u003E\n\u003Ch4\u003E\u2026Where we Lay our Scene\u003C\/h4\u003E\n\u003Cp\u003EThe stage is now set to introduce the new technique. First, a short recap of how we got here:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003ENeed to debug in a VM to avoid damage to the host system\u003C\/li\u003E\n\u003Cli\u003EPrefer to use IDA Pro as the debugging front-end to unify static and dynamic analysis\u003C\/li\u003E\n\u003Cli\u003ENeed to use remote debugging to avoid damage to static analysis artifacts and documentation\u003C\/li\u003E\n\u003Cli\u003ENeed to debug iteratively across multiple debug sessions\u003C\/li\u003E\n\u003Cli\u003EDisassembly annotations must align with the memory map in the debug session to be useful\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EMalware behavior and analyst preferences seem to have painted us into a corner. Running the malware repeatedly results in a non-deterministic memory map that does not align with the annotations in the disassembly database, and using IDA Pro to unify the static view with live remote debugging appears impede the use of VM snapshots to act as save points. What should an analyst do?\u003C\/p\u003E\n\u003Ch4\u003EPark Your Malware\u003C\/h4\u003E\n\u003Cp\u003ETo capture a VM snapshot that allows us to repeatedly reattach to and resume debugging, we\u2019ll increase the suspend count of all the threads in the program and detach the debugger. The debug server will gracefully close its TCP connection, and the program will stay suspended until we reattach. We then capture a VM snapshot. Finally, we can repeatedly revert the VM, reattach, and resume execution to continue our analysis. This way, you can park your malware once, and then crash it over and over again until you understand its behavior.\u003C\/p\u003E\n\u003Cp\u003EAs it turns out, IDA Pro\u2019s facility for suspending threads (right-click -\u0026gt; Suspend) doesn\u2019t maintain its effect after detaching the debugger. Instead, we\u2019ll specifically use WinDbg as IDA\u2019s debugger back-end (see the \u003Ca href=\u0022https:\/\/www.hex-rays.com\/products\/ida\/support\/tutorials\/debugging_windbg.pdf\u0022\u003Edirections at Hex-Rays\u2019 site\u003C\/a\u003E).\u003C\/p\u003E\n\u003Cp\u003EThe WinDbg command for viewing thread status is ~ (tilde). The ~ command accepts an optional numeric argument to specify which thread to display (e.g. ~3), or you can specify ~* to display full status for all threads. WinDbg also supports commands ~n and ~m for suspe\u003Cu\u003En\u003C\/u\u003Eding and resu\u003Cu\u003Em\u003C\/u\u003Eing threads. These also permit numeric or asterisk arguments, so we can use ~*n to suspe\u003Cu\u003En\u003C\/u\u003Ed all threads before detaching, and ~*m to resu\u003Cu\u003Em\u003C\/u\u003Ee them upon reattaching. Figure 9 shows IDA\/WinDbg output after viewing thread status, suspending all threads, and finally viewing their status once more.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig9.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Viewing thread status, suspending, and viewing again\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe suspend count increases from 1 to 2 after issuing the ~*n command. Now, when the debugger detaches from the process and decrements the suspend count of all threads (as usual), the artificially elevated suspend count of each thread will remain greater than zero. Consequently, the NT dispatcher will not schedule any threads in the process to run, and the process will continue to exist in a suspended state.\u003C\/p\u003E\n\u003Cp\u003ENow, we can capture a VM snapshot that can be repeatedly reverted to resume debugging from where we left off. Figure 10 shows the process attachment dialog in IDA Pro after reverting the VM snapshot and clicking Deb\u003Cu\u003Eu\u003C\/u\u003Egger -\u0026gt; \u003Cu\u003EA\u003C\/u\u003Ettach to process\u2026\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig10.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Attaching to the suspended process\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EYou can create these \u201csave points\u201d at various junctures \u2013 as many as you have disk space to store.\u003C\/p\u003E\n\u003Cp\u003EThe one caveat to this procedure is that it is easy to forget to resume threads between reattaching and attempting to continue debugging. If you forget this step, then the \u201cPlease wait\u2026\u201d modal dialog in Figure 11 will appear.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/debugging-complex-malware\/Fig11.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Debugging a suspended process\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EA reverse engineer might be accustomed to seeing this dialog only after making a mistake and allowing malware to run free, but in this case, the program is not actually executing any instructions. To fix it, simply click the Suspend button in IDA Pro\u2019s \u201cPlease wait\u2026\u201d dialog and then resume all threads (WinDbg: ~*m) to decrease their suspend count. Then, execution can continue as normal.\u003C\/p\u003E\n\u003Ch4\u003ESummary\u003C\/h4\u003E\n\u003Cp\u003ETo suspend a program that you are running within an IDA Pro + WinDbg remote debug session to capture a reusable VM snapshot:\u003C\/p\u003E\n\u003Col style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003ESuspend all threads (WinDbg: ~*n)\u003C\/li\u003E\n\u003Cli\u003EDetach from the process (IDA Pro: Deb\u003Cu\u003Eu\u003C\/u\u003Egger -\u0026gt; Detac\u003Cu\u003Eh\u003C\/u\u003E from process)\u003C\/li\u003E\n\u003Cli\u003ECapture your VM snapshot\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003ETo resume the suspended program:\u003C\/p\u003E\n\u003Col style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EAttach to the remote process (IDA Pro: Deb\u003Cu\u003Eu\u003C\/u\u003Egger -\u0026gt; \u003Cu\u003EA\u003C\/u\u003Ettach to process\u2026)\u003C\/li\u003E\n\u003Cli\u003EResume all threads (WinDbg: ~*m)\u003C\/li\u003E\n\u003Cli\u003EResume debugging as normal\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EIf you aren\u2019t interested in using WinDbg commands, you can instead use SysInternals\u2019 Process Explorer to suspend the process in your debugging VM and simply detach using IDA Pro. You could also write a Python ctypes script or native program to directly use the relevant Windows APIs if you prefer (specifically via CreateToolhelp32Snapshot with the TH32_SNAPTHREAD flag, OpenThread, SuspendThread, and ResumeThread).\u003C\/p\u003E\n\u003Cp\u003EThis tactic allows us to cope with complex multi-stage shellcode or modular malware that has several (sometimes cascading) unpacked code regions. It lets us create save points in our debug session while maintaining the same memory map so our disassembly annotations always remain aligned with the memory map in the debug session. It also allows us to suspend malware execution in one debugger and pick it up in another, provided each debugger allows thread suspend count to remain at a non-zero value before detaching.\u003C\/p\u003E\n\u003Cp\u003EBefore closing, I\u2019d like to give credit to Tarik Soulami for his explanation of WinDbg thread management in his book, \u201cInside Windows Debugging\u201d (Microsoft Press, 2012). If you\u2019re starting to confront more difficult debugging scenarios in your journey as a reverse engineer, I strongly encourage you to pick up \u201cInside Windows Debugging\u201d to augment your repertoire and further understand the powerful debugging capabilities of WinDbg and Windows itself.\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu Jan 04 2018 11:51:16 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EIn this blog, learn about a simple debugging tactic for creating \u201csave points\u201d during iterative remote debugging of complex multi-stage samples that execute code in heap memory at non-deterministic addresses.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Jan 03 2018 15:46:26 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed May 08 2019 18:26:42 GMT-0400",
      "imageRotate": "0"
    }
  }
}
