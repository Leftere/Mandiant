{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Tue Jul 07 2020 18:00:12 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Configuring a Windows Domain to Dynamically Analyze an Obfuscated Lateral Movement Tool",
    "jcr:versionHistory": "09695e79-0a6c-4f8a-85a8-479a5f11789f",
    "author": "Matthew Haigh",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "69ce8e2c-8eca-4a6d-b166-b767a9ca7dca"
    ],
    "jcr:created": "Tue Jul 07 2020 18:00:12 GMT+0000",
    "cq:lastModified": "Tue Jul 07 2020 17:47:53 GMT+0000",
    "jcr:baseVersion": "69ce8e2c-8eca-4a6d-b166-b767a9ca7dca",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:matthew-haigh",
      "fireeye-blog-authors:trevor-haskell",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:analysis",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:malware",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:reverse-engineering",
      "fireeye-blog-tags:mandiant"
    ],
    "jcr:uuid": "ba630d2f-9348-48f3-8a09-a460372aed71",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Jul 07 2020 14:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EWe recently encountered a large obfuscated malware sample that offered several interesting analysis challenges. It used virtualization that prevented us from producing a fully-deobfuscated memory dump for static analysis. Statically analyzing a large virtualized sample can take anywhere from several days to several weeks. Bypassing this time-consuming step presented an opportunity for collaboration between the FLARE reverse engineering team and the Mandiant consulting team which ultimately saved many hours of difficult reverse engineering.\u003C\/p\u003E\n\u003Cp\u003EWe suspected the sample to be a lateral movement tool, so we needed an appropriate environment for dynamic analysis. Configuring the environment proved to be essential, and we want to empower other analysts who encounter samples that leverage a domain. Here we will explain the process of setting up a virtualized Windows domain to run the malware, as well as the analysis techniques we used to confirm some of the malware functionality.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Ch4\u003EPreliminary Analysis\u003C\/h4\u003E\n\u003Cp\u003EWhen analyzing a new malware sample, we begin with basic static analysis, where we can often get an idea of what type of sample it is and what it\u2019s capabilities might be. We can use this to inform the subsequent stages of the analysis process and focus on the relevant data. We begin with a Portable Executable analysis tool such as CFF Explorer. In this case, we found that the sample is quite large at 6.64 MB. This usually indicates that the sample includes statically linked libraries such as Boost or OpenSSL, which can make analysis difficult.\u003C\/p\u003E\n\u003Cp\u003EAdditionally, we noticed that the import table includes eight dynamically linked DLLs with only one imported function each as shown in Figure 1. This is a common technique used by packers and obfuscators to import DLLs that can later be used for runtime linking, without exposing the actual APIs used by the malware.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Suspicious imports\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOur strings analysis confirmed our suspicion that the malware would be difficult to analyze statically. Because the file is so large, there were over 75,000 strings to consider. We used \u003Ca href=\u0022https:\/\/github.com\/fireeye\/stringsifter\u0022\u003EStringSifter\u003C\/a\u003E to rank the strings according to relevance to malware analysis, but we did not identify anything useful. Figure 2 shows the most relevant strings according to StringSifter.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: StringSifter output\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWhen we encounter these types of obstacles, we can often turn to dynamic analysis to reveal the malware\u0027s behavior. In this case, our basic dynamic analysis provided hope. Upon execution the sample printed a usage statement:\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003EUsage: evil.exe [\/P:str] [\/S[:str]] [\/B:str] [\/F:str] [\/C] [\/L:str] [\/H:str] [\/T:int] [\/E:int] [\/R]\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/P:str -- path to payload file.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/S[:str] -- share for reverse copy.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/B:str -- path to file to load settings from.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/F:str -- write log to specified file.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/C -- write log to console.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/L:str -- path to file with host list.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/H:str -- host name to process.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/T:int -- maximum number of concurrent threads.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/E:int -- number of seconds to delay before payload deletion (set to 0 to avoid remove).\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp;\/R -- remove payload from hosts (\/P and \/S will be ignored).\u003Cbr\u003E\n If \/S specifed without value, random name will be used.\u003Cbr\u003E\n \/L and \/H can be combined and specified more than once. At least one must present.\u003Cbr\u003E\n \/B will be processed after all other flags and will override any specified values (if any).\u003Cbr\u003E\n All parameters are case sensetive.\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Usage statement\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe attempted to unpack the sample by suspending the process and dumping the memory. This proved difficult as the malware exited almost instantly and deleted itself. We eventually managed to produce a partially-unpacked memory dump by using the commands in Figure 4.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Esleep 2 \u0026amp;\u0026amp; evil.exe \/P:\u0026quot;C:\\Windows\\System32\\calc.exe\u0026quot; \/E:1000 \/F:log.txt \/H:some_host\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Commands executed to run binary\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe chose an arbitrary payload file and a large interval for payload deletion. We also provided a log filename and a hostname for payload execution. These parameters were designed to force a slower execution time so we could suspend the process before it terminated.\u003C\/p\u003E\n\u003Cp\u003EWe used \u003Ca href=\u0022https:\/\/github.com\/glmcdona\/Process-Dump\u0022\u003EProcess Dump\u003C\/a\u003E to produce a memory snapshot after the two second delay. Unfortunately, virtualization still hindered static analysis and our sample remained mostly obfuscated, but we did manage to extract some strings which provided the breakthrough we needed.\u003C\/p\u003E\n\u003Cp\u003EFigure 5 shows some of the interesting strings we encountered that were not present in the original binary.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Edumpedswaqp.exe\u003Cbr\u003E\n psxexesvc\u003Cbr\u003E\n schtasks.exe \/create \/tn \u0026quot;%s\u0026quot; \/tr \u0026quot;%s\u0026quot; \/s \u0026quot;%s\u0026quot; \/sc onstart \/ru system \/f\u003Cbr\u003E\n schtasks.exe \/run \/tn \u0026quot;%s\u0026quot; \/s \u0026quot;%s\u0026quot;\u003Cbr\u003E\n schtasks.exe \/delete \/tn \u0026quot;%s\u0026quot; \/s \u0026quot;%s\u0026quot; \/f\u003Cbr\u003E\n ServicesActive\u003Cbr\u003E\n Payload direct-copied\u003Cbr\u003E\n Payload reverse-copied\u003Cbr\u003E\n Payload removed\u003Cbr\u003E\n Task created\u003Cbr\u003E\n Task executed\u003Cbr\u003E\n Task deleted\u003Cbr\u003E\n SM opened\u003Cbr\u003E\n Service created\u003Cbr\u003E\n Service started\u003Cbr\u003E\n Service stopped\u003Cbr\u003E\n Service removed\u003Cbr\u003E\n Total hosts: %d, Threads: %d\u003Cbr\u003E\n SHARE_%c%c%c%c\u003Cbr\u003E\n Share \u0026quot;%s\u0026quot; created, path \u0026quot;%s\u0026quot;\u003Cbr\u003E\n Share \u0026quot;%s\u0026quot; removed\u003Cbr\u003E\n Error at hooking API \u0026quot;%S\u0026quot;\u003Cbr\u003E\n Dumping first %d bytes:\u003Cbr\u003E\n DllRegisterServer\u003Cbr\u003E\n DllInstall\u003Cbr\u003E\n register\u003Cbr\u003E\n install\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Strings output from memory dump\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBased on the analysis thus far, we suspected remote system access. However, we were unable to confirm our suspicions without providing an environment for lateral movement. To expedite analysis, we created a virtualized Windows domain.\u003C\/p\u003E\n\u003Cp\u003EThis requires some configuration, so we have documented the process here to aid others when using this analysis technique.\u003C\/p\u003E\n\u003Ch4\u003EBuilding a Test Environment\u003C\/h4\u003E\n\u003Cp\u003EIn the test environment, make sure to have clean Windows 10 and Windows Server 2016 (Desktop Experience) virtual machines installed. We recommend creating two Windows Server 2016 machines so the Domain Controller can be separated from the other test systems.\u003C\/p\u003E\n\u003Cp\u003EIn VMware Virtual Network Editor on the host system, create a custom network with the following settings:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EUnder VMNet Information, select the \u201cHost-only\u201d radio button.\u003C\/li\u003E\n\u003Cli\u003EEnsure that \u201cConnect a host virtual adapter\u201d is disabled to prevent connection to the outside world.\u003C\/li\u003E\n\u003Cli\u003EEnsure that the \u201cUse local DHCP service\u201d option is disabled if static IP addresses will be used.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EThis is demonstrated in Figure 6\u003Cb\u003E\u003C\/b\u003E.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture6.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Virtual network adapter configuration\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThen, configure the guests\u2019 network adapters to connect to this network.\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EConfigure hostnames and static IP addresses for the virtual machines.\u003C\/li\u003E\n\u003Cli\u003EChoose the domain controller IP as the default gateway and DNS server for all guests.\u0026nbsp;\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EWe used the system configurations shown in Figure 7.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Example system configurations\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce everything is configured, begin by installing Active Directory Domain Services and DNS Server roles onto the designated domain controller server. This can be done by selecting the options shown in Figure 8 via the Windows Server Manager application. The default settings can be used throughout the dialog as roles are added.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture8.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Roles needed on domain controller\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce the roles are installed, run the promotion operation as demonstrated in Figure 9. The promotion option is accessible through the notifications menu (flag icon) once the Active Directory Domain Services role is added to the server. Add a new forest with a fully qualified root domain name such as \u003Ci\u003Etestdomain.local\u003C\/i\u003E. Other options may be left as default. Once the promotion process is complete, reboot the system.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture9.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Promoting system to domain controller in Server Manager\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce the domain controller is promoted, create a test user account via \u003Ci\u003EActive Directory Users and Computers\u003C\/i\u003E on the domain controller. An example is shown in Figure 10.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture10.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Test user account\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce the test account is created, proceed to join the other systems on the virtual network to the domain. This can be done through Advanced System Settings as shown in Figure 11. Use the test account credentials to join the system to the domain.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture11.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Configure the domain name for each guest\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce all systems are joined to the domain, verify that each system can ping the other systems. We recommend disabling the Windows Firewall in the test environment to ensure that each system can access all available services of another system in the test environment.\u003C\/p\u003E\n\u003Cp\u003EGive the test account administrative rights on all test systems. This can be done by modifying the local administrator group on each system manually with the command shown in Figure 12 or automated through a \u003Ca href=\u0022https:\/\/social.technet.microsoft.com\/wiki\/contents\/articles\/20402.active-directory-group-policy-restricted-groups.aspx\u0022\u003EGroup Policy Object (GPO)\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Enet localgroup administrators sa_jdoe \/ADD\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: Command to add user to local administrators group\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EDynamic Analysis on the Domain\u003C\/h4\u003E\n\u003Cp\u003EAt this point, we were ready to begin our dynamic analysis. We prepared our test environment by installing and launching Wireshark and Process Monitor. We took snapshots of all three guests and ran the malware in the context of the test domain account on the client as shown in Figure 13.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Eevil.exe \/P:\u0026quot;C:\\Windows\\System32\\calc.exe\u0026quot; \/L:hostnames.txt \/F:log.txt \/S \/C\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 13: Command used to run the malware\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe populated the \u003Ci\u003Ehostnames.txt\u003C\/i\u003E file with the following line-delimited hostnames as demonstrated in Figure 14.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003EDBPROD.testdomain.local\u003Cbr\u003E\n client.testdomain.local\u003Cbr\u003E\n DC.testdomain.local\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 14: File contents of hostnames.txt\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EPacket Capture Analysis\u003C\/h4\u003E\n\u003Cp\u003EUpon analyzing the traffic in the packet capture, we identified SMB connections to each system in the host list. Before the SMB handshake completed, Kerberos tickets were requested. A ticket granting ticket (TGT) was requested for the user, and service tickets were requested for each server as seen in Figure 15. To learn more about the Kerberos authentication protocol, please see \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2020\/04\/kerberos-tickets-on-linux-red-teams.html\u0022\u003Eour recent blog\u003C\/a\u003E post that introduces the protocol along with a new Mandiant Red Team tool.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture15.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 15: Kerberos authentication process\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe malware accessed the \u003Ci\u003EC$\u003C\/i\u003E share over SMB and wrote the file \u003Ci\u003EC:\\Windows\\swaqp.exe\u003C\/i\u003E. It then used RPC to launch \u003Ci\u003ESVCCTL\u003C\/i\u003E, which is used to register and launch services. \u003Ci\u003ESVCCTL\u003C\/i\u003E created the \u003Ci\u003Eswaqpd\u003C\/i\u003E service. The service was used to execute the payload and then was subsequently deleted. Finally, the file was deleted, and no additional activity was observed. The traffic is shown in Figure 16.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/dynamicanalysis\/Picture16.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 16: Malware behavior observed in packet capture\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOur analysis of the malware behavior with Process Monitor confirmed this observation. We then proceeded to run the malware with different command line options and environments. Combined with our static analysis, we were able to determine with confidence the malware capabilities, which include copying a payload to a remote host, installing and running a service, and deleting the evidence afterward.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EStatic analysis of a large, obfuscated sample can take dozens of hours. Dynamic analysis can provide an alternate solution, but it requires the analyst to predict and simulate a proper execution environment. In this case we were able to combine our basic analysis fundamentals with a virtualized Windows domain to get the job done. We leveraged the diverse skills available to FireEye by combining FLARE reverse engineering expertise with Mandiant consulting and Red Team experience. This combination reduced analysis time to several hours. We supported an active incident response investigation by quickly extracting the necessary indicators from the compromised host. We hope that sharing this experience can assist others in building their own environment for lateral movement analysis.\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue Jul 07 2020 17:47:53 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EStatic analysis of a large, obfuscated sample can take dozens of hours, so dynamic analysis can provide an alternate solution.\u003C\/p\u003E\n",
      "jcr:lastModified": "Tue Jul 07 2020 17:40:30 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Tue Jul 07 2020 17:44:45 GMT+0000",
      "imageRotate": "0"
    }
  }
}
