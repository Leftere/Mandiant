{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed May 04 2016 09:04:04 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Tracking Malware with Import Hashing",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "36dee551-cf8a-4c9e-93ed-36c0e4fd79ea",
    "author": "Mandiant",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "lynda.hall@fireeye.com",
    "focusKeyword": "FireEye",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "865eb526-015d-4373-96a6-ef126f562792"
    ],
    "jcr:created": "Fri Jun 03 2016 19:48:18 GMT-0400",
    "cq:lastReplicated": "Fri Jun 03 2016 19:48:18 GMT-0400",
    "cq:lastModified": "Thu Jan 23 2014 20:20:08 GMT-0500",
    "cq:distribute": true,
    "jcr:baseVersion": "865eb526-015d-4373-96a6-ef126f562792",
    "jcr:isCheckedOut": true,
    "cq:createdBy": "admin",
    "cq:tags": [
      "fireeye-blog-authors:cap-info",
      "fireeye-blog-tags:homeunix",
      "fireeye-blog-tags:fireeye",
      "fireeye-blog-tags:imphash",
      "fireeye-blog-tags:mandiant"
    ],
    "jcr:uuid": "771eb99a-3828-43c9-a2b4-004ef3bd1ca8",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Jan 23 2014 20:20:08 GMT-0500",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "admin",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "admin",
        "text": "\u003Cdiv class=\u0022c00 c00v1\u0022\u003E\u003Cp\u003ETracking threat groups over time is an important tool to help defenders hunt for evil on networks and conduct effective incident response. Knowing how certain groups operate makes for an efficient investigation and assists in easily identifying threat actor activity.\u003C\/p\u003E \u003Cp\u003EAt Mandiant, we utilize several methods to help identify and correlate threat group activity. A critical piece of our work involves tracking various operational items such as attacker infrastructure and email addresses. In addition, we track the specific backdoors each threat group utilizes - one of the key ways to follow a group\u0027s activities over time. For example, some groups may favor the SOGU backdoor, while others use HOMEUNIX.\u003C\/p\u003E \u003Cp\u003EOne unique way that Mandiant tracks specific threat groups\u0027 backdoors is to track portable executable (PE) imports. Imports are the functions that a piece of software (in this case, the backdoor) calls from other files (typically various DLLs that provide functionality to the Windows operating system). To track these imports, Mandiant creates a hash based on library\/API names and their specific order within the executable. We refer to this convention as an \u0022imphash\u0022 (for \u0022import hash\u0022). Because of the way a PE\u0027s import table is generated (and therefore how its imphash is calculated), we can use the imphash value to identify related malware samples. We can also use it to search for new, similar samples that the same threat group may have created and used.\u003C\/p\u003E \u003Cp\u003EThough Mandiant has been leveraging this technique for well over a year internally, \u003Ca href=\u0022http:\/\/www.fireeye.com\/resources\/pdfs\/fireeye-malware-supply-chain.pdf\u0022 target=\u0022_blank\u0022 rel=\u0022nofollow\u0022\u003Ewe aren\u0027t the first to publicly discuss this\u003C\/a\u003E. An imphash is a powerful way to identify related malware because the value itself should be relatively unique. This is because the compiler\u0027s linker generates and builds the Import Address Table (IAT) based on the specific order of functions within the source file. Take the following example source code:\u003C\/p\u003E \u003Cpre\u003E#include \u003Cwindows.h\u003E\u003Cbr \/\u003E#include \u003Cstdio.h\u003E\u003Cbr \/\u003E#include \u003Cstdlib.h\u003E\u003Cbr \/\u003E#include \u003Cwininet.h\u003E\u003Cbr \/\u003E#pragma comment(lib, \u0022ws2_32.lib\u0022)\u003Cbr \/\u003E#pragma comment(lib, \u0022wininet.lib\u0022)\u003Cbr \/\u003Eint makeMutexA()\u003Cbr \/\u003E{\u003Cbr \/\u003E    CreateMutexA(NULL, FALSE, \u0022TestMutex\u0022);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint makeMutexW()\u003Cbr \/\u003E{\u003Cbr \/\u003E    CreateMutexW(NULL, FALSE, L\u0022TestMutex\u0022);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint makeUserAgent()\u003Cbr \/\u003E{\u003Cbr \/\u003E    HANDLE hInet=0, hConn=0;\u003Cbr \/\u003E    char buf[sizeof(struct hostent)] = {0};\u003Cbr \/\u003E    hInet = InternetOpenA(\u0022User-Agent: (Windows; 5.1)\u0022, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\u003Cbr \/\u003E    hConn = InternetConnectA(hInet, \u0022www.google.com\u0022, 443, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);\u003Cbr \/\u003E    WSAAsyncGetHostByName(NULL, 3, \u0022www.yahoo.com\u0022, buf, sizeof(struct hostent));\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint main(int argc, char *argv[])\u003Cbr \/\u003E{\u003Cbr \/\u003E    makeMutexA();\u003Cbr \/\u003E    makeMutexW();\u003Cbr \/\u003E    makeUserAgent();\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003C\/pre\u003E\u003Cp\u003EWhen that source file is compiled, the resulting import table looks as follows:\u003C\/p\u003E \u003Cpre\u003Ews2_32.dll\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ews2_32.dll.WSAAsyncGetHostByName\u003C\/strong\u003E\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003Ewininet.dll\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ewininet.dll.InternetOpenA\u003C\/strong\u003E\u003C\/span\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ewininet.dll.InternetConnectA\u003C\/strong\u003E\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003Ekernel32.dll\u003Cbr \/\u003E    kernel32.dll.InterlockedIncrement\u003Cbr \/\u003E    kernel32.dll.IsProcessorFeaturePresent\u003Cbr \/\u003E    kernel32.dll.GetStringTypeW\u003Cbr \/\u003E    kernel32.dll.MultiByteToWideChar\u003Cbr \/\u003E    kernel32.dll.LCMapStringW\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ekernel32.dll.CreateMutexA\u003C\/strong\u003E\u003C\/span\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003E kernel32.dll.CreateMutexW\u003C\/strong\u003E\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003Ekernel32.dll.GetCommandLineA\u003Cbr \/\u003Ekernel32.dll.HeapSetInformation\u003Cbr \/\u003Ekernel32.dll.TerminateProcess\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003EImphash: 0c6803c4e922103c4dca5963aad36ddf\u003C\/span\u003E\u003C\/p\u003E \u003Cp\u003EWe abbreviated the table to save space, but the red\/bolded APIs are the ones referenced in the source code. Note the order in which they appear in the table, and compare that to the order in which they appear in the source file.\u003C\/p\u003E \u003Cp\u003EIf an author were to change the order of the functions and\/or the order of the API calls in the source code, this would in turn affect the compiled import table. Take the previous example, modified:\u003C\/p\u003E \u003Cpre\u003E#include \u003Cwindows.h\u003E\u003Cbr \/\u003E#include \u003Cstdio.h\u003E\u003Cbr \/\u003E#include \u003Cstdlib.h\u003E\u003Cbr \/\u003E#include \u003Cwininet.h\u003E\u003Cbr \/\u003E#pragma comment(lib, \u0022ws2_32.lib\u0022)\u003Cbr \/\u003E#pragma comment(lib, \u0022wininet.lib\u0022)\u003Cbr \/\u003E\u003Cstrong\u003Eint makeMutexW()\u003Cbr \/\u003E{\u003Cbr \/\u003E    CreateMutexW(NULL, FALSE, L\u0022TestMutex\u0022);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint makeMutexA()\u003Cbr \/\u003E{\u003Cbr \/\u003E    CreateMutexA(NULL, FALSE, \u0022TestMutex\u0022);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003C\/strong\u003E\u003Cbr \/\u003Eint makeUserAgent()\u003Cbr \/\u003E{\u003Cbr \/\u003E    HANDLE hInet=0, hConn=0;\u003Cbr \/\u003E    char buf[sizeof(struct hostent)] = {0};\u003Cbr \/\u003E    \u003Cstrong\u003EhConn = InternetConnectA(hInet, \u0022www.google.com\u0022, 443, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);\u003Cbr \/\u003E  hInet = InternetOpenA(\u0022User-Agent: (Windows; 5.1)\u0022, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\u003C\/strong\u003E\u003Cbr \/\u003E    WSAAsyncGetHostByName(NULL, 3, \u0022www.yahoo.com\u0022, buf, sizeof(struct hostent));\u003Cbr \/\u003E  return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint main(int argc, char *argv[])\u003Cbr \/\u003E{\u003Cbr \/\u003E    makeMutexA();\u003Cbr \/\u003E  makeMutexW();\u003Cbr \/\u003E  makeUserAgent();\u003Cbr \/\u003E  return 0;\u003Cbr \/\u003E}\u003C\/pre\u003E\u003Cp\u003EIn this example, we have reversed the order of makeMutexW and makeMutexA, and of InternetConnectA and InternetOpenA. (Note that this would be an invalid sequence of API calls, but we use it here to illustrate the point.) Below is the import table generated from this modified source code (again abbreviated); note the changes when compared to the original IAT, above, as well as the different imphash value:\u003C\/p\u003E \u003Cpre\u003Ews2_32.dll\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003Ews2_32.dll.WSAAsyncGetHostByName\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003Ewininet.dll\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ewininet.dll.InternetConnectA\u003C\/strong\u003E\u003C\/span\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ewininet.dll.InternetOpenA\u003C\/strong\u003E\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003Ekernel32.dll\u003Cbr \/\u003Ekernel32.dll.InterlockedIncrement\u003Cbr \/\u003Ekernel32.dll.IsProcessorFeaturePresent\u003Cbr \/\u003Ekernel32.dll.GetStringTypeW\u003Cbr \/\u003Ekernel32.dll.MultiByteToWideChar\u003Cbr \/\u003Ekernel32.dll.LCMapStringW\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ekernel32.dll.CreateMutexW\u003C\/strong\u003E\u003C\/span\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ekernel32.dll.CreateMutexA\u003C\/strong\u003E\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003Ekernel32.dll.GetCommandLineA\u003Cbr \/\u003Ekernel32.dll.HeapSetInformation\u003Cbr \/\u003Ekernel32.dll.TerminateProcess\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003EImphash: b8bb385806b89680e13fc0cf24f4431e\u003C\/span\u003E\u003C\/p\u003E \u003Cp\u003EThe final example shows how the ordering of included files at compile time will affect the resulting IAT (and thus the resulting imphash value). We\u0027ll expand on our original example by adding files \u003Ccode\u003Eimphash1.c\u003C\/code\u003E and \u003Ccode\u003Eimphash2.c\u003C\/code\u003E, to be included with our original source file \u003Ccode\u003Eimphash.c\u003C\/code\u003E:\u003C\/p\u003E \u003Cpre\u003E\u003Cbr \/\u003E-- imphash1.c --\u003Cbr \/\u003Eint makeNamedPipeA()\u003Cbr \/\u003E{\u003Cbr \/\u003EHANDLE ph = CreateNamedPipeA(\u0022\\\\.\\pipe    est_pipe\u0022, PIPE_ACCESS_DUPLEX,\u003Cbr \/\u003E    PIPE_TYPE_MESSAGE, 1, 128,\u003Cbr \/\u003E    64, 200, NULL);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003C\/pre\u003E\u003Cpre\u003E\u003Cbr \/\u003E-- imphash2.c --\u003Cbr \/\u003Eint makeNamedPipeW()\u003Cbr \/\u003E{\u003Cbr \/\u003E    HANDLE ph2 = CreateNamedPipeW(L\u0022\\\\.\\pipe    est_pipeW\u0022, PIPE_ACCESS_DUPLEX,\u003Cbr \/\u003E        PIPE_TYPE_MESSAGE, 1, 128,\u003Cbr \/\u003E        64, 200, NULL);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003C\/pre\u003E\u003Cpre\u003E\u003Cbr \/\u003E-- imphash.c --\u003Cbr \/\u003E#include \u003Cwindows.h\u003E\u003Cbr \/\u003E#include \u003Cstdio.h\u003E\u003Cbr \/\u003E#include \u003Cstdlib.h\u003E\u003Cbr \/\u003E#include \u003Cwininet.h\u003E\u003Cbr \/\u003E#include \u0022imphash1.h\u0022\u003Cbr \/\u003E#include \u0022imphash2.h\u0022\u003Cbr \/\u003E#pragma comment(lib, \u0022ws2_32.lib\u0022)\u003Cbr \/\u003E#pragma comment(lib, \u0022wininet.lib\u0022)\u003Cbr \/\u003Eint makeMutexW()\u003Cbr \/\u003E{\u003Cbr \/\u003E    CreateMutexW(NULL, FALSE, L\u0022TestMutex\u0022);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint makeMutexA()\u003Cbr \/\u003E{\u003Cbr \/\u003E    CreateMutexA(NULL, FALSE, \u0022TestMutex\u0022);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint makeUserAgent()\u003Cbr \/\u003E{\u003Cbr \/\u003E    HANDLE hInet = 0, hConn = 0;\u003Cbr \/\u003E    char buf[sizeof(struct hostent)] = {0};\u003Cbr \/\u003E    hConn = InternetConnectA(hInet, \u0022www.google.com\u0022, 443, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);\u003Cbr \/\u003E    hInet = InternetOpenA(\u0022User-Agent: (Windows; 5.1)\u0022, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\u003Cbr \/\u003E    WSAAsyncGetHostByName(NULL, 3, \u0022www.yahoo.com\u0022, buf, sizeof(struct hostent));\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003Eint main(int argc, char *argv[])\u003Cbr \/\u003E{\u003Cbr \/\u003E    makeMutexA();\u003Cbr \/\u003E    makeMutexW();\u003Cbr \/\u003E    makeUserAgent();\u003Cbr \/\u003E    makeNamedPipeA();\u003Cbr \/\u003E    makeNamedPipeW();\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003C\/pre\u003E\u003Cp\u003EUsing the following command to build the EXE:\u003C\/p\u003E \u003Cpre\u003Ecl imphash.c imphash1.c imphash2.c \/W3 \/WX \/link\u003C\/pre\u003E\u003Cp\u003EThe resulting IAT is:\u003C\/p\u003E \u003Cpre\u003Ews2_32.dll\u003Cbr \/\u003Ews2_32.dll.WSAAsyncGetHostByName\u003Cbr \/\u003Ewininet.dll\u003Cbr \/\u003Ewininet.dll.InternetConnectA\u003Cbr \/\u003Ewininet.dll.InternetOpenA\u003Cbr \/\u003Ekernel32.dll\u003Cbr \/\u003Ekernel32.dll.TlsFree\u003Cbr \/\u003Ekernel32.dll.IsProcessorFeaturePresent\u003Cbr \/\u003Ekernel32.dll.GetStringTypeW\u003Cbr \/\u003Ekernel32.dll.MultiByteToWideChar\u003Cbr \/\u003Ekernel32.dll.LCMapStringW\u003Cbr \/\u003Ekernel32.dll.CreateMutexW\u003Cbr \/\u003Ekernel32.dll.CreateMutexA\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ekernel32.dll.CreateNamedPipeA\u003C\/strong\u003E\u003C\/span\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ekernel32.dll.CreateNamedPipeW\u003C\/strong\u003E\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003E \u003Cbr \/\u003Ekernel32.dll.GetCommandLineA\u003Cbr \/\u003Ekernel32.dll.HeapSetInformation\u003Cbr \/\u003Ekernel32.dll.TerminateProcess\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003EImphash: 9129bdbc18cfd1aba498c94e809567d5\u003C\/span\u003E\u003C\/p\u003E \u003Cp\u003EChanging the order of includes for \u003Ccode\u003Eimphash1.h\u003C\/code\u003E and \u003Ccode\u003Eimphash2.h\u003C\/code\u003E within the source file \u003Ccode\u003Eimphash.c\u003C\/code\u003E will have no effect on the ordering of the IAT. However, changing the order of the files on the command line and recompiling will affect the IAT; note the re-ordering of \u003Ccode\u003ECreateNamedPipeW\u003C\/code\u003E and \u003Ccode\u003ECreateNamedPipeA\u003C\/code\u003E:\u003C\/p\u003E \u003Cpre\u003Ecl imphash.c imphash2.c imphash1.c \/W3 \/WX \/link\u003Cbr \/\u003Ews2_32.dll\u003Cbr \/\u003E    ws2_32.dll.WSAAsyncGetHostByName\u003Cbr \/\u003Ewininet.dll\u003Cbr \/\u003E    wininet.dll.InternetConnectA\u003Cbr \/\u003E    wininet.dll.InternetOpenA\u003Cbr \/\u003Ekernel32.dll\u003Cbr \/\u003E    kernel32.dll.TlsFree\u003Cbr \/\u003E    kernel32.dll.IsProcessorFeaturePresent\u003Cbr \/\u003E    kernel32.dll.GetStringTypeW\u003Cbr \/\u003E    kernel32.dll.MultiByteToWideChar\u003Cbr \/\u003E    kernel32.dll.LCMapStringW\u003Cbr \/\u003E    kernel32.dll.CreateMutexW\u003Cbr \/\u003E    kernel32.dll.CreateMutexA\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ekernel32.dll.CreateNamedPipeW\u003C\/strong\u003E\u003C\/span\u003E\u003Cspan style=\u0022color: red;\u0022\u003E\u003Cstrong\u003Ekernel32.dll.CreateNamedPipeA\u003C\/strong\u003E\u003C\/span\u003E\u003C\/p\u003E \u003Cpre\u003E \u003Cbr \/\u003Ekernel32.dll.GetCommandLineA\u003Cbr \/\u003E    kernel32.dll.HeapSetInformation\u003Cbr \/\u003E    kernel32.dll.TerminateProcess\u003C\/pre\u003E\u003Cp\u003E\u003Cspan style=\u0022color: red;\u0022\u003EImphash: c259e28326b63577c31ee2c01b25d3fa\u003C\/span\u003E\u003C\/p\u003E \u003Cp\u003EThese examples show that both the ordering of functions within the original source code - as well as the ordering of source files at compile time - will affect the resulting IAT, and therefore the resulting imphash value. Because the source code is not organized the same way, two different binaries with exactly the same imports are highly likely to have different import hashes. Conversely, if two files have the same imphash value, they have the same IAT, which implies that the files were compiled from the same source code, and in the same manner.\u003C\/p\u003E \u003Cp\u003EFor packed samples, simple tools or utilities (with few imports and, based on their simplicity, likely compiled in the same way), the imphash value may not be unique enough to be useful for attribution. In other words, it may be possible for two different threat actors to independently generate tools with the same imphash based on those factors.\u003C\/p\u003E \u003Cp\u003EHowever, for more complex and\/or custom tools (like backdoors), where there are a sufficient number of imports present, the imphash should be relatively unique, and can therefore be used to identify code families that are structurally similar. While files with the same imphash are not guaranteed to originate from the same threat group (it\u0027s possible, for example, for the files were generated by a common builder that is shared among groups) the files can at least be reasonably assumed to have a common origin and may eventually be attributable to a single threat group with additional corroborating information.\u003C\/p\u003E \u003Cp\u003EEmploying this method has given us great success for verifying attacker backdoors over a period of time and demonstrating relationships between backdoors and their associated threat groups.\u003C\/p\u003E \u003Cp\u003EMandiant has submitted a patch that enables the calculation of the imphash value for a given PE to Ero Carrera\u0027s pefile (http:\/\/code.google.com\/p\/pefile\/).\u003C\/p\u003E \u003Cp\u003EExample code:\u003C\/p\u003E \u003Cpre\u003Eimport pefile\u003Cbr \/\u003Epe = pefile.PE(sys.argv[1])\u003Cbr \/\u003Eprint \u0022Import Hash: %s\u0022 % pe.get_imphash()\u003C\/pre\u003E\u003Cp\u003EMandiant uses an imphash convention that requires that the ordinals for a given import be mapped to a specific function. We\u0027ve added a lookup for a couple of DLLs that export functions commonly looked up by ordinal to pefile.\u003C\/p\u003E \u003Cp\u003EMandiant\u0027s imphash convention requires the following:\u003C\/p\u003E \u003Cul\u003E\u003Cli\u003EResolving ordinals to function names when they appear\u003C\/li\u003E\u003Cli\u003EConverting both DLL names and function names to all lowercase\u003C\/li\u003E\u003Cli\u003ERemoving the file extensions from imported module names\u003C\/li\u003E\u003Cli\u003EBuilding and storing the lowercased string . in an ordered list\u003C\/li\u003E\u003Cli\u003EGenerating the MD5 hash of the ordered list\u003C\/li\u003E\u003C\/ul\u003E\u003Cp\u003EThis convention is implemented in pefile.py version 1.2.10-139 starting at line 3618.\u003C\/p\u003E \u003Cp\u003EIf imphash values serve as relatively unique identifiers for malware families (and potentially for specific threat groups), won\u0027t discussing this technique alert attackers and cause them to change their methods? Attackers would need to modify source code (in a way that did not affect the functionality of the malware itself) or change the file order at compile time (assuming the source code is spread across multiple files). While attackers could write tools to modify the imphash, we don\u0027t expect many attackers to care enough to do this.\u003C\/p\u003E \u003Cp\u003EWe believe it is important to add imphash to the lexicon as a way to discuss malware samples at a higher level and to exchange information about attackers and threat groups. For example, incident responders can use imphash values to discuss malware without specifically disclosing which exact sample (specific MD5) is being discussed.\u003C\/p\u003E \u003Cp\u003EConsider a scenario where an attacker compiles 30 variants of its backdoor with different C2 locations and campaign IDs and deploys them to various companies. If a blog post comes out stating that a specific MD5 was identified as part of a campaign, then based on that MD5 the attacker immediately knows what infrastructure (such as C2 domains or associated IP addresses) is at stake and which campaign may be in jeopardy. However, if the malware was identified just by its imphash value, it is possible that the imphash is shared across all 30 of the attacker\u0027s variants. The malware is still identifiable by and can be discussed within the security community, but the attacker doesn\u0027t know which specific samples have been identified or which parts of their infrastructure are in jeopardy.\u003C\/p\u003E \u003Cp\u003ETo demonstrate the effectiveness of this analysis method, we\u0027ve decided to share the imphash values of a few malware families from the Mandiant APT1 report:\u003C\/p\u003E \u003Ctable\u003E\u003Ctbody\u003E\u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Cth\u003EFamily Name\u003C\/th\u003E\u003C\/p\u003E \u003Cp\u003E\u003Cth\u003EImport Hash\u003C\/th\u003E\u003C\/p\u003E \u003Cp\u003E\u003Cth\u003ETotal Imports\u003C\/th\u003E\u003C\/p\u003E \u003Cp\u003E\u003Cth\u003ENumber of\u003C\/p\u003E \u003Cp\u003Ematched\u003C\/p\u003E \u003Cp\u003ESamples\u003C\/th\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003EGREENCAT\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E2c26ec4a570a502ed3e8484295581989\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E74\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E23\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003EGREENCAT\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003Eb722c33458882a1ab65a13e99efe357e\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E74\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E18\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003EGREENCAT\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E2d24325daea16e770eb82fa6774d70f1\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E113\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E13\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003EGREENCAT\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E0d72b49ed68430225595cc1efb43ced9\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E100\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E13\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003ESTARSYPOUND\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E959711e93a68941639fd8b7fba3ca28f\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E62\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E31\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003ECOOKIEBAG\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E4cec0085b43f40b4743dc218c585f2ec\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E79\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E10\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003ENEWSREELS\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E3b10d6b16f135c366fc8e88cba49bc6c\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E77\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E41\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003ENEWSREELS\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E4f0aca83dfe82b02bbecce448ce8be00\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E80\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E10\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003ETABMSGSQL\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003Eee22b62aa3a63b7c17316d219d555891\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E102\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E9\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003EWEBC2\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003Ea1a42f57ff30983efda08b68fedd3cfc\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E63\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E25\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctr\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003EWEBC2\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E7276a74b59de5761801b35c672c9ccb4\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E52\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003Ctd\u003E13\u003C\/td\u003E\u003C\/p\u003E \u003Cp\u003E\u003C\/tr\u003E\u003C\/p\u003E \u003C\/tbody\u003E\u003C\/table\u003E\u003Cp\u003EWe calculated the above malware families and corresponding imphash values over the set of malware from the Mandiant APT1 report released in February 2013. Using the imphash method described above, we calculated imphash values over all the samples, and then counted the total number of samples that matched on each imphash. Using 356 total samples from the report, we were able to identify 11 imphash values that provided significant coverage of their respective families. Pivoting from these imphash values, we were able to identify additional malware samples that further analysis showed were part of the same malware families and attributable to the same threat group.\u003C\/p\u003E \u003Cp\u003EImphash analysis, like any other method, has its limitations and should not be considered a single point of success. Just because two binaries have the same imphash value does not mean they belong to the same threat group, or even that they are part of the same malware family (though there is an increased likelihood that this is the case). Imphash analysis is a low-cost, efficient and valuable way to triage potential malware samples and expand discovery by identifying \u0022interesting\u0022 samples that merit further analysis. The imphash value gives analysts another pivot point when conducting discovery on threat groups and their tools. Employing this method can also yield results in tracking and verifying attacker backdoors over time, and it can assist in exposing relationships between backdoors and threat groups. Happy Hunting!\u003C\/p\u003E \u003C\/div\u003E",
        "jcr:lastModified": "Thu Jan 23 2014 20:20:08 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "admin",
      "text": "\u003Cp\u003ETracking threat groups over time is an important tool to help defenders hunt for evil on networks and conduct effective incident response. Knowing how certain groups operate makes for an efficient investigation and assists in easily identifying threat actor activity.\u003C\/p\u003E ",
      "jcr:lastModified": "Thu Jan 23 2014 20:20:08 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
