{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Tue Dec 01 2020 20:32:52 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Using Speakeasy Emulation Framework Programmatically to Unpack Malware",
    "jcr:versionHistory": "71ece1a7-3995-4bcd-b89f-9015c94c61ce",
    "author": "James T. Bennett",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "f36b7c90-8e5d-4e4b-acdf-f4a03b7af008"
    ],
    "jcr:created": "Tue Dec 01 2020 20:32:52 GMT+0000",
    "cq:lastModified": "Tue Dec 01 2020 20:27:04 GMT+0000",
    "jcr:baseVersion": "f36b7c90-8e5d-4e4b-acdf-f4a03b7af008",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:cap-james-t-bennett",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware-analysis",
      "fireeye-blog-tags:tools",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "05fa0382-2ac7-45a5-9df7-774f8c743dce",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Dec 01 2020 15:30:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003E\u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research.html\/category\/etc\/tags\/fireeye-blog-authors\/cap-andrew-davis\u0022\u003EAndrew Davis\u003C\/a\u003E recently \u003Ca href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2020\/08\/emulation-of-malicious-shellcode-with-speakeasy.html\u0022 adhocenable=\u0022false\u0022\u003Eannounced the public release\u003C\/a\u003E of his new Windows emulation framework named \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\u0022\u003ESpeakeasy\u003C\/a\u003E. While the introductory blog post focused on using Speakeasy as an automated malware sandbox of sorts, this entry will highlight another powerful use of the framework: automated malware unpacking. I will demonstrate, with code examples, how Speakeasy can be used programmatically to:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EBypass unsupported Windows APIs to continue emulation and unpacking\u003C\/li\u003E\n\u003Cli\u003ESave virtual addresses of dynamically allocated code using API hooks\u003C\/li\u003E\n\u003Cli\u003ESurgically direct execution to key areas of code using code hooks\u003C\/li\u003E\n\u003Cli\u003EDump an unpacked PE from emulator memory and fix its section headers\u003C\/li\u003E\n\u003Cli\u003EAid in reconstruction of import tables by querying Speakeasy for symbolic information\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003EInitial Setup\u003C\/h4\u003E\n\u003Cp\u003EOne approach to interfacing with Speakeasy is to create a subclass of Speakeasy\u2019s \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\/blob\/master\/speakeasy\/speakeasy.py\u0022\u003E\u003Cspan class=\u0022code\u0022\u003ESpeakeasy\u003C\/span\u003E\u003C\/a\u003E class. Figure 1 shows a Python code snippet that sets up such a class that will be expanded in upcoming examples.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eimport speakeasy\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eclass MyUnpacker(speakeasy.Speakeasy):\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; def __init__(self, config=None):\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; super(MyUnpacker, self).__init__(config=config)\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Creating a Speakeasy subclass\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe code in Figure 1 accepts a Speakeasy configuration dictionary that may be used to override the default configuration. Speakeasy ships with \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\/tree\/master\/speakeasy\/configs\u0022\u003Eseveral configuration files\u003C\/a\u003E. The \u003Cspan class=\u0022code\u0022\u003ESpeakeasy\u003C\/span\u003E class is a wrapper class for an underlying emulator class. The emulator class is chosen automatically when a binary is loaded based on its PE headers or is specified as shellcode. Subclassing \u003Cspan class=\u0022code\u0022\u003ESpeakeasy\u003C\/span\u003E makes it easy to access, extend, or modify interfaces. It also facilitates reading and writing stateful data before, during, and after emulation.\u003C\/p\u003E\n\u003Ch4\u003EEmulating a Binary\u003C\/h4\u003E\n\u003Cp\u003EFigure 2 shows how to load a binary into the Speakeasy emulator.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Eself.module = self.load_module(filename)\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Loading the binary into the emulator\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003Eload_module\u003C\/span\u003E function returns a \u003Cspan class=\u0022code\u0022\u003EPeFile\u003C\/span\u003E object for the provided binary on disk. It is an instance of the \u003Cspan class=\u0022code\u0022\u003EPeFile\u003C\/span\u003E class defined in \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\/blob\/master\/speakeasy\/windows\/common.py\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Espeakeasy\/windows\/common.py\u003C\/span\u003E\u003C\/a\u003E, which is subclassed from \u003Ca href=\u0022https:\/\/github.com\/erocarrera\/pefile\/blob\/master\/pefile.py\u0022\u003Epefile\u003C\/a\u003E\u2019s \u003Cspan class=\u0022code\u0022\u003EPE\u003C\/span\u003E class. Alternatively, you can provide the bytes of a binary using the \u003Cspan class=\u0022code\u0022\u003Edata\u003C\/span\u003E parameter rather than specifying a file name. Figure 3 shows how to emulate a loaded binary.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Eself.run_module(self.module)\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Starting emulation\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EAPI Hooks\u003C\/h4\u003E\n\u003Cp\u003EThe Speakeasy framework ships with support for hundreds of Windows APIs with more being added frequently. This is accomplished via Python API \u003Ci\u003Ehandlers\u003C\/i\u003E defined in appropriate files in the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\/tree\/master\/speakeasy\/winenv\/api\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Espeakeasy\/winenv\/api\u003C\/span\u003E\u003C\/a\u003E directory. API \u003Ci\u003Ehooks\u003C\/i\u003E can be installed to have your own code executed when particular APIs are called during emulation. They can be installed for any API, regardless of whether a handler exists or not. An API hook can be used to override an existing handler and that handler can optionally be invoked from your hook. The API hooking mechanism in Speakeasy provides flexibility and control over emulation. Let\u2019s examine a few uses of API hooking within the context of emulating unpacking code to retrieve an unpacked payload.\u003C\/p\u003E\n\u003Ch4\u003EBypassing Unsupported APIs\u003C\/h4\u003E\n\u003Cp\u003EWhen Speakeasy encounters an unsupported Windows API call, it stops emulation and provides the name of the API function that is not supported. If the API function in question is not critical for unpacking the binary, you can add an API hook that simply returns a value that allows execution to continue. For example, a recent sample\u2019s unpacking code contained API calls that had no effect on the unpacking process. One such API call was to \u003Cspan class=\u0022code\u0022\u003EGetSysColor\u003C\/span\u003E. In order to bypass this call and allow execution to continue, an API hook may be added as shown in Figure 4.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Eself.add_api_hook(self.getsyscolor_hook,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0027user32\u0027,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0027GetSysColor\u0027,\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; argc=1\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; )\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Adding an API hook\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAccording to \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/winuser\/nf-winuser-getsyscolor\u0022\u003EMSDN\u003C\/a\u003E, this function takes 1 parameter and returns an RGB color value represented as a \u003Cspan class=\u0022code\u0022\u003EDWORD\u003C\/span\u003E. If the calling convention for the API function you are hooking is not \u003Cspan class=\u0022code\u0022\u003Estdcall\u003C\/span\u003E, you can specify the calling convention in the optional \u003Cspan class=\u0022code\u0022\u003Ecall_conv parameter\u003C\/span\u003E. The calling convention constants are defined in the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\/blob\/master\/speakeasy\/winenv\/arch.py\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Espeakeasy\/common\/arch.py\u003C\/span\u003E\u003C\/a\u003E file. Because the \u003Cspan class=\u0022code\u0022\u003EGetSysColor\u003C\/span\u003E return value does not impact the unpacking process, we can simply return \u003Cspan class=\u0022code\u0022\u003E0\u003C\/span\u003E. Figure 5 shows the definition of the \u003Cspan class=\u0022code\u0022\u003Egetsyscolor_hook\u003C\/span\u003E function specified in Figure 4.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Edef getsyscolor_hook(self, emu, api_name, func, params):\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; return 0\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: The GetSysColor hook returns 0\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIf an API function requires more finessed handling, you can implement a more specific and meaningful hook that suits your needs. If your hook implementation is robust enough, you might consider contributing it to the Speakeasy project as an API handler! \u0026nbsp;\u003C\/p\u003E\n\u003Ch4\u003EAdding an API Handler\u003C\/h4\u003E\n\u003Cp\u003EWithin the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\/tree\/master\/speakeasy\/winenv\/api\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Espeakeasy\/winenv\/api\u003C\/span\u003E\u003C\/a\u003E directory you\u0027ll find \u003Cspan class=\u0022code\u0022\u003Eusermode\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Ekernelmode\u003C\/span\u003E subdirectories that contain Python files for corresponding binary modules. These files contain the API handlers for each module. In \u003Cspan class=\u0022code\u0022\u003Eusermode\/kernel32.py\u003C\/span\u003E, we see a handler defined for \u003Cspan class=\u0022code\u0022\u003ESetEnvironmentVariable\u003C\/span\u003E as shown in Figure 6.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E1: @apihook(\u0027SetEnvironmentVariable\u0027, argc=2)\u003Cbr\u003E\n 2: def SetEnvironmentVariable(self, emu, argv, ctx={}):\u003Cbr\u003E\n 3:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0027\u0027\u0027\u003Cbr\u003E\n 4:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; BOOL SetEnvironmentVariable(\u003Cbr\u003E\n 5:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; LPCTSTR lpName,\u003Cbr\u003E\n 6:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; LPCTSTR lpValue\u003Cbr\u003E\n 7:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; );\u003Cbr\u003E\n 8:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0027\u0027\u0027\u003Cbr\u003E\n 9:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; lpName, lpValue = argv\u003Cbr\u003E\n 10:\u0026nbsp;\u0026nbsp;\u0026nbsp; cw = self.get_char_width(ctx)\u003Cbr\u003E\n 11:\u0026nbsp;\u0026nbsp;\u0026nbsp; if lpName and lpValue:\u003Cbr\u003E\n 12:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; name = self.read_mem_string(lpName, cw)\u003Cbr\u003E\n 13:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; val = self.read_mem_string(lpValue, cw)\u003Cbr\u003E\n 14:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argv[0] = name\u003Cbr\u003E\n 15:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argv[1] = val\u003Cbr\u003E\n 16:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; emu.set_env(name, val)\u003Cbr\u003E\n 17:\u0026nbsp;\u0026nbsp;\u0026nbsp; return True\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: API handler for SetEnvironmentVariable\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EA handler begins with a function decorator (line 1) that defines the name of the API and the number of parameters it accepts. At the start of a handler, it is good practice to include MSDN\u0027s documented prototype as a comment (lines 3-8).\u003C\/p\u003E\n\u003Cp\u003EThe handler\u0027s code begins by storing elements of the \u003Cspan class=\u0022code\u0022\u003Eargv\u003C\/span\u003E parameter in variables named after their corresponding API parameters (line 9). The handler\u0027s \u003Cspan class=\u0022code\u0022\u003Ectx\u003C\/span\u003E parameter is a dictionary that contains contextual information about the API call. For API functions that end in an \u2018\u003Cspan class=\u0022code\u0022\u003EA\u003C\/span\u003E\u2019 or \u2018\u003Cspan class=\u0022code\u0022\u003EW\u003C\/span\u003E\u2019 (e.g., \u003Cspan class=\u0022code\u0022\u003ECreateFileA\u003C\/span\u003E), the character width can be retrieved by passing the \u003Cspan class=\u0022code\u0022\u003Ectx\u003C\/span\u003E parameter to the \u003Cspan class=\u0022code\u0022\u003Eget_char_width\u003C\/span\u003E function (line 10). This width value can then be passed to calls such as \u003Cspan class=\u0022code\u0022\u003Eread_mem_string\u003C\/span\u003E (lines 12 and 13), which reads the emulator\u2019s memory at a given address and returns a string.\u003C\/p\u003E\n\u003Cp\u003EIt is good practice to overwrite string pointer values in the \u003Cspan class=\u0022code\u0022\u003Eargv\u003C\/span\u003E parameter with their corresponding string values (lines 14 and 15). This enables Speakeasy to display string values instead of pointer values in its API logs. To illustrate the impact of updating \u003Cspan class=\u0022code\u0022\u003Eargv\u003C\/span\u003E values, examine the Speakeasy output shown in Figure 7. In the \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E entry, the symbolic constant string \u003Cspan class=\u0022code\u0022\u003EPAGE_EXECUTE_READWRITE\u003C\/span\u003E replaces the value \u003Cspan class=\u0022code\u0022\u003E0x40\u003C\/span\u003E. In the \u003Cspan class=\u0022code\u0022\u003EGetModuleFileNameA\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003ECreateFileA\u003C\/span\u003E entries, pointer values are replaced with a file path.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003EKERNEL32.VirtualAlloc(0x0, 0x2b400, 0x3000, \u0026quot;PAGE_EXECUTE_READWRITE\u0026quot;) -\u0026gt; 0x7c000\u003Cbr\u003E\n KERNEL32.GetModuleFileNameA(0x0, \u0026quot;C:\\\\Windows\\\\system32\\\\sample.exe\u0026quot;, 0x104) -\u0026gt; 0x58\u003Cbr\u003E\n KERNEL32.CreateFileA(\u0026quot;C:\\\\Windows\\\\system32\\\\sample.exe\u0026quot;, \u0026quot;GENERIC_READ\u0026quot;, 0x1, 0x0, \u0026quot;OPEN_EXISTING\u0026quot;, 0x80, 0x0) -\u0026gt; 0x84\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Speakeasy API logs\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ESaving the Unpacked Code Address\u003C\/h4\u003E\n\u003Cp\u003EPacked samples often use functions such as \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E to allocate memory used to store the unpacked sample. An effective approach for capturing the location and size of the unpacked code is to first hook the memory allocation function used by the unpacking stub. Figure 8\u0026nbsp;shows an example of hooking \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E to capture the virtual address and amount of memory being allocated by the API call.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E1: def virtualalloc_hook(self, emu, api_name, func, params):\u003Cbr\u003E\n 2:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0027\u0027\u0027\u003Cbr\u003E\n 3:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; LPVOID VirtualAlloc(\u003Cbr\u003E\n 4:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; LPVOID lpAddress,\u003Cbr\u003E\n 5:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; SIZE_T dwSize,\u003Cbr\u003E\n 6:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; DWORD\u0026nbsp; flAllocationType,\u003Cbr\u003E\n 7:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; DWORD\u0026nbsp; flProtect\u003Cbr\u003E\n 8:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; );\u003Cbr\u003E\n 9:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0027\u0027\u0027\u003Cbr\u003E\n 10:\u0026nbsp;\u0026nbsp;\u0026nbsp; PAGE_EXECUTE_READWRITE = 0x40\u003Cbr\u003E\n 11:\u0026nbsp;\u0026nbsp;\u0026nbsp; lpAddress, dwSize, flAllocationType, flProtect = params\u003Cbr\u003E\n 12:\u0026nbsp;\u0026nbsp;\u0026nbsp; rv = func(params)\u003Cbr\u003E\n 13:\u0026nbsp;\u0026nbsp;\u0026nbsp; if lpAddress == 0 and flProtect == PAGE_EXECUTE_READWRITE:\u003Cbr\u003E\n 14:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; self.logger.debug(\u0026quot;[*] unpack stub VirtualAlloc call, saving dump info\u0026quot;)\u003Cbr\u003E\n 15:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; self.dump_addr = rv\u003Cbr\u003E\n 16:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; self.dump_size = dwSize\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E17:\u0026nbsp;\u0026nbsp;\u0026nbsp; return rv\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: VirtualAlloc hook to save memory dump information\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe hook in Figure 8 calls Speakeasy\u2019s API handler for \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E on line 12 to allow memory to be allocated. The virtual address returned by the API handler is saved to a variable named \u003Cspan class=\u0022code\u0022\u003Erv\u003C\/span\u003E. Since \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E may be used to allocate memory not related to the unpacking process, additional checks are used on line 13 to confirm the intercepted \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E call is the one used in the unpacking code. Based on prior analysis, we\u2019re looking for a \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E call that receives the \u003Cspan class=\u0022code\u0022\u003ElpAddress\u003C\/span\u003E value \u003Cspan class=\u0022code\u0022\u003E0\u003C\/span\u003E and the \u003Cspan class=\u0022code\u0022\u003EflProtect\u003C\/span\u003E value \u003Cspan class=\u0022code\u0022\u003EPAGE_EXECUTE_READWRITE\u003C\/span\u003E (\u003Cspan class=\u0022code\u0022\u003E0x40\u003C\/span\u003E). If these arguments are present, the virtual address and specified size are stored on lines 15 and 16 so they may be used to extract the unpacked payload from memory after the unpacking code is finished. Finally, on line 17, the return value from the \u003Cspan class=\u0022code\u0022\u003EVirtualAlloc\u003C\/span\u003E handler is returned by the hook.\u003C\/p\u003E\n\u003Ch4\u003ESurgical Code Emulation Using API and Code Hooks\u003C\/h4\u003E\n\u003Cp\u003ESpeakeasy is a robust emulation framework; however, you may encounter binaries that have large sections of problematic code. For example, a sample may call many unsupported APIs or simply take far too long to emulate. An example of overcoming both challenges is described in the following scenario.\u003C\/p\u003E\n\u003Ch4\u003EUnpacking Stubs Hiding in MFC Projects\u003C\/h4\u003E\n\u003Cp\u003EA popular technique used to disguise malicious payloads involves hiding them inside a large, open-source MFC project. MFC is short for \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/cpp\/mfc\/mfc-desktop-applications?redirectedfrom=MSDN\u0026amp;view=vs-2019\u0022\u003EMicrosoft Foundation Class\u003C\/a\u003E, which is a popular library used to build Windows desktop applications. These MFC projects are often arbitrarily chosen from popular Web sites such as \u003Ca href=\u0022https:\/\/www.codeproject.com\/\u0022\u003ECode Project\u003C\/a\u003E. While the MFC library makes it easy to create desktop applications, MFC applications are difficult to reverse engineer due to their size and complexity. They are particularly difficult to emulate due to their large initialization routine that calls many different Windows APIs. What follows is a description of my experience with writing a Python script using Speakeasy to automate unpacking of a custom packer that hides its unpacking stub within an MFC project.\u003C\/p\u003E\n\u003Cp\u003EReverse engineering the packer revealed the unpacking stub is ultimately called during initialization of the \u003Cspan class=\u0022code\u0022\u003ECWinApp\u003C\/span\u003E object, which occurs after initialization of the C runtime and MFC. After attempting to bypass unsupported APIs, I realized that, even if successful, emulation would take far too long to be practical. I considered skipping over the initialization code completely and jumping straight to the unpacking stub. Unfortunately, execution of the C-runtime initialization code was required in order for emulation of the unpacking stub to succeed.\u003C\/p\u003E\n\u003Cp\u003EMy solution was to identify a location in the code that fell after the C-runtime initialization but was early in the MFC initialization routine. After examining the Speakeasy API log shown in Figure 9, such a location was easy to spot. The graphics-related API function \u003Cspan class=\u0022code\u0022\u003EGetDeviceCaps\u003C\/span\u003E is invoked early in the MFC initialization routine. This was deduced based on 1) MFC is a graphics-dependent framework and 2) \u003Cspan class=\u0022code\u0022\u003EGetDeviceCaps\u003C\/span\u003E is unlikely to be called during C-runtime initialization.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E0x43e0a7: \u0027kernel32.FlsGetValue(0x0)\u0027 -\u0026gt; 0x4150\u003Cbr\u003E\n 0x43e0e3: \u0027kernel32.DecodePointer(0x7049)\u0027 -\u0026gt; 0x7048\u003Cbr\u003E\n 0x43b16a: \u0027KERNEL32.HeapSize(0x4130, 0x0, 0x7000)\u0027 -\u0026gt; 0x90\u003Cbr\u003E\n 0x43e013: \u0027KERNEL32.TlsGetValue(0x0)\u0027 -\u0026gt; 0xfeee0001\u003Cbr\u003E\n 0x43e02a: \u0027KERNEL32.TlsGetValue(0x0)\u0027 -\u0026gt; 0xfeee0001\u003Cbr\u003E\n 0x43e02c: \u0027kernel32.FlsGetValue(0x0)\u0027 -\u0026gt; 0x4150\u003Cbr\u003E\n 0x43e068: \u0027kernel32.EncodePointer(0x44e215)\u0027 -\u0026gt; 0x44e216\u003Cbr\u003E\n 0x43e013: \u0027KERNEL32.TlsGetValue(0x0)\u0027 -\u0026gt; 0xfeee0001\u003Cbr\u003E\n 0x43e02a: \u0027KERNEL32.TlsGetValue(0x0)\u0027 -\u0026gt; 0xfeee0001\u003Cbr\u003E\n 0x43e02c: \u0027kernel32.FlsGetValue(0x0)\u0027 -\u0026gt; 0x4150\u003Cbr\u003E\n 0x43e068: \u0027kernel32.EncodePointer(0x704c)\u0027 -\u0026gt; 0x704d\u003Cbr\u003E\n 0x43c260: \u0027KERNEL32.LeaveCriticalSection(0x466f28)\u0027 -\u0026gt; None\u003Cbr\u003E\n 0x422151: \u0027USER32.GetSystemMetrics(0xb)\u0027 -\u0026gt; 0x1\u003Cbr\u003E\n 0x422158: \u0027USER32.GetSystemMetrics(0xc)\u0027 -\u0026gt; 0x1\u003Cbr\u003E\n 0x42215f: \u0027USER32.GetSystemMetrics(0x2)\u0027 -\u0026gt; 0x1\u003Cbr\u003E\n 0x422169: \u0027USER32.GetSystemMetrics(0x3)\u0027 -\u0026gt; 0x1\u003Cbr\u003E\n \u003Cb style=\u0022font-size: 12px;\u0022\u003E0x422184: \u0027GDI32.GetDeviceCaps(0x288, 0x58)\u0027 -\u0026gt; None\u003C\/b\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Identifying beginning of MFC code in Speakeasy API logs\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ETo intercept execution at this stage I created an API hook for \u003Cspan class=\u0022code\u0022\u003EGetDeviceCaps\u003C\/span\u003E as shown in Figure 10. The hook confirms the function is being called for the first time on line 2.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E1: def mfc_init_hook(self, emu, api_name, func, params):\u003Cbr\u003E\n 2:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; if not self.trigger_hit:\u003Cbr\u003E\n 3:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; self.trigger_hit = True\u003Cbr\u003E\n 4:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; self.h_code_hook =\u0026nbsp;\u0026nbsp; self.add_code_hook(self.start_unpack_func_hook)\u003Cbr\u003E\n 5:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; self.logger.debug(\u0026quot;[*] MFC init api hit, starting unpack function\u0026quot;)\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: API hook set for GetDeviceCaps\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ELine 4 shows the creation of a code hook using the \u003Cspan class=\u0022code\u0022\u003Eadd_code_hook\u003C\/span\u003E function of the \u003Cspan class=\u0022code\u0022\u003ESpeakeasy\u003C\/span\u003E class. Code hooks allow you to specify a callback function that is called before each instruction that is emulated. Speakeasy also allows you to optionally specify an address range for which the code hook will be effective by specifying \u003Cspan class=\u0022code\u0022\u003Ebegin\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Eend\u003C\/span\u003E parameters.\u003C\/p\u003E\n\u003Cp\u003EAfter the code hook is added on line 4, the \u003Cspan class=\u0022code\u0022\u003EGetDeviceCaps\u003C\/span\u003E hook completes and, prior to the execution of the sample\u0027s next instruction, the \u003Cspan class=\u0022code\u0022\u003Estart_unpack_func_hook\u003C\/span\u003E function is called. This function is shown in Figure 11.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E1: def start_unpack_func_hook(self, emu, addr, size, ctx):\u003Cbr\u003E\n 2: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self.h_code_hook.disable()\u003Cbr\u003E\n 3: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;unpack_func_va = self.module.get_rva_from_offset(self.unpack_offs) + self.module.get_base()\u003Cbr\u003E\n 4: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self.set_pc(unpack_func_va)\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Code hook that changes the instruction pointer\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe code hook receives the emulator object, the address and size of the current instruction, and the context dictionary (line 1). On line 2, the code hook disables itself. Because code hooks are executed with each instruction, this slows emulation significantly. Therefore, they should be used sparingly and disabled as soon as possible. On line 3, the hook calculates the virtual address of the unpacking function. The offset used to perform this calculation was located using a regular expression. This part of the example was omitted for the sake of brevity.\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003Eself.module\u003C\/span\u003E attribute was previously set in the example code shown in Figure 2. It being subclassed from the \u003Cspan class=\u0022code\u0022\u003EPE\u003C\/span\u003E class of \u003Cspan class=\u0022code\u0022\u003Epefile\u003C\/span\u003E allows us to access useful functions such as \u003Cspan class=\u0022code\u0022\u003Eget_rva_from_offset()\u003C\/span\u003E on line 3. This line also includes an example of \u003Cspan class=\u0022code\u0022\u003Eusing self.module.get_base()\u003C\/span\u003E to retrieve the module\u0027s base virtual address.\u003C\/p\u003E\n\u003Cp\u003EFinally, on line 4, the instruction pointer is changed using the \u003Cspan class=\u0022code\u0022\u003Eset_pc\u003C\/span\u003E function and emulation continues at the unpacking code. The code snippets in Figure 10 and Figure 11 allowed us to redirect execution to the unpacking code after the C-runtime initialization completed and avoid MFC initialization code.\u003C\/p\u003E\n\u003Ch4\u003EDumping and Fixing Unpacked PEs\u003C\/h4\u003E\n\u003Cp\u003EOnce emulation has reached the original entry point of the unpacked sample, it is time to dump the PE and fix it up. Typically, a hook would save the base address of the unpacked PE in an attribute of the class as illustrated on line 15 of Figure 8. If the unpacked PE does not contain the correct entry point in its PE headers, the true entry point may also need to be captured during emulation. Figure 12 shows an example of how to dump emulator memory to a file.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Ewith open(self.output_path, \u0026quot;wb\u0026quot;) as up:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; mm = self.get_address_map(self.dump_addr)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; up.write(self.mem_read(mm.get_base(), mm.get_size()))\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: Dumping the unpacked PE\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIf you are dumping a PE that has already been loaded in memory, it will not have the same layout as it does on disk due to differences in section alignment. As a result, the dumped PE\u0027s headers may need to be modified. One approach is to modify each section\u0027s \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/winnt\/ns-winnt-image_section_header\u0022\u003E\u003Cspan class=\u0022code\u0022\u003EPointerToRawData\u003C\/span\u003E\u003C\/a\u003E value to match its \u003Cspan class=\u0022code\u0022\u003EVirtualAddress\u003C\/span\u003E field. Each section\u0027s \u003Cspan class=\u0022code\u0022\u003ESizeOfRawData\u003C\/span\u003E value may need to be padded in order conform with the \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/winnt\/ns-winnt-image_optional_header32\u0022\u003E\u003Cspan class=\u0022code\u0022\u003EFileAlignment\u003C\/span\u003E\u003C\/a\u003E value specified in the PE\u2019s optional headers. Keep in mind the resulting PE is unlikely to execute successfully. However, these efforts will allow most static analysis tools to function correctly.\u003C\/p\u003E\n\u003Cp\u003EThe final step for repairing the dumped PE is to fix its import table. This is a complex task deserving of its own blog post and will not be discussed in detail here. However, the first step involves collecting a list of library function names and their addresses in emulator memory. If you know the \u003Cspan class=\u0022code\u0022\u003EGetProcAddress\u003C\/span\u003E API is used by the unpacker stub to resolve imports for the unpacked PE, you can call the \u003Cspan class=\u0022code\u0022\u003Eget_dyn_imports\u003C\/span\u003E function as shown in Figure 13.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Eapi_addresses = self.get_dyn_imports()\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 13: Retrieving dynamic imports\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOtherwise, you can query the emulator class to retrieve its symbol information by calling the \u003Cspan class=\u0022code\u0022\u003Eget_symbols\u003C\/span\u003E function as shown in Figure 14.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003Esymbols = self.get_symbols()\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 14: Retrieve symbol information from emulator class\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis data can be used to discover the IAT of the unpacked PE and fix or reconstruct its import related tables.\u003C\/p\u003E\n\u003Ch4\u003EPutting It All Together\u003C\/h4\u003E\n\u003Cp\u003EWriting a Speakeasy script to unpack a malware sample can be broken down into the following steps:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EReverse engineer the unpacking stub to identify: 1) where the unpacked code will reside or where its memory is allocated, 2) where execution is transferred to the unpacked code, and 3) any problematic code that may introduce issues such as unsupported APIs, slow emulation, or anti-analysis checks.\u003C\/li\u003E\n\u003Cli\u003EIf necessary, set hooks to bypass problematic code.\u003C\/li\u003E\n\u003Cli\u003ESet a hook to identify the virtual address and, optionally, the size of the unpacked binary.\u003C\/li\u003E\n\u003Cli\u003ESet a hook to stop emulation at, or after, execution of the original entry point of the unpacked code.\u003C\/li\u003E\n\u003Cli\u003ECollect virtual addresses of Windows APIs and reconstruct the PE\u2019s import table.\u003C\/li\u003E\n\u003Cli\u003EFix the PE\u2019s headers (if applicable) and write the bytes to a file for further analysis.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EFor an example of a script that unpacks UPX samples, check out the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/speakeasy\/blob\/master\/examples\/upx_unpack.py\u0022\u003EUPX unpacking script\u003C\/a\u003E in the Speakeasy repository.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EThe \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/speakeasy\u0022\u003ESpeakeasy framework\u003C\/a\u003E provides an easy-to-use, flexible, and powerful programming interface that enables analysts to solve complex problems such as unpacking malware. Using Speakeasy to automate these solutions allows them to be performed at scale. I hope you enjoyed this introduction to automating the Speakeasy framework and are inspired to begin using it to implement your own malware analysis solutions!\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue Dec 01 2020 20:14:17 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EThe Speakeasy framework\u0026nbsp;provides an easy-to-use, flexible, and powerful programming interface that enables analysts to solve complex problems such as unpacking malware.\u003C\/p\u003E\n",
      "jcr:lastModified": "Tue Dec 01 2020 18:46:10 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Tue Dec 01 2020 20:27:04 GMT+0000",
      "imageRotate": "0"
    }
  }
}
