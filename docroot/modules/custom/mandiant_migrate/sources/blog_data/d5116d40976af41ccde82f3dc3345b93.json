{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Thu Nov 29 2018 12:00:20 GMT-0500",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Obfuscated Command Line Detection Using Machine Learning",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "20f64ba0-7651-4bde-8b4e-c70e4f11b979",
    "author": "Vikram Hegde",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "lynda.hall@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "c5118932-9d3e-46cb-b350-0cd5117af3b2"
    ],
    "jcr:created": "Tue May 14 2019 17:55:51 GMT-0400",
    "cq:lastReplicated": "Tue May 14 2019 17:55:49 GMT-0400",
    "cq:lastModified": "Tue May 14 2019 17:55:39 GMT-0400",
    "jcr:baseVersion": "c5118932-9d3e-46cb-b350-0cd5117af3b2",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:vikram-hegde",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:machine-learning",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:obfuscation"
    ],
    "jcr:uuid": "46882c64-7621-4f10-9f2d-0592f1e606c4",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Nov 29 2018 12:00:00 GMT-0500",
    "cq:lastModifiedBy": "lynda.hall@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
        "text": "\u003Cp\u003EThis blog post presents a machine learning (ML) approach to solving an emerging security problem: detecting obfuscated Windows command line invocations on endpoints. We start out with an introduction to this relatively new threat capability, and then discuss how such problems have traditionally been handled. We then describe a machine learning approach to solving this problem and point out how ML vastly simplifies development and maintenance of a robust obfuscation detector. Finally, we present the results obtained using two different ML techniques and compare the benefits of each.\u003C\/p\u003E\n\u003Ch4\u003EIntroduction\u003C\/h4\u003E\n\u003Cp\u003EMalicious actors are increasingly \u201cliving off the land,\u201d using built-in utilities such as PowerShell and the Windows Command Processor (cmd.exe) as part of their infection workflow in an effort to \u003Ca href=\u0022https:\/\/www.trendmicro.com\/vinfo\/us\/security\/news\/security-technology\/security-101-the-rise-of-fileless-threats-that-abuse-powershell\u0022\u003Eminimize the chance of detection and bypass whitelisting\u003C\/a\u003E defense strategies. The release of new obfuscation tools makes detection of these threats even more difficult by adding a layer of indirection between the visible syntax and the final behavior of the command. For example, \u003Ca href=\u0022https:\/\/github.com\/danielbohannon\/Invoke-Obfuscation\u0022\u003EInvoke-Obfuscation\u003C\/a\u003E and Invoke-DOSfuscation are two recently released tools that \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2018\/03\/dosfuscation-exploring-obfuscation-and-detection-techniques.html\u0022\u003Eautomate the obfuscation of Powershell and Windows command lines\u003C\/a\u003E respectively.\u003C\/p\u003E\n\u003Cp\u003EThe traditional pattern matching and rule-based approaches for detecting obfuscation are difficult to develop and generalize, and can pose a huge maintenance headache for defenders. We will show how using ML techniques can address this problem.\u003C\/p\u003E\n\u003Cp\u003EDetecting obfuscated command lines is a very useful technique because it allows defenders to reduce the data they must review by providing a strong filter for possibly malicious activity. While there are some examples of \u201clegitimate\u201d obfuscation in the wild, in the overwhelming majority of cases, the presence of obfuscation generally serves as a signal for malicious intent.\u003C\/p\u003E\n\u003Ch4\u003EBackground\u003C\/h4\u003E\n\u003Cp\u003EThere has been a long history of obfuscation being employed to \u003Ca href=\u0022https:\/\/blogs.cisco.com\/security\/a_brief_history_of_malware_obfuscation_part_1_of_2\u0022\u003Ehide the presence of malware\u003C\/a\u003E, ranging from encryption of malicious payloads (starting with the \u003Ca href=\u0022https:\/\/www.f-secure.com\/v-descs\/cascade.shtml\u0022\u003ECascade virus\u003C\/a\u003E) and obfuscation of strings, to \u003Ca href=\u0022http:\/\/www.cse.psu.edu\/~sxz16\/papers\/malware.pdf\u0022\u003EJavaScript obfuscation\u003C\/a\u003E. The purpose of obfuscation is two-fold:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EMake it harder to find patterns in executable code, strings or scripts that can easily be detected by defensive software.\u003C\/li\u003E\n\u003Cli\u003EMake it harder for reverse engineers and analysts to decipher and fully understand what the malware is doing.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EIn that sense, command line obfuscation is not a new problem \u2013 it is just that the \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/06\/obfuscation-in-the-wild.html\u0022\u003Etarget of obfuscation\u003C\/a\u003E (the Windows Command Processor) is relatively new. The recent release of tools such as Invoke-Obfuscation (for PowerShell) and Invoke-DOSfuscation (for cmd.exe) have demonstrated just how flexible these commands are, and how even incredibly complex obfuscation will still run commands effectively.\u003C\/p\u003E\n\u003Cp\u003EThere are two categorical axes in the space of obfuscated vs. non-obfuscated command lines: simple\/complex and clear\/obfuscated (see Figure 1 and Figure 2). For this discussion \u201csimple\u201d means generally short and relatively uncomplicated, but can still contain obfuscation, while \u201ccomplex\u201d means long, complicated strings that may or may not be obfuscated. Thus, the simple\/complex axis is orthogonal to obfuscated\/unobfuscated. The interplay of these two axes produce many boundary cases where simple heuristics to detect if a script is obfuscated (e.g. length of a command) will produce false positives on unobfuscated samples. The flexibility of the command line processor makes classification a difficult task from an ML perspective.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Dimensions of obfuscation\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Examples of weak and strong obfuscation\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ETraditional Obfuscation Detection\u003C\/h4\u003E\n\u003Cp\u003ETraditional obfuscation detection can be split into three approaches. One approach is to write a large number of complex regular expressions to match the most commonly abused syntax of the Windows command line. Figure 3 shows one such regular expression that attempts to match ampersand chaining with a call command, a common pattern seen in obfuscation. Figure 4 shows an example command sequence this regex is designed to detect.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: A common obfuscation pattern captured as a regular expression\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: A common obfuscation pattern (calling echo in obfuscated fashion in this example)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThere are two problems with this approach. First, it is virtually impossible to develop regular expressions to cover every possible abuse of the command line. The flexibility of the command line results in a \u003Ca href=\u0022https:\/\/stackoverflow.com\/questions\/898489\/what-programming-languages-are-context-free\u0022\u003Enon-regular language\u003C\/a\u003E, which is feasible yet impractical to express using regular expressions. A second issue with this approach is that even if a regular expression exists for the technique a malicious sample is using, a determined attacker can make minor modifications to avoid the regular expression. Figure 5 shows a minor modification to the sequence in Figure 4, which avoids the regex detection.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: A minor change (extra carets) to an obfuscated command line that breaks the regular expression in Figure 3\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe second approach, which is closer to an ML approach, involves writing complex if-then rules. However, these rules are hard to derive, are complex to verify, and pose a significant maintenance burden as authors evolve to escape detection by such rules. Figure 6 shows one such if-then rule.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: An if-then rule that *may* indicate obfuscation (notice how loose this rule is, and how false positives are likely)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EA third approach is to combine regular expressions and if-then rules. This greatly complicates the development and maintenance burden, and still suffers from the same weaknesses that make the first two approaches fragile. Figure 7 shows an example of an if-then rule with regular expressions. Clearly, it is easy to appreciate how burdensome it is to generate, test, maintain and determine the efficacy of such rules.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: A combination of an if-then rule with regular expressions to detect obfuscation (a real hand-built obfuscation detector would consist of tens or hundreds of rules and still have gaps in its detection)\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EThe ML Approach \u2013 Moving Beyond Pattern Matching and Rules\u003C\/h4\u003E\n\u003Cp\u003EUsing ML simplifies the solution to these problems. We will illustrate two ML approaches: a feature-based approach and a feature-less end-to-end approach.\u003C\/p\u003E\n\u003Cp\u003EThere are some ML techniques that can work with any kind of raw data (provided it is numeric), and neural networks are a prime example. Most other ML algorithms require the modeler to extract pertinent information, called \u003Ci\u003Efeatures\u003C\/i\u003E, from raw data before they are fed into the algorithm. Some examples of this latter type are tree-based algorithms, which we will also look at in this blog (we described the \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2018\/06\/build-machine-learning-models-for-the-soc.html\u0022\u003Estructure and uses of Tree-Based algorithms\u003C\/a\u003E in a previous blog post, where we used a Gradient-Boosted Tree-Based Model).\u003C\/p\u003E\n\u003Ch4\u003EML Basics \u2013 Neural Networks\u003C\/h4\u003E\n\u003Cp\u003ENeural networks are a type of ML algorithm that have recently become very popular and consist of a series of elements called \u003Ci\u003Eneuron\u003C\/i\u003Es. A neuron is essentially an element that takes a set of inputs, computes a weighted sum of these inputs, and then feeds the sum into a non-linear function. It has been shown that a relatively shallow network of neurons can approximate any continuous mapping between input and output. The specific type of neural network we used for this research is what is called a Convolutional Neural Network (CNN), which was developed primarily for computer vision applications, but has also found success in other domains including natural language processing. One of the main benefits of a neural network is that it can be trained without having to manually engineer features.\u003C\/p\u003E\n\u003Ch4\u003EFeatureless ML\u003C\/h4\u003E\n\u003Cp\u003EWhile neural networks can be used with feature data, one of the attractions of this approach is that it can \u003Ca href=\u0022https:\/\/iksinc.online\/2015\/12\/18\/feature-engineering-and-deep-learning\/\u0022\u003Ework with raw data\u003C\/a\u003E (converted into numeric form) without doing any feature design or extraction. The first step in the model is converting text data into numeric form. We used a character-based encoding where each character type was encoded by a real valued number. The value was automatically derived during training and conveys semantic information about the relationships between characters as they apply to cmd.exe syntax.\u003C\/p\u003E\n\u003Ch4\u003EFeature-Based ML\u003C\/h4\u003E\n\u003Cp\u003EWe also experimented with hand-engineered features and a Gradient Boosted Decision Tree algorithm.\u0026nbsp;The features developed for this model were largely statistical in nature \u2013 derived from the presence and frequency of character sets and keywords. For example, the presence of dozens of \u2018%\u2019 characters or long, contiguous strings might contribute to detecting potential obfuscation. While any single feature will not perfectly separate the two classes, a combination of features as present in a tree-based model can learn flexible patterns in the data. The expectation is that those patterns are robust and can generalize to future obfuscation variants.\u003C\/p\u003E\n\u003Ch4\u003EData and Experiments\u003C\/h4\u003E\n\u003Cp\u003ETo develop our models, we collected non-obfuscated data from tens of thousands of endpoint events and generated obfuscated data using a variety of methods in Invoke-DOSfuscation. We developed our models using roughly 80 percent of the data as training data, and tested them on the remaining 20 percent. We ensured that our train-test split was stratified. For featureless ML (i.e. neural networks), we simply input Unicode code points into the first layer of the CNN model. The first layer converts the code point into semantically meaningful numerical representations (called embeddings) before feeding it into the rest of the neural network.\u003C\/p\u003E\n\u003Cp\u003EFor the Gradient Boosted Tree method, we generated a number of features from the raw command lines. The following are some of them:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003ELength of the command line\u003C\/li\u003E\n\u003Cli\u003EThe number of carets in the command line\u003C\/li\u003E\n\u003Cli\u003EThe count of pipe symbols\u003C\/li\u003E\n\u003Cli\u003EThe fraction of white space in the command line\u003C\/li\u003E\n\u003Cli\u003EThe fraction of special characters\u003C\/li\u003E\n\u003Cli\u003EEntropy of the string\u003C\/li\u003E\n\u003Cli\u003EThe frequency of the strings \u201ccmd\u201d and \u201cpower\u201d in the command line\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EWhile each of these features individually is a weak signal and could not possibly be a good discriminator on its own, a flexible classifier such as a Gradient Boosted Tree \u2013 trained on sufficient data with these features \u2013 is able to classify obfuscated and non-obfuscated command lines in spite of the aforementioned difficulties.\u003C\/p\u003E\n\u003Ch4\u003EResults\u003C\/h4\u003E\n\u003Cp\u003EEvaluated against our test set, we were able to get nearly identical results from our Gradient Boosted Tree and neural network models.\u003C\/p\u003E\n\u003Cp\u003EThe results for the GBT model were near perfect with metrics such as F1-score, precision, and recall all being close to 1.0. The CNN model was slightly less accurate.\u003C\/p\u003E\n\u003Cp\u003EWhile we certainly do not expect perfect results in a real-world scenario, these lab results were nonetheless encouraging. Recall that all of our obfuscated examples were generated by one source, namely the Invoke-DOSfuscation tool. While Invoke-DOSfuscation generates a wide variety of obfuscated samples, in the real world we expect to see at least some samples that are quite dissimilar from any that Invoke-DOSfuscation generates. We are currently collecting real world obfuscated command lines to get a more accurate picture of the generalizability of this model on obfuscated samples from actual malicious actors. We expect that command obfuscation, similar to PowerShell obfuscation before it, will continue to emerge in new malware families.\u003C\/p\u003E\n\u003Cp\u003EAs an additional test we asked Daniel Bohannon (author of Invoke-DOSfuscation, the Windows command line obfuscation tool) to come up with obfuscated samples that in his experience would be difficult for a traditional obfuscation detector. In every case, our ML detector was still able to detect obfuscation. Some examples are shown in Figure 8.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Some examples of obfuscated text used to test and attempt to defeat the ML obfuscation detector (all were correctly identified as obfuscated text)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe also created very cryptic looking texts that, although valid Windows command lines and non-obfuscated, appear slightly obfuscated to a human observer. This was done to test efficacy of the detector with boundary examples. The detector was correctly able to classify the text as non-obfuscated in this case as well. Figure 9 shows one such example.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture9.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: An example that appears on first glance to be obfuscated, but isn\u0027t really and would likely fool a non-ML solution (however, the ML obfuscation detector currently identifies it as non-obfuscated)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFinally, Figure 10 shows a complicated yet non-obfuscated command line that is correctly classified by our obfuscation detector, but would likely fool a non-ML detector based on statistical features (for example a rule-based detector with a hand-crafted weighing scheme and a threshold, using features such as the proportion of special characters, length of the command line or entropy of the command line).\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmdline\/Picture10.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: An example that would likely be misclassified by an ML detector that uses simplistic statistical features; however, our ML obfuscation detector currently identifies it as non-obfuscated\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ECNN vs. GBT Results\u003C\/h4\u003E\n\u003Cp\u003EWe compared the results of a heavily tuned GBT classifier built using carefully selected features to those of a CNN trained with raw data (featureless ML). While the CNN architecture was not heavily tuned, it is interesting to note that with samples such as those in Figure 10, the GBT classifier confidently predicted non-obfuscated with a score of 19.7 percent (the complement of the measure of the classifier\u2019s confidence in non-obfuscation). Meanwhile, the CNN classifier predicted non-obfuscated with a confidence probability of 50 percent \u2013 right at the boundary between obfuscated and non-obfuscated. The number of misclassifications of the CNN model was also more than that of the Gradient Boosted Tree model. Both of these are most likely the result of inadequate tuning of the CNN, and not a fundamental shortcoming of the featureless approach.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EIn this blog post we described an ML approach to detecting obfuscated Windows command lines, which can be used as a signal to help identify malicious command line usage. Using ML techniques, we demonstrated a highly accurate mechanism for detecting such command lines without resorting to the often inadequate and costly technique of maintaining complex if-then rules and regular expressions. The more comprehensive ML approach is flexible enough to catch new variations in obfuscation, and when gaps are detected, it can usually be handled by adding some well-chosen evader samples to the training set and retraining the model.\u003C\/p\u003E\n\u003Cp\u003EThis successful application of ML is yet another demonstration of the usefulness of ML in replacing complex manual or programmatic approaches to problems in computer security. In the years to come, we anticipate ML to take an increasingly important role both at FireEye and in the rest of the cyber security industry.\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue May 14 2019 17:55:39 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EThis blog post presents a machine learning approach to detecting obfuscated Windows command line invocations on endpoints.\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu Nov 29 2018 11:21:39 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Nov 29 2018 11:23:37 GMT-0500",
      "imageRotate": "0"
    }
  }
}
