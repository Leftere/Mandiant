{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Thu May 05 2016 18:15:26 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Deobfuscating Python Bytecode",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "f1d68ec9-389c-48ae-aa9b-5a318c00060b",
    "author": "Joshua Homan",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "4722778b-16cf-44b6-ad4d-f23afff20dc0"
    ],
    "jcr:created": "Fri Jun 14 2019 15:51:50 GMT-0400",
    "cq:lastReplicated": "Fri Jun 14 2019 15:51:49 GMT-0400",
    "cq:lastModified": "Fri Jun 14 2019 15:51:41 GMT-0400",
    "cq:distribute": true,
    "jcr:description": "Learn how to remove a simple obfuscation from a Python code object using the bytecode_graph module.",
    "jcr:baseVersion": "4722778b-16cf-44b6-ad4d-f23afff20dc0",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-tags:reverse-engineering",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-authors:cap-joshua-homan",
      "fireeye-blog-threat-research:threat-research\/malware-research",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "99fb3a77-118d-4850-8ab8-6880b37ff07a",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue May 03 2016 08:30:00 GMT-0400",
    "_charset_": "UTF-8",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
        "text": "\u003Ch5\u003E\u003Cb\u003EIntroduction\u003C\/b\u003E\u003C\/h5\u003E\n\u003Cp\u003EDuring an investigation, the FLARE team came across an interesting Python malware sample (MD5: \u003Cspan class=\u0022code\u0022\u003E61a9f80612d3f7566db5bdf37bbf22cf \u003C\/span\u003E) that is packaged using \u003Ca target=\u0022_blank\u0022 href=\u0022http:\/\/www.py2exe.org\u0022 adhocenable=\u0022false\u0022\u003Epy2exe\u003C\/a\u003E. Py2exe is a popular way to compile and package Python scripts into executables. When we encounter this type of malware we typically just decompile and read the Python source code. However, this malware was different, it had its bytecode manipulated to prevent it from being decompiled easily!\u003C\/p\u003E\n\u003Cp\u003EIn this blog we\u2019ll analyze the malware and show how we removed the obfuscation, which allowed us to produce a clean decompile. Here we release source code to our bytecode_graph module to help you analyze obfuscated Python bytecode (https:\/\/github.com\/fireeye\/flare-bytecode_graph). This module allows you to remove instructions from a bytecode stream, refactor offsets and generate a new code object that can be further analyzed.\u003C\/p\u003E\n\u003Ch5\u003E\u003Cb\u003EBackground\u003C\/b\u003E\u003C\/h5\u003E\n\u003Cp\u003EPy2exe is a utility that turns a Python script into an executable, which allows it to run on a system without a Python interpreter installed. Analyzing a Py2exe binary is generally a straightforward process that starts with extracting the Python bytecode followed by decompiling the code object with a module such as \u003Cspan class=\u0022code\u0022\u003E\u003Ca target=\u0022_blank\u0022 href=\u0022http:\/\/srossross.github.io\/Meta\/html\/api\/decompile.html\u0022 adhocenable=\u0022false\u0022\u003Emeta\u003C\/a\u003E \u003C\/span\u003Eor \u003Cspan class=\u0022code\u0022\u003E\u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/github.com\/wibiti\/uncompyle2\u0022 adhocenable=\u0022false\u0022\u003Euncompyle2\u003C\/a\u003E\u003C\/span\u003E. Appendix A contains an example script that demonstrates how to extract a code object from a Py2exe binary.\u003C\/p\u003E\n\u003Cp\u003EWhen attempting to decompile this sample using uncompyle2, the exception shown in Figure 1 is generated. The exception suggests the bytecode stream contains code sequences that the decompiler is not expecting.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Uncompyle2 exception trace\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003E\u003Cb\u003EObfuscation that breaks decompilers\u003C\/b\u003E\u003C\/h4\u003E\n\u003Cp\u003ETo understand why the decompiler is failing, we first need to take a closer look at the bytecode disassembly. A simple method to disassemble Python bytecode is to use the built-in module \u003Cspan class=\u0022code\u0022\u003E\u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/docs.python.org\/2\/library\/dis.html\u0022 adhocenable=\u0022false\u0022\u003Edis\u003C\/a\u003E\u003C\/span\u003E. When using the \u003Cspan class=\u0022code\u0022\u003Edis\u003C\/span\u003E module, it is important to use the same version of Python as the bytecode to get an accurate disassembly. Figure 2 contains an example interactive session that disassembles the script \u201cimport sys\u201d. Each line in the disassembly output contains an optional line number, followed by the bytecode offset and finally the bytecode instruction mnemonic and any arguments.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig2.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2:\u0026nbsp; Example bytecode disassembly\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EUsing the example script from Appendix A, we can view the disassembly of the code object to get a better idea what is causing the decompiler to fail. Figure 3 contains a portion of the disassembly produced by running script on this sample.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig3.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Bytecode disassembly\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ELooking closer at the disassembly, notice there are several unnecessary bytecode sequences that have no effect on the logic of the code. This suggests that a standard compiler did not produce the bytecode. The first surprising bytecode construct is the use of \u003Cspan class=\u0022code\u0022\u003ENOP\u003C\/span\u003Es, for example, found at bytecode offset 0. The \u003Cspan class=\u0022code\u0022\u003ENOP\u003C\/span\u003E instruction is not typically included in compiled Python code because the interpreter does not have to deal with pipelining issues. The second surprising bytecode construct is the series of \u003Cspan class=\u0022code\u0022\u003E\u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/docs.python.org\/2\/library\/dis.html#opcode-ROT_TWO\u0022 adhocenable=\u0022false\u0022\u003EROT_TWO\u003C\/a\u003E \u003C\/span\u003Eand \u003Cspan class=\u0022code\u0022\u003E\u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/docs.python.org\/2\/library\/dis.html#opcode-ROT_THREE\u0022 adhocenable=\u0022false\u0022\u003EROT_THREE\u003C\/a\u003E \u003C\/span\u003Einstructions. The \u003Cspan class=\u0022code\u0022\u003EROT_TWO \u003C\/span\u003Einstruction rotates the top two stack items and the \u003Cspan class=\u0022code\u0022\u003EROT_THREE\u003C\/span\u003E rotates the top three stack items. By calling two successive \u003Cspan class=\u0022code\u0022\u003EROT_TWO\u003C\/span\u003E or three \u003Cspan class=\u0022code\u0022\u003EROT_THREE\u003C\/span\u003E instructions, the stack is returned to the same state as before the instruction sequence. So, these sequences have no effect on the logic of the code, but may confuse decompilers. Lastly, the \u003Cspan class=\u0022code\u0022\u003ELOAD_CONST\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003EPOP_TOP\u003C\/span\u003E combinations are unnecessary. The \u003Cspan class=\u0022code\u0022\u003ELOAD_CONST\u003C\/span\u003E instruction pushes a constant onto the stack while the \u003Cspan class=\u0022code\u0022\u003EPOP_TOP\u003C\/span\u003E removes it. This again leaves the stack in its original state.\u003C\/p\u003E\n\u003Cp\u003EThese unnecessary code sequences prevent decompiling bytecode using modules such as \u003Cspan class=\u0022code\u0022\u003Emeta\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Euncompyle2\u003C\/span\u003E. Many of the \u003Cspan class=\u0022code\u0022\u003EROT_TWO\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003EROT_THREE\u003C\/span\u003E sequences operate on an empty stack that generates errors when inspected because both modules use a Python List object to simulate the runtime stack. A \u003Cspan class=\u0022code\u0022\u003Epop\u003C\/span\u003E operation on the empty list generates exceptions that halt the decompilation process. In contrast, when Python interpreter executes the bytecode, no checks are made on the stack before performing operations on it. Take for example \u003Cspan class=\u0022code\u0022\u003EROT_TWO\u003C\/span\u003E from \u003Cspan class=\u0022code\u0022\u003E\u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/github.com\/python\/cpython\/blob\/master\/Python\/ceval.c#L1400\u0022 adhocenable=\u0022false\u0022\u003Eceval.c\u003C\/a\u003E \u003C\/span\u003Ein Figure 4.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig4.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: ROT_TWO source\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ELooking at the macro definitions for \u003Cspan class=\u0022code\u0022\u003ETOP, SECOND, SET_TOP\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003ESET_SECOND\u003C\/span\u003E from \u003Cspan class=\u0022code\u0022\u003E\u003Ca target=\u0022_blank\u0022 href=\u0022https:\/\/github.com\/python\/cpython\/blob\/master\/Python\/ceval.c#L1048\u0022 adhocenable=\u0022false\u0022\u003Eceval.c\u003C\/a\u003E\u003C\/span\u003E in Figure 5, the lack of sanity checks allow these code sequences to execute without stopping.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig5.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Macro definitions\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003ENOP\u003C\/span\u003Es and \u003Cspan class=\u0022code\u0022\u003ELOAD_CONST\/POP_TOP\u003C\/span\u003E sequences stop the decompilation process in situations where the next or previous instructions are expected to be a specific value. An example debug trace for \u003Cspan class=\u0022code\u0022\u003Euncompyle2\u003C\/span\u003E is shown in Figure 6 where the previous instruction is expected to be a jump or a return.\u003C\/p\u003E\n\u003Ch5\u003E\u003Cb\u003ERemoving the obfuscation\u003C\/b\u003E\u003C\/h5\u003E\n\u003Cp\u003ENow that the types of obfuscation have been identified, the next step is to clean the bytecode in hopes of getting a successful decompile. The \u003Cspan class=\u0022code\u0022\u003Eopmap\u003C\/span\u003E dictionary from the \u003Cspan class=\u0022code\u0022\u003Edis\u003C\/span\u003E module is very helpful when manipulating bytecode streams. When using \u003Cspan class=\u0022code\u0022\u003Eopmap\u003C\/span\u003E, instructions can be referenced by name rather than a specific bytecode value. For example, the \u003Cspan class=\u0022code\u0022\u003ENOP\u003C\/span\u003E bytecode binary value is available with \u003Cspan class=\u0022code\u0022\u003Edis.opmap[\u2018NOP\u2019]\u003C\/span\u003E.\u003C\/p\u003E\n\u003Cp\u003EAppendix B contains an example script that replaces the \u003Cspan class=\u0022code\u0022\u003EROT_TWO, ROT_THREE\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003ELOAD_CONST\/POP_TOP\u003C\/span\u003E sequences with \u003Cspan class=\u0022code\u0022\u003ENOP\u003C\/span\u003E instructions and creates a new code object. The disassembly produced from running the script in Appendix A on the malware is shown in Figure 6.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig6.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Clean disassembly\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAt this point, the disassembly is somewhat easier to read with the unnecessary instruction sequences replaced with NOPs, but the bytecode still fails to decompile. The failure is due how \u003Cspan class=\u0022code\u0022\u003Euncompyle2\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Emeta\u003C\/span\u003E deal with exceptions. The problem is demonstrated in Figure 7 with a simple script that includes an exception handler.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig7.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Exception handler\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn Figure 7, the exception handler is created using the \u003Cspan class=\u0022code\u0022\u003ESETUP_EXCEPT \u003C\/span\u003Einstruction at offset 0 with the handler code beginning at offset \u003Cspan class=\u0022code\u0022\u003E13\u003C\/span\u003E with the three \u003Cspan class=\u0022code\u0022\u003EPOP_TOP\u003C\/span\u003E instructions. Both the \u003Cspan class=\u0022code\u0022\u003Emeta\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Euncompyle2\u003C\/span\u003E modules inspect the instruction prior to the exception handler to verify it is a jump instruction. If the instruction isn\u2019t a jump, the decompile process is halted. In the case of this malware, the instruction is a \u003Cspan class=\u0022code\u0022\u003ENOP\u003C\/span\u003E because of the obfuscation instructions were removed.\u003C\/p\u003E\n\u003Cp\u003EAt this point, to get a successful decompile, we have two options. First, we can reorder instructions to make sure they are where the decompiler expects them. Alternatively, we can remove all the NOP instructions. Both strategies can be complicated and tedious because absolute and relative addresses for any jump instructions need to also be updated. This is where the \u003Cspan class=\u0022code\u0022\u003Ebytecode_graph\u003C\/span\u003E module comes in.\u0026nbsp; Using the \u003Cspan class=\u0022code\u0022\u003Ebytecode_graph\u003C\/span\u003E module, it\u2019s easy to replace and remove instructions from a bytecode stream and generate a new stream with offsets automatically updated accordingly. Figure 8 shows an example function that uses the \u003Cspan class=\u0022code\u0022\u003Ebytecode_graph \u003C\/span\u003Emodule to remove all NOP instructions from a code object.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Fig8.png\u0022\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Example bytecode_graph removing NOP instructions\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003E\u003Cb\u003ESummary\u003C\/b\u003E\u003Cbr\u003E\n\u003C\/h4\u003E\n\u003Cp\u003EIn this blog I\u2019ve demonstrated how to remove a simple obfuscation from a Python code object using the \u003Cspan class=\u0022code\u0022\u003Ebytecode_graph\u003C\/span\u003E module. I think you\u2019ll find it easy to use and a perfect tool for dealing with tricky py2exe samples. You can download \u003Cspan class=\u0022code\u0022\u003Ebytecode_graph\u003C\/span\u003E via pip (\u003Cspan class=\u0022code\u0022\u003Epip install bytecode-graph\u003C\/span\u003E) or from the FLARE team\u2019s Github page: https:\/\/github.com\/fireeye\/flare-bytecode_graph.\u003C\/p\u003E\n\u003Cp\u003EAn example script that removes the obfuscation discussed in this blog can be found here: https:\/\/github.com\/fireeye\/flare-bytecode_graph\/blob\/master\/examples\/bytecode_deobf_blog.py.Hashes identified that implement this bytecode obfuscation:\u003C\/p\u003E\n\u003Cp\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u003Cspan class=\u0022code\u0022\u003E61a9f80612d3f7566db5bdf37bbf22cf\u003Cbr\u003E\n \u003C\/span\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u003Cspan class=\u0022code\u0022\u003Eff720db99531767907c943b62d39c06d\u003Cbr\u003E\n \u003C\/span\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u003Cspan class=\u0022code\u0022\u003Eaad6c679b7046e568d6591ab2bc76360\u003Cbr\u003E\n \u003C\/span\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp; \u003Cspan class=\u0022code\u0022\u003Eba7d3868cb7350fddb903c7f5f07af85\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EAppendix A: Python script to extract and disassemble Py2exe resource\u003C\/h4\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Appendix%20A.png\u0022\u003E\u003C\/p\u003E\n\u003Ch4\u003EAppendix B: Sample script to remove obfuscation\u003C\/h4\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/Flare%20Homan\/Appendix%20B.png\u0022\u003E\u003C\/p\u003E\n",
        "jcr:lastModified": "Thu May 05 2016 18:14:59 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "alt": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "comments": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/commons\/components\/comments"
      },
      "trackback": {
        "jcr:primaryType": "nt:unstructured",
        "sling:resourceType": "social\/blog\/components\/trackback"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "lynda.hall@fireeye.com",
      "text": "\u003Cp\u003ELearn how to remove a simple obfuscation from a Python code object using the bytecode_graph module.\u003C\/p\u003E\n",
      "jcr:lastModified": "Thu May 05 2016 18:14:42 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Fri Jun 14 2019 15:51:41 GMT-0400",
      "imageRotate": "0"
    }
  }
}
