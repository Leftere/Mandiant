{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Mon Apr 23 2018 11:13:40 GMT-0400",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Loading Kernel Shellcode",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "77072aa9-0bea-4cee-b75b-7b04019edaef",
    "author": "Michael Bailey",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "79a5b686-61a3-4856-9588-6c36007e4a62"
    ],
    "jcr:created": "Wed May 08 2019 18:28:01 GMT-0400",
    "cq:lastReplicated": "Wed May 08 2019 18:28:00 GMT-0400",
    "cq:lastModified": "Wed May 08 2019 18:27:51 GMT-0400",
    "jcr:baseVersion": "79a5b686-61a3-4856-9588-6c36007e4a62",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:michael-bailey",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:kernel",
      "fireeye-blog-tags:shellcode",
      "fireeye-blog-tags:tools",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "3c3526e2-5bf7-4ff4-bfc1-3c7c9c29dd67",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Mon Apr 23 2018 11:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EIn the wake of recent hacking tool dumps, the FLARE team saw a spike in malware samples detonating kernel shellcode. Although most samples can be analyzed statically, the FLARE team sometimes debugs these samples to confirm specific functionality. Debugging can be an efficient way to get around packing or obfuscation and quickly identify the structures, system routines, and processes that a kernel shellcode sample is accessing.\u003C\/p\u003E\n\u003Cp\u003EThis post begins a series centered on kernel software analysis, and introduces a tool that uses a custom Windows kernel driver to load and execute Windows kernel shellcode. I\u2019ll walk through a brief case study of some kernel shellcode, how to load shellcode with \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-kscldr\u0022\u003EFLARE\u2019s kernel shellcode loader\u003C\/a\u003E, how to build your own copy, and how it works.\u003C\/p\u003E\n\u003Cp\u003EAs always, only analyze malware in a safe environment such as a VM; never use tools such as a kernel shellcode loader on any system that you rely on to get your work done.\u003C\/p\u003E\n\u003Ch4\u003EA Tale of Square Pegs and Round Holes\u003C\/h4\u003E\n\u003Cp\u003EDepending upon how a shellcode sample is encountered, the analyst may not know whether it is meant to target user space or kernel space. A common triage step is to load the sample in a shellcode loader and debug it in user space. With kernel shellcode, this can have unexpected results such as the access violation in Figure 1.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/KernelShellcode\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Access violation from shellcode dereferencing null pointer\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe kernel environment is a world apart from user mode: various registers take on different meanings and point to totally different structures. For instance, while the gs segment register in 64-bit Windows user mode points to the Thread Information Block (TIB) whose size is only 0x38 bytes, in kernel mode it points to the Processor Control Region (KPCR) which is much larger. In Figure 1 at address 0x2e07d9, the shellcode is attempting to access the IdtBase member of the KPCR, but because it is running in user mode, the value at offset 0x38 from the gs segment is null. This causes the next instruction to attempt to access invalid memory in the NULL page. What the code is trying to do doesn\u2019t make sense in the user mode environment, and it has crashed as a result.\u003C\/p\u003E\n\u003Cp\u003EIn contrast, kernel mode is a perfect fit. Figure 2 shows WinDbg\u2019s dt command being used to display the _KPCR type defined within ntoskrnl.pdb, highlighting the field at offset 0x38 named IdtBase.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/KernelShellcode\/Fig2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: KPCR structure\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EGiven the rest of the code in this sample, accessing the IdtBase field of the KPCR made perfect sense. Determining that this was kernel shellcode allowed me to quickly resolve the rest of my questions, but to confirm my findings, I wrote a kernel shellcode loader. Here\u2019s what it looks like to use this tool to load a small, do-nothing piece of shellcode.\u003C\/p\u003E\n\u003Ch4\u003EUsing FLARE\u2019s Kernel Shellcode Loader\u003C\/h4\u003E\n\u003Cp\u003EI booted a target system with a kernel debugger and opened an administrative command prompt in the directory where I copied the shellcode loader (kscldr.exe). The shellcode loader expects to receive the name of the file on disk where the shellcode is located as its only argument. Figure 3 shows an example where I\u2019ve used a hex editor to write the opcodes for the NOP (0x90) and RET (0xC3) instructions into a binary file and invoked kscldr.exe to pass that code to the kernel shellcode loader driver. I created my file using the Windows port of xxd that comes with \u003Ca href=\u0022http:\/\/www.vim.org\/download.php#pc\u0022\u003EVim for Windows\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/KernelShellcode\/Fig3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Using kscldr.exe to load kernel shellcode\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe shellcode loader prompts with a security warning. After clicking yes, kscldr.exe installs its driver and uses it to execute the shellcode. The system is frozen at this point because the kernel driver has already issued its breakpoint and the kernel debugger is awaiting commands. Figure 4 shows WinDbg hitting the breakpoint and displaying the corresponding source code for kscldr.sys.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/KernelShellcode\/Fig4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Breaking in kscldr.sys\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFrom the breakpoint, I use WinDbg with source-level debugging to step and trace into the shellcode buffer. Figure 5 shows WinDbg\u2019s disassembly of the buffer after doing this.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/KernelShellcode\/Fig5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Tracing into and disassembling the shellcode\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe disassembly shows the 0x90 and 0xc3 opcodes from before, demonstrating that the shellcode buffer is indeed being executed. From here, the powerful facilities of WinDbg are available to debug and analyze the code\u2019s behavior.\u003C\/p\u003E\n\u003Ch4\u003EBuilding It Yourself\u003C\/h4\u003E\n\u003Cp\u003ETo try out FLARE\u2019s kernel shellcode loader for yourself, you\u2019ll need to \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-kscldr\u0022\u003Edownload the source code\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003ETo get started building it, download and install the \u003Ca href=\u0022https:\/\/developer.microsoft.com\/en-us\/windows\/hardware\/windows-driver-kit\u0022\u003EWindows Driver Kit (WDK)\u003C\/a\u003E. I\u2019m using \u003Ca href=\u0022https:\/\/www.microsoft.com\/en-us\/download\/confirmation.aspx?id=11800\u0022\u003EWindows Driver Kit Version 7.1.0\u003C\/a\u003E, which is command line driven, whereas more modern versions of the WDK integrate with Visual Studio. If you feel comfortable using a newer kit, you\u2019re welcomed to do so, but beware, you\u2019ll have to take matters into your own hands regarding build commands and dependencies. Since WDK 7.1.0 is adequate for purposes of this tool, that is the version I will describe in this post.\u003C\/p\u003E\n\u003Cp\u003EOnce you have downloaded and installed the WDK, browse to the Windows Driver Kits directory in the start menu on your development system and select the appropriate environment. Figure 6 shows the WDK program group on a Windows 7 system. The term \u201cchecked build\u201d indicates that debugging checks will be included. I plan to load 64-bit kernel shellcode, and I like having Windows catch my mistakes early, so I\u2019m using the x64 Checked Build Environment.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/KernelShellcode\/Fig6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Windows Driver Kits program group\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn the WDK command prompt, change to the directory where you downloaded the FLARE kernel shellcode loader and type ez.cmd. The script will cause prompts to appear asking you to supply and use a password for a test signing certificate. Once the build completes, visit the bin directory and copy kscldr.exe to your debug target. Before you can commence using your custom copy of this tool, you\u2019ll need to follow just a few more steps to prepare the target system to allow it.\u003C\/p\u003E\n\u003Ch4\u003EPreparing the Debug Target\u003C\/h4\u003E\n\u003Cp\u003ETo debug kernel shellcode, I wrote a Windows software-only driver that loads and runs shellcode at privilege level 0. Normally, Windows only loads drivers that are signed with a special \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows-hardware\/drivers\/install\/cross-certificates-for-kernel-mode-code-signing\u0022\u003Ecross-certificate\u003C\/a\u003E, but Windows allows you to \u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows-hardware\/drivers\/install\/the-testsigning-boot-configuration-option\u0022\u003Eenable testsigning\u003C\/a\u003E to load drivers signed with a test certificate. We can create this test certificate for free, and it won\u2019t allow the driver to be loaded on production systems, which is ideal.\u003C\/p\u003E\n\u003Cp\u003EIn addition to enabling testsigning mode, it is necessary to enable kernel debugging to be able to really follow what is happening after the kernel shellcode gains execution. Starting with Windows Vista, we can enable both testsigning and kernel debugging by issuing the following two commands in an administrative command prompt followed by a reboot:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022671\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Ebcdedit.exe \/set testsigning on\u003C\/p\u003E\n\u003Cp\u003Ebcdedit.exe \/set debug on\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EFor debugging in a VM, I install \u003Ca href=\u0022http:\/\/virtualkd.sysprogs.org\/\u0022\u003EVirtualKD\u003C\/a\u003E, but you can also follow your virtualization vendor\u2019s directions for connecting a serial port to a named pipe or other mechanism that WinDbg understands. Once that is set up and tested, we\u2019re ready to go!\u003C\/p\u003E\n\u003Cp\u003EIf you try the shellcode loader and get a blue screen indicating stop code 0x3B (SYSTEM_SERVICE_EXCEPTION), then you likely did not successfully connect the kernel debugger beforehand. Remember that the driver issues a software interrupt to give control to the debugger immediately before executing the shellcode; if the debugger is not successfully attached, Windows will blue screen. If this was the case, reboot and try again, this time first confirming that the debugger is in control by clicking \u003Cu\u003ED\u003C\/u\u003Eebug -\u0026gt; \u003Cu\u003EB\u003C\/u\u003Ereak in WinDbg. Once you know you have control, you can issue the g command to let execution continue (you may need to disable driver load notifications to get it to finish the boot process without further intervention: sxd ld).\u003C\/p\u003E\n\u003Ch4\u003EHow It Works\u003C\/h4\u003E\n\u003Cp\u003EThe user-space application (kscldr.exe) copies the driver from a PE-COFF resource to the disk and registers it as a Windows kernel service. The driver implements device write and I\/O control routines to allow interaction from the user application. Its driver entry point first registers dispatch routines to handle CreateFile, WriteFile, DeviceIoControl, and CloseHandle. It then creates a device named \\Device\\kscldr and a symbolic link making the device name accessible from user-space. When the user application opens the device file and invokes WriteFile, the driver calls ExAllocatePoolWithTag specifying a PoolType of NonPagedPool (\u003Ca href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows-hardware\/drivers\/ddi\/content\/wdm\/ne-wdm-_pool_type\u0022\u003Ewhich is executable\u003C\/a\u003E), and writes the buffer to the newly allocated memory. After the write operation, the user application can call DeviceIoControl to call into the shellcode. In response, the driver sets the appropriate flags on the device object, issues a breakpoint to pass control to the kernel debugger, and finally calls the shellcode as if it were a function.\u003C\/p\u003E\n\u003Ch4\u003EWhile You\u2019re Here\u003C\/h4\u003E\n\u003Cp\u003EDriver development opens the door to unique instrumentation opportunities. For example, Figure 7 shows a few kernel callback routines described in the WDK help files that can track system-wide process, thread, and DLL activity.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/KernelShellcode\/Fig7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: WDK kernel-mode driver architecture reference\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EKernel development is a deep subject that entails a great deal of study, but the WDK also comes with dozens upon dozens of sample drivers that illustrate correct Windows kernel programming techniques. This is a treasure trove of Windows internals information, security research topics, and instrumentation possibilities. If you have time, take a look around before you get back to work.\u003C\/p\u003E\n\u003Ch4\u003EWrap-Up\u003C\/h4\u003E\n\u003Cp\u003EWe\u2019ve shared FLARE\u2019s tool for loading privileged shellcode in test environments so that we can dynamically analyze kernel shellcode. We hope this provides a straightforward way to quickly triage kernel shellcode if it ever appears in your environment. Download the\u0026nbsp;\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-kscldr\u0022\u003Esource code\u003C\/a\u003E\u0026nbsp;now.\u003C\/p\u003E\n\u003Cp\u003EDo you want to learn more about these tools and techniques from FLARE? Then you should take one of our Black Hat classes in Las Vegas this summer! Our offerings include \u003Ca href=\u0022https:\/\/www.blackhat.com\/us-18\/training\/schedule\/index.html#malware-analysis-crash-course-96601515451125\u0022\u003EMalware Analysis Crash Course\u003C\/a\u003E, \u003Ca href=\u0022https:\/\/www.blackhat.com\/us-18\/training\/schedule\/index.html#macos-malware-analysis-for-reverse-engineers-96811515782706\u0022\u003EmacOS Malware for Reverse Engineers\u003C\/a\u003E, and \u003Ca href=\u0022https:\/\/www.blackhat.com\/us-18\/training\/schedule\/index.html#malware-analysis-master-class-9682\u0022\u003EMalware Analysis Master Class\u003C\/a\u003E.\u003C\/p\u003E\n",
        "jcr:lastModified": "Mon Apr 23 2018 11:12:59 GMT-0400",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EThis post begins a series centered on kernel software analysis.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Apr 23 2018 01:32:37 GMT-0400",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed May 08 2019 18:27:51 GMT-0400",
      "imageRotate": "0"
    }
  }
}
