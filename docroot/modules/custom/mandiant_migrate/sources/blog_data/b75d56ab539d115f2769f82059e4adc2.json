{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Thu Apr 02 2020 15:05:06 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "FakeNet Genie: Improving Dynamic Malware Analysis with Cheat Codes for FakeNet-NG",
    "jcr:versionHistory": "33a1f5c3-cbb4-40ca-b0a0-7fd82da4e11c",
    "author": "Matthew Haigh",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "e2229eb2-8aae-4cab-9ae0-c0691489d9f0"
    ],
    "jcr:created": "Thu Apr 02 2020 15:05:06 GMT+0000",
    "cq:lastModified": "Thu Apr 02 2020 15:04:58 GMT+0000",
    "jcr:baseVersion": "e2229eb2-8aae-4cab-9ae0-c0691489d9f0",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:matthew-haigh",
      "fireeye-blog-authors:nhan-huynh",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:malware",
      "fireeye-blog-tags:open-source-tools",
      "fireeye-blog-tags:detection",
      "fireeye-blog-tags:malware-analysis"
    ],
    "jcr:uuid": "f260f376-f37a-48f4-98f5-506cf9ee3ca4",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Thu Apr 02 2020 11:00:00 GMT-0400",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EAs developers of the network simulation tool FakeNet-NG, reverse engineers on the FireEye FLARE team, and malware analysis instructors, we get to see how different analysts use FakeNet-NG and the challenges they face. We have learned that FakeNet-NG provides many useful features and solutions of which our users are often unaware. In this blog post, we will showcase some cheat codes to level up your network analysis with FakeNet-NG. We will introduce custom responses and demonstrate powerful features such as executing commands on connection events and decrypting SSL traffic.\u003C\/p\u003E\n\u003Cp\u003ESince its first \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2016\/08\/fakenet-ng_next_gen.html\u0022\u003Erelease in 2016\u003C\/a\u003E, we have improved \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-fakenet-ng\/releases\u0022\u003EFakeNet-NG\u003C\/a\u003E by adding new features such as \u003Ca href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2017\/07\/linux-support-for-fakenet-ng.html\u0022 adhocenable=\u0022false\u0022\u003ELinux support\u003C\/a\u003E and \u003Ca href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2017\/10\/fakenet-content-based-protocol-detection.html\u0022 adhocenable=\u0022false\u0022\u003Econtent-based protocol detection\u003C\/a\u003E. We recently updated FakeNet-NG with one of our most requested features: custom responses for HTTP and binary protocols.\u003C\/p\u003E\n\u003Cp\u003EThis blog post offers seven \u0026quot;stages\u0026quot; to help you master different FakeNet-NG strategies. We present them in terms of common scenarios we encounter when analyzing malware. Feel free to skip to the section relevant to your current analysis and\/or adapt them to your individual needs. The stages are presented as follows:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003ECustom File Responses\u003C\/li\u003E\n\u003Cli\u003ECustom Binary Protocols\u003C\/li\u003E\n\u003Cli\u003ECustom HTTP Responses\u003C\/li\u003E\n\u003Cli\u003EManual Custom Responses\u003C\/li\u003E\n\u003Cli\u003EBlacklisting Processes\u003C\/li\u003E\n\u003Cli\u003EExecuting Commands on Connection Events\u003C\/li\u003E\n\u003Cli\u003EDecrypting SSL Traffic\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003ERead on to upgrade your skill tree and become a FakeNet-NG pro!\u003C\/p\u003E\n\u003Ch4\u003EBefore You Start: Configuring FakeNet-NG\u003C\/h4\u003E\n\u003Cp\u003EHere is a quick reference for FakeNet-NG configurations and log data locations.\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EConfiguration files are in \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\u003C\/span\u003E. You can modify \u003Cspan class=\u0022code\u0022\u003Edefault.ini\u003C\/span\u003E or copy it to a new file and point FakeNet-NG to the alternate configuration with \u003Cspan class=\u0022code\u0022\u003E-c\u003C\/span\u003E. Ex: \u003Cspan class=\u0022code\u0022\u003Efakenet.py -c custom.ini.\u003C\/span\u003E\u003C\/li\u003E\n\u003Cli\u003EDefault files are at \u003Cspan class=\u0022code\u0022\u003Efakenet\\defaultFiles\u003C\/span\u003E and Listener implementations are at \u003Cspan class=\u0022code\u0022\u003Efakenet\\listeners\u003C\/span\u003E.\u003C\/li\u003E\n\u003Cli\u003EThe \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\default.ini\u003C\/span\u003E default configuration includes global configuration settings and individual Listener configurations.\u003C\/li\u003E\n\u003Cli\u003ECustom response configuration samples are included in the directory \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\u003C\/span\u003E in the files \u003Cspan class=\u0022code\u0022\u003ECustomProviderExample.py\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003Esample_custom_response.ini\u003C\/span\u003E, and \u003Cspan class=\u0022code\u0022\u003Esample_raw_response.txt\u003C\/span\u003E.\u003C\/li\u003E\n\u003Cli\u003EThe install location for FakeNet-NG in FLARE VM is \u003Cspan class=\u0022code\u0022\u003EC:\\Python27\\lib\\site-packages\\fakenet\u003C\/span\u003E. You will find the subdirectories containing the \u003Cspan class=\u0022code\u0022\u003EdefaultFiles\u003C\/span\u003E, \u003Cspan class=\u0022code\u0022\u003Econfigs\u003C\/span\u003E, and \u003Cspan class=\u0022code\u0022\u003Elisteners\u003C\/span\u003E in this directory.\u003C\/li\u003E\n\u003Cli\u003EIn FLARE VM, FakeNet-NG packet capture files and HTTP requests can be found on the Desktop in the \u003Cspan class=\u0022code\u0022\u003Efakenet_logs\u003C\/span\u003E directory\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch4\u003EStage 1: Custom File Responses\u003C\/h4\u003E\n\u003Cp\u003EAs you may have noticed, FakeNet-NG is not limited to serving HTML pages. Depending on the file type requested, FakeNet-NG can serve PE files, ELF files, JPG, GIF, etc. FakeNet-NG is configured with several default files for common types and can also be configured to serve up custom files. The \u003Cspan class=\u0022code\u0022\u003EdefaultFiles\u003C\/span\u003E directory contains several types of files for standard responses. For example, if malware sends an FTP GET request for \u003Cspan class=\u0022code\u0022\u003Eevil.exe\u003C\/span\u003E, FakeNet-NG will respond with the file \u003Cspan class=\u0022code\u0022\u003EdefaultFiles\\FakeNetMini.exe\u003C\/span\u003E (the default response for .exe requests). This file is a valid Portable Executable file that displays a message box. By providing an actual PE file, we can observe the malware as it attempts to download and execute a malicious payload. An example FTP session and subsequent execution of the downloaded default file is shown in Figure 1.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture1.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Using FTP to download FakeNet-NG\u0027s default executable response\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EMost requests are adequately handled by this system. However, malware sometimes expects a file with a specific format, such as an image with an embedded PowerShell script, or an executable with a hash appended to the file for an integrity check . In cases like these, you can replace one of the default files with a file that meets the malware\u2019s expectation. There is also an option in each of the relevant Listeners (modules that implement network protocols) configurations to modify the \u003Cspan class=\u0022code\u0022\u003EdefaultFiles\u003C\/span\u003E path. This allows FakeNet-NG to serve different files without overwriting or modifying default data. A customized \u003Cspan class=\u0022code\u0022\u003EFakeNet.html\u003C\/span\u003E\u003Ci\u003E \u003C\/i\u003Efile is shown in Figure 2.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Modify the default FakeNet.html file to customize the response\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EStage 2: Custom Binary Protocols\u003C\/h4\u003E\n\u003Cp\u003EMany malware samples implement custom binary protocols which require specific byte sequences. For example, malware in the GH0ST family may require each message to begin with a signature such as \u0026quot;GH0ST\u0026quot;. The default FakeNet-NG \u003Cspan class=\u0022code\u0022\u003ERawListener\u003C\/span\u003E responds to unknown requests with an echo, i.e. it sends the same data that it has received. This behavior is typically sufficient. However, in cases where a custom response is required, you can still send the data the malware expects.\u003C\/p\u003E\n\u003Cp\u003ECustom TCP and UDP responses are now possible with FakeNet-NG. Consider a hypothetical malware sample that beacons the string \u201cHello\u201d to its command and control (C2) server and waits for a response packet that begins with \u201cFLARE\u201d followed by a numeric command (0-9). We will now demonstrate several interesting ways FakeNet-NG can handle this scenario.\u003C\/p\u003E\n\u003Ch5\u003EStatic Custom Response\u003C\/h5\u003E\n\u003Cp\u003EYou can configure how the TCP and\/or UDP Raw Listeners respond to traffic. In this example we tell FakeNet-NG how to respond to any TCP raw request (no protocol detected). First uncomment the \u003Cspan class=\u0022code\u0022\u003ECustom\u003C\/span\u003E configuration option in the \u003Cspan class=\u0022code\u0022\u003ERawTCPListener\u003C\/span\u003E section of \u003Cspan class=\u0022code\u0022\u003Efakenet\/configs\/default.ini\u003C\/span\u003E as illustrated in Figure 3.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E[RawTCPListener]\u003Cbr\u003E\n Enabled:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; True\u003Cbr\u003E\n Port:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1337\u003Cbr\u003E\n Protocol:\u0026nbsp;\u0026nbsp;\u0026nbsp; TCP\u003Cbr\u003E\n Listener:\u0026nbsp;\u0026nbsp;\u0026nbsp; RawListener\u003Cbr\u003E\n UseSSL:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; No\u003Cbr\u003E\n Timeout:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 10\u003Cbr\u003E\n Hidden:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; False\u003Cbr\u003E\n # To read about customizing responses, see docs\/CustomResponse.md\u003Cbr\u003E\n \u003Cb\u003ECustom:\u0026nbsp;\u0026nbsp;\u0026nbsp; sample_custom_response.ini\u003C\/b\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Activate custom TCP response\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENext configure the \u003Cspan class=\u0022code\u0022\u003ETcpRawFile\u003C\/span\u003E custom response in \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\sample_custom_response.ini\u003C\/span\u003E as demonstrated in Figure 4. Make sure to comment-out or replace the default \u003Cspan class=\u0022code\u0022\u003ERawTCPListener\u003C\/span\u003E instance.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E[ExampleTCP]\u003Cbr\u003E\n InstanceName:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; RawTCPListener\u003Cbr\u003E\n ListenerType:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TCP\u003Cbr\u003E\n TcpRawFile:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;flare_command.txt\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: TCP static custom response specifications\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ECreate the file \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\flare_command.txt\u003C\/span\u003E with the content \u003Cspan class=\u0022code\u0022\u003EFLARE0\u003C\/span\u003E. TCP responses will now be generated from the contents of the file.\u003C\/p\u003E\n\u003Ch5\u003EDynamic Custom Response\u003C\/h5\u003E\n\u003Cp\u003EPerhaps you want to issue commands dynamically rather than committing to a specific command in \u003Cspan class=\u0022code\u0022\u003Eflare_command.txt\u003C\/span\u003E. This can be achieved programmatically. Configure the \u003Cspan class=\u0022code\u0022\u003ETcpDynamic\u003C\/span\u003E custom response in \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\sample_custom_response.ini\u003C\/span\u003E as demonstrated in Figure 5. Make sure to comment-out or replace the existing \u003Cspan class=\u0022code\u0022\u003ERawTCPListener\u003C\/span\u003E instance.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E[ExampleTCP]\u003Cbr\u003E\n InstanceName:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; RawTCPListener\u003Cbr\u003E\n TcpDynamic:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; flare_command.py\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: TCP dynamic custom response specifications\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe file \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\CustomProviderExample.py\u003C\/span\u003E can be used as a template for our dynamic response file \u003Cspan class=\u0022code\u0022\u003Eflare_command.py\u003C\/span\u003E. We modify the \u003Cspan class=\u0022code\u0022\u003EHandleTcp()\u003C\/span\u003E function and produce the new file \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\flare_command.py\u003C\/span\u003E as illustrated in Figure 6. Now you can choose each command as the malware executes. Figure 7 demonstrates issuing commands dynamically using this configuration.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eimport socket\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Edef HandleTcp(sock):\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; while True:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; try:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; data = None\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; data = sock.recv(1024)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; except socket.timeout:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; pass\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; if not data:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; break\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; resp = raw_input(\u0027\\nEnter a numeric command: \u0027)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; command = bytes(\u0027FLARE\u0027 + resp + \u0027\\n\u0027)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; sock.sendall(command)\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: TCP dynamic response script\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture7.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Issue TCP dynamic commands\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EStage 3: Custom HTTP Responses\u003C\/h4\u003E\n\u003Cp\u003EMalware frequently implements its own encryption scheme on top of the popular HTTP protocol. For example, your sample may send an HTTP GET request to \u003Cspan class=\u0022code\u0022\u003E\/comm.php?nonce=\u0026lt;random\u0026gt;\u003C\/span\u003E and expect the C2 server response to be RC4 encrypted with the nonce value. This process is illustrated in Figure 8. How can we easily force the malware to execute its critical code path to observe or debug its behaviors?\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture8.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Malware example that expects a specific key based on beacon data\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFor cases like these we recently introduced support for HTTP custom responses. Like TCP custom responses, the \u003Cspan class=\u0022code\u0022\u003EHTTPListener\u003C\/span\u003E also has a new setting named \u003Cspan class=\u0022code\u0022\u003ECustom\u003C\/span\u003E that enables dynamic HTTP responses. This setting also allows FakeNet-NG to select the appropriate responses matching specific hosts or URIs. With this feature, we can now quickly write a small Python script to handle the HTTP traffic dynamically based upon our malware sample.\u003C\/p\u003E\n\u003Cp\u003EStart by uncommenting the Custom configuration option in the \u003Cspan class=\u0022code\u0022\u003EHTTPListener80\u003C\/span\u003E section as illustrated in Figure 9.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E[HTTPListener80]\u003Cbr\u003E\n Enabled:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; True\u003Cbr\u003E\n Port:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 80\u003Cbr\u003E\n Protocol:\u0026nbsp;\u0026nbsp;\u0026nbsp; TCP\u003Cbr\u003E\n Listener:\u0026nbsp;\u0026nbsp;\u0026nbsp; HTTPListener\u003Cbr\u003E\n UseSSL:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; No\u003Cbr\u003E\n Webroot:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; defaultFiles\/\u003Cbr\u003E\n Timeout:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 10\u003Cbr\u003E\n #ProcessBlackList: dmclient.exe, OneDrive.exe, svchost.exe, backgroundTaskHost.exe, GoogleUpdate.exe, chrome.exe\u003Cbr\u003E\n DumpHTTPPosts: Yes\u003Cbr\u003E\n DumpHTTPPostsFilePrefix: http\u003Cbr\u003E\n Hidden:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; False\u003Cbr\u003E\n # To read about customizing responses, see docs\/CustomResponse.md\u003Cbr\u003E\n \u003Cb\u003ECustom:\u0026nbsp;\u0026nbsp;\u0026nbsp; sample_custom_response.ini\u003C\/b\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: HTTP Listener configuration\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENext configure the \u003Cspan class=\u0022code\u0022\u003EHttpDynamic\u003C\/span\u003E custom response in \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\sample_custom_response.ini\u003C\/span\u003E as demonstrated in Figure 10. Make sure to comment-out or replace the default \u003Cspan class=\u0022code\u0022\u003EHttpDynamic\u003C\/span\u003E instance.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E[Example2]\u003Cbr\u003E\n ListenerType:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; HTTP\u003Cbr\u003E\n HttpURIs:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; comm.php\u003Cbr\u003E\n HttpDynamic:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; http_example.py\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: HttpDynamic configuration\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe file \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\CustomProviderExample.py\u003C\/span\u003E can be used as a template for our dynamic response file \u003Cspan class=\u0022code\u0022\u003Ehttp_example.py\u003C\/span\u003E. We modify the \u003Cspan class=\u0022code\u0022\u003EHandleRequest()\u003C\/span\u003E function as illustrated in Figure 11. FakeNet-NG will now encrypt responses dynamically with the nonce.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eimport socket\u003Cbr\u003E\n from arc4 import ARC4\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E# To read about customizing HTTP responses, see docs\/CustomResponse.md\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Edef HandleRequest(req, method, post_data=None):\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026quot;\u0026quot;\u0026quot;Sample dynamic HTTP response handler.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; Parameters\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; ----------\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; req : BaseHTTPServer.BaseHTTPRequestHandler\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; The BaseHTTPRequestHandler that recevied the request\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; method: str\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; The HTTP method, either \u0027HEAD\u0027, \u0027GET\u0027, \u0027POST\u0027 as of this writing\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; post_data: str\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; The HTTP post data received by calling `rfile.read()` against the\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; BaseHTTPRequestHandler that received the request.\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026quot;\u0026quot;\u0026quot;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; response = \u0027Ahoy\\r\\n\u0027\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; nonce = req.path.split(\u0027=\u0027)[1]\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; arc4 = ARC4(nonce)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; response = arc4.encrypt(response)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp; req.send_response(200)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; req.send_header(\u0027Content-Length\u0027, len(response))\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; req.end_headers()\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; req.wfile.write(response)\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Dynamic HTTP request handler\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EStage 4: Manual Custom Responses\u003C\/h4\u003E\n\u003Cp\u003EFor even more flexibility, the all-powerful networking utility \u003Cspan class=\u0022code\u0022\u003Enetcat\u003C\/span\u003E can be used to stand-in for FakeNet-NG listeners. For example, you may want to use \u003Cspan class=\u0022code\u0022\u003Enetcat\u003C\/span\u003E to act as a C2 server and issue commands dynamically during execution on port 80. Launch a \u003Cspan class=\u0022code\u0022\u003Enetcat\u003C\/span\u003E listener before starting FakeNet-NG, and traffic destined for the corresponding port will be diverted to the \u003Cspan class=\u0022code\u0022\u003Enetcat\u003C\/span\u003E listener. You can then issue commands dynamically using the \u003Cspan class=\u0022code\u0022\u003Enetcat\u003C\/span\u003E interface as seen in Figure 12.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture12.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: Use ncat.exe to manually handle traffic\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFakeNet-NG\u0027s custom response capabilities are diverse. Read the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-fakenet-ng\/blob\/feature-tcp-custom-response\/docs\/CustomResponse.md\u0022\u003Edocumentation\u003C\/a\u003E to learn how to boost your custom response high score.\u003C\/p\u003E\n\u003Ch4\u003EStage 5: Blacklisting Processes\u003C\/h4\u003E\n\u003Cp\u003ESome analysts prefer to debug malware from a separate system. There are many reasons to do this; most commonly to preserve the IDA database and other saved data when malware inevitably corrupts the environment. The process usually involves configuring two virtual machines on a host-only network. In this setup, FakeNet-NG intercepts network traffic between the two machines, which renders remote debugging impossible. To overcome this obstacle, we can blacklist the debug server by instructing FakeNet-NG to ignore traffic from the debug server process.\u003C\/p\u003E\n\u003Cp\u003EWhen debugging remotely with IDA Pro, the standard debug server process for a 32-bit Portable Executable is \u003Cspan class=\u0022code\u0022\u003Ewin32_remote.exe\u003C\/span\u003E (or \u003Cspan class=\u0022code\u0022\u003Edbgsrv.exe\u003C\/span\u003E for WinDbg). All you need to do is add the process names to the \u003Cspan class=\u0022code\u0022\u003EProcessBlackList\u003C\/span\u003E configuration as demonstrated in Figure 13. Then, the debug servers can still communicate freely with IDA Pro while all other network traffic is captured and redirected by FakeNet-NG.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E# Specify processes to ignore when diverting traffic. Windows example used here.\u003Cbr\u003E\n ProcessBlackList: win32_remote.exe, dbgsrv.exe\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 13: Modified configs\/default.ini to allow remote debugging with IDA Pro\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBlacklisting is also useful to filter out noisy processes from polluting Fakenet-NG captured network traffic. Examples include processes that attempt to update the Windows system or other malware analysis tools.\u003C\/p\u003E\n\u003Cp\u003EAdditional settings are available for blacklisting ports and hosts. Please see the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-fakenet-ng\u0022\u003EREADME\u003C\/a\u003E for more details about blacklisting and whitelisting.\u003C\/p\u003E\n\u003Ch4\u003EStage 6: Executing Commands on Connection Events\u003C\/h4\u003E\n\u003Cp\u003EFakenet-NG can be configured to execute commands when a connection is made to a Listener. For example, this option can be used to attach a debugger to a running sample upon a connection attempt. Imagine a scenario where we analyze the packed sample named \u003Cspan class=\u0022code\u0022\u003ELab18-01.exe\u003C\/span\u003E from the \u003Ca href=\u0022https:\/\/practicalmalwareanalysis.com\/labs\/\u0022\u003EPractical Malware Analysis labs\u003C\/a\u003E. Using dynamic analysis, we can see that the malware beacons to its C2 server over TCP port 80 using the HTTP protocol as seen in Figure 14.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture14.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 14: Malware beacons to its C2 server over TCP port 80\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWouldn\u2019t it be nice if we could magically attach a debugger to \u003Cspan class=\u0022code\u0022\u003ELab18-01.exe\u003C\/span\u003E when a connection is made? We could speedrun the sample and bypass the entire unpacking stub and any potential anti-debugging tricks the sample may employ.\u003C\/p\u003E\n\u003Cp\u003ETo configure Fakenet-NG to launch and attach a debugger to any process, modify the [\u003Cspan class=\u0022code\u0022\u003EHTTPListener80\u003C\/span\u003E] section in the \u003Cspan class=\u0022code\u0022\u003Efakenet\\configs\\default.ini\u003C\/span\u003E to include the \u003Cspan class=\u0022code\u0022\u003EExecuteCmd\u003C\/span\u003E option. Figure 15 shows an example of a complete [\u003Cspan class=\u0022code\u0022\u003EHTTPListener80\u003C\/span\u003E] section.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E[HTTPListener80]\u003Cbr\u003E\n Enabled:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; True\u003Cbr\u003E\n Port:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 80\u003Cbr\u003E\n Protocol:\u0026nbsp;\u0026nbsp;\u0026nbsp; TCP\u003Cbr\u003E\n Listener:\u0026nbsp;\u0026nbsp;\u0026nbsp; HTTPListener\u003Cbr\u003E\n UseSSL:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; No\u003Cbr\u003E\n Webroot:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; defaultFiles\/\u003Cbr\u003E\n Timeout:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 10\u003Cbr\u003E\n DumpHTTPPosts: Yes\u003Cbr\u003E\n DumpHTTPPostsFilePrefix: http\u003Cbr\u003E\n Hidden:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; False\u003Cbr\u003E\n # Execute x32dbg \u2013p to attach to a debugger. {pid} is filled in automatically by Fakenet-NG\u003Cbr\u003E\n \u003Cb\u003EExecuteCmd: x32dbg.exe -p {pid}\u003C\/b\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 15: Execute command option to run and attach x32dbg\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn this example, we configure the \u003Cspan class=\u0022code\u0022\u003EHTTPListener\u003C\/span\u003E on port 80 to execute the debugger \u003Cspan class=\u0022code\u0022\u003Ex32dbg.exe\u003C\/span\u003E, which will attach to a running process whose process ID is determined at runtime. When a connection is made to \u003Cspan class=\u0022code\u0022\u003EHTTPListener\u003C\/span\u003E, FakeNet-NG will automatically replace the string \u003Cspan class=\u0022code\u0022\u003E{pid}\u003C\/span\u003E with the process ID of the process that makes the connection. For a complete list of supported variables, please refer to the \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-fakenet-ng\/blob\/master\/fakenet\/configs\/default.ini\u0022\u003EDocumentation\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EUpon restarting Fakenet-NG and running the sample again, we see \u003Cspan class=\u0022code\u0022\u003Ex32dbg\u003C\/span\u003E launch and automatically attach to \u003Cspan class=\u0022code\u0022\u003ELab18-01.exe\u003C\/span\u003E. We can now use memory dumping tools such as \u003Cspan class=\u0022code\u0022\u003EScylla\u003C\/span\u003E or the \u003Cspan class=\u0022code\u0022\u003EOllyDumpEx\u003C\/span\u003E plugin to dump the executable and proceed to static analysis. This is demonstrated in Figure 16 and Figure 17.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture16.gif\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 16: Using FakeNet-NG to attach x32dbg to the sample (animated)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture17.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 17: Fakenet-NG executes x32dbg upon connection to practicalmalwareanalysis.com\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EStage 7: Decrypting SSL Traffic\u003C\/h4\u003E\n\u003Cp\u003EOften malware uses SSL for network communication, which hinders traffic analysis considerably as the packet data is encrypted. Using Fakenet-NG\u0027s \u003Cspan class=\u0022code\u0022\u003EProxyListener\u003C\/span\u003E, you can create a packet capture with decrypted traffic. This can be done using the protocol detection feature.\u003C\/p\u003E\n\u003Cp\u003EThe proxy can detect SSL, and \u0026quot;man-in-the-middle\u0026quot; the socket in SSL using Python\u0027s OpenSSL library. It then maintains full-duplex connections with the malware and with the HTTP Listener, with both sides unaware of the other. Consequently, there is a stream of cleartext HTTP traffic between the Proxy and the HTTP Listener, as seen in Figure 18.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture18.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 18: Cleartext streams between Fakenet-NG components\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn order to keep FakeNet-NG as simple as possible, current default settings for FakeNet-NG do not have the proxy intercept HTTPS traffic on port 443 and create the decrypted stream. To proxy the data you need to set the \u003Cspan class=\u0022code\u0022\u003EHTTPListener443 Hidden\u003C\/span\u003E attribute to \u003Cspan class=\u0022code\u0022\u003ETrue\u003C\/span\u003E as demonstrated in Figure 19. This tells the proxy to intercept packets and detect the protocol based on packet contents. Please \u003Ca href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2017\/10\/fakenet-content-based-protocol-detection.html\u0022 adhocenable=\u0022false\u0022\u003Eread our blog post\u003C\/a\u003E\u0026nbsp;on the proxy and protocol detection to learn more about this advanced feature.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E[HTTPListener443]\u003Cbr\u003E\n Enabled:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; True\u003Cbr\u003E\n Port:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;443\u003Cbr\u003E\n Protocol:\u0026nbsp;\u0026nbsp;\u0026nbsp; TCP\u003Cbr\u003E\n Listener:\u0026nbsp;\u0026nbsp;\u0026nbsp; HTTPListener\u003Cbr\u003E\n UseSSL:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Yes\u003Cbr\u003E\n Webroot:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; defaultFiles\/\u003Cbr\u003E\n DumpHTTPPosts: Yes\u003Cbr\u003E\n DumpHTTPPostsFilePrefix: http\u003Cbr\u003E\n \u003Cb\u003EHidden:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; True\u003C\/b\u003E\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 19: Hide the listener so the traffic will be proxied\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EWe can now examine the packet capture produced by Fakenet-NG. The cleartext can be found in a TCP stream between an ephemeral port on localhost (\u003Cspan class=\u0022code\u0022\u003EProxyListener\u003C\/span\u003E) and port 80 on localhost (\u003Cspan class=\u0022code\u0022\u003EHTTPListener\u003C\/span\u003E). This is demonstrated in Figure 20.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fakenetgenie\/Picture20.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 20: Cleartext traffic between HTTPListener and Proxy Listener\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EConclusion (New Game+)\u003C\/h4\u003E\n\u003Cp\u003EFakenet-NG is the de facto standard network simulation tool for malware analysis. It runs without installation and is included in FLARE VM. In addition to its proven and tested default settings, Fakenet offers countless capabilities and configuration options. In this blog post we have presented several tricks to handle common analysis scenarios. To download the latest version, to see a complete list of all configuration options, or to contribute to Fakenet-NG, please see our\u0026nbsp;\u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-fakenet-ng\u0022\u003EGithub repository\u003C\/a\u003E.\u003C\/p\u003E\n",
        "jcr:lastModified": "Mon Mar 30 2020 17:49:25 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003ELearn all about some lesser known features of FakeNet-NG, and some strategies to help master using our network simulation tool.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Mar 30 2020 16:17:39 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Thu Apr 02 2020 15:04:58 GMT+0000",
      "imageRotate": "0"
    }
  }
}
