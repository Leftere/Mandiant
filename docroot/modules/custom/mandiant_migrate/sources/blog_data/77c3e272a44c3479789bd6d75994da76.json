{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed Dec 12 2018 12:29:09 GMT-0500",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "FLARE Script Series: Automating Objective-C Code Analysis with Emulation",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "79b1d21c-86e6-495d-b8d2-b56517e91025",
    "author": "James T. Bennett",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "768341e8-27cc-4a52-b1b8-8670ad54bd1d"
    ],
    "jcr:created": "Wed Dec 12 2018 12:29:09 GMT-0500",
    "cq:lastReplicated": "Wed Dec 12 2018 12:29:08 GMT-0500",
    "cq:lastModified": "Wed Dec 12 2018 12:28:39 GMT-0500",
    "jcr:baseVersion": "768341e8-27cc-4a52-b1b8-8670ad54bd1d",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:cap-james-t-bennett",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:analysis",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:tools"
    ],
    "jcr:uuid": "fc1a4abf-0909-4cb8-93bd-a946778477a5",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Wed Dec 12 2018 12:30:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/FLARE%20emu%20icon.png\u0022 class=\u0022float-right-small\u0022\u003EThis blog post is the next episode in the FireEye Labs Advanced Reverse Engineering (FLARE) team Script Series. Today, we are sharing a new IDAPython library\u0026nbsp;\u2013\u0026nbsp;\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-emu\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u003C\/a\u003E\u0026nbsp;\u2013 powered by \u003Ca href=\u0022https:\/\/www.hex-rays.com\/products\/ida\/\u0022\u003EIDA Pro\u003C\/a\u003E and the \u003Ca href=\u0022https:\/\/www.unicorn-engine.org\/\u0022\u003EUnicorn emulation framework\u003C\/a\u003E that provides scriptable emulation features for the x86, x86_64, ARM, and ARM64 architectures to reverse engineers. Along with this library, we are also sharing an Objective-C code analysis IDAPython script that uses it. Read on to learn some creative ways that emulation can help solve your code analysis problems and how to use our new IDAPython library to save you lots of time in the process.\u003C\/p\u003E\n\u003Ch4\u003EWhy Emulation?\u003C\/h4\u003E\n\u003Cp\u003EIf you haven\u2019t employed emulation as a means to solve a code analysis problem, then you are missing out! I will highlight some of its benefits and a few use cases in order to give you an idea of how powerful it can be. Emulation is flexible, and many emulation frameworks available today, including Unicorn, are cross-platform. With emulation, you choose which code to emulate and you control the context under which it is executed. Because the emulated code cannot access the system services of the operating system under which it is running, there is little risk of it causing damage. All of these benefits make emulation a great option for ad-hoc experimentation, problem solving, or automation.\u003C\/p\u003E\n\u003Ch4\u003EUse Cases\u003C\/h4\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003E\u003Cb\u003EDecoding\/Decryption\/Deobfuscation\/Decompress\u003C\/b\u003E \u2013 Often during malicious code analysis you will come across a function used to decode, decompress, decrypt, or deobfuscate some useful data such as strings, configuration data, or another payload. If it is a common algorithm, you may be able to identify it by sight or with a plug-in such as \u003Ca href=\u0022https:\/\/github.com\/nihilus\/IDA_Signsrch\u0022\u003Esignsrch\u003C\/a\u003E. Unfortunately, this is not often the case. You are then left to either opening up a debugger and instrumenting the sample to decode it for you, or transposing the function by hand into whatever programming language fits your needs at the time. These options can be time consuming and problematic depending on the complexity of the code and the sample you are analyzing. Here, emulation can often provide a preferable third option. Writing a script that emulates the function for you is akin to having the function available to you as if you wrote it or are calling it from a library. This allows you to reuse the function as many times as it\u2019s needed, with varying inputs, without having to open a debugger. This case also applies to self-decrypting shellcode, where you can have the code decrypt itself for you.\u003C\/li\u003E\n\u003Cli\u003E\u003Cb\u003EData Tracking \u003C\/b\u003E\u2013 With emulation, you have the power to stop and inspect the emulation context at any time using an instruction hook. Pairing a disassembler with an emulator allows you to pause emulation at key instructions and inspect the contents of registers and memory. This allows you to keep tabs on interesting data as it flows through a function. This can have several applications. As previously covered in other blogs in the FLARE script series, \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2015\/11\/flare_ida_pro_script.html\u0022\u003EAutomating Function Argument Extraction\u003C\/a\u003E and \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2015\/12\/flare_script_series.html\u0022\u003EAutomating Obfuscated String Decoding\u003C\/a\u003E, this technique can be used to track the arguments passed to a given function throughout an entire program. Function argument tracking is one of the techniques employed by the Objective-C code analysis tool introduced later in this post. The data tracking technique could also be employed to track the \u003Cspan class=\u0022code\u0022\u003Ethis\u003C\/span\u003E pointer in C++ code in order to markup object member references, or the return values from calls to \u003Cspan class=\u0022code\u0022\u003EGetProcAddress\/dlsym\u003C\/span\u003E in order to rename the variables they are stored in appropriately. There are many possibilities.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003EIntroducing flare-emu\u003C\/h4\u003E\n\u003Cp\u003EThe FLARE team is introducing an IDAPython library, \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-emu\u0022\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u003C\/a\u003E,\u0026nbsp;that marries IDA Pro\u2019s binary analysis capabilities with Unicorn\u2019s emulation framework to provide the user with an easy to use and flexible interface for scripting emulation tasks. \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E is designed to handle all the housekeeping of setting up a flexible and robust emulator for its supported architectures so that you can focus on solving your code analysis problems. It currently provides three different interfaces to serve your emulation needs, along with a slew of related helper and utility functions.\u003C\/p\u003E\n\u003Col style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003E\u003Cspan class=\u0022code\u0022\u003EemulateRange\u003C\/span\u003E \u2013 This API is used to emulate a range of instructions, or a function, within a user-specified context. It provides options for user-defined hooks for both individual instructions and for when \u201ccall\u201d instructions are encountered. The user can decide whether the emulator will skip over, or call into function calls. Figure 1 shows \u003Cspan class=\u0022code\u0022\u003EemulateRange\u003C\/span\u003E used with both an instruction and call hook to track the return value of \u003Cspan class=\u0022code\u0022\u003EGetProcAddress\u003C\/span\u003E calls and rename global variables to the name of the Windows APIs they will be pointing to. In this example, it was only set to emulate from \u003Cspan class=\u0022code\u0022\u003E0x401514\u003C\/span\u003E to \u003Cspan class=\u0022code\u0022\u003E0x40153D\u003C\/span\u003E.\u0026nbsp; This interface provides an easy way for the user to specify values for given registers and stack arguments. If a bytestring is specified, it is written to the emulator\u2019s memory and the pointer is written to the register or stack variable. After emulation, the user can make use of \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u2019s utility functions to read data from the emulated memory or registers, or use the Unicorn emulation object that is returned for direct probing in case \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E does not expose some functionality you require.\u003Cbr\u003E\n\u003Cbr\u003E\nA small wrapper function for \u003Cspan class=\u0022code\u0022\u003EemulateRange\u003C\/span\u003E, named \u003Cspan class=\u0022code\u0022\u003EemulateSelection\u003C\/span\u003E, can be used to emulate the range of instructions currently highlighted in IDA Pro.\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: emulateRange being used to track the return value of GetProcAddress\u003Cbr\u003E\n \u003C\/span\u003E\u003Cbr\u003E\n\u003C\/li\u003E\n\u003Cli\u003E\u003Cspan class=\u0022code\u0022\u003Eiterate\u003C\/span\u003E \u2013 This API is used to force emulation down specific branches within a function in order to reach a given target. The user can specify a list of target addresses, or the address of a function from which a list of cross-references to the function is used as the targets, along with a callback for when a target is reached. The targets will be reached, regardless of conditions during emulation that may have caused different branches to be taken. Figure 2 illustrates a set of code branches that \u003Cspan class=\u0022code\u0022\u003Eiterate\u003C\/span\u003E has forced to be taken in order to reach its target; the flags set by the \u003Cspan class=\u0022code\u0022\u003Ecmp\u003C\/span\u003E instructions are irrelevant.\u0026nbsp; Like the \u003Cspan class=\u0022code\u0022\u003EemulateRange\u003C\/span\u003E API, options for user-defined hooks for both individual instructions and for when \u201ccall\u201d instructions are encountered are provided. An example use of the \u003Cspan class=\u0022code\u0022\u003Eiterate\u003C\/span\u003E API is for the function argument tracking technique mentioned earlier in this post.\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: A path of emulation determined by the iterate API in order to reach the target address\u003Cbr\u003E\n \u003C\/span\u003E\u003Cbr\u003E\n\u003C\/li\u003E\n\u003Cli\u003E\u003Cspan class=\u0022code\u0022\u003EemulateBytes\u003C\/span\u003E \u2013 This API provides a way to simply emulate a blob of extraneous shellcode. The provided bytes are not added to the IDB and are simply emulated as is. This can be useful for preparing the emulation environment. For example, \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E itself uses this API to manipulate a Model Specific Register (MSR) for the ARM64 CPU that is not exposed by Unicorn in order to enable Vector Floating Point (VFP) instructions and register access. Figure 3 shows the code snippet that achieves this. Like with \u003Cspan class=\u0022code\u0022\u003EemulateRange\u003C\/span\u003E, the Unicorn emulation object is returned for further probing by the user in case \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E does not expose some functionality required by the user.\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: flare-emu using emulateBytes to enable VFP for ARM64\u003C\/span\u003E\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch4\u003EAPI Hooking\u003C\/h4\u003E\n\u003Cp\u003EAs previously stated, \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E is designed to make it easy for you to use emulation to solve your code analysis needs. One of the pains of emulation is in dealing with calls into library functions. While \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E gives you the option to simply skip over call instructions, or define your own hooks for dealing with specific functions within your call hook routine, it also comes with predefined hooks for over 80 functions! These functions include many of the common C runtime functions for string and memory manipulation that you will encounter, as well as some of their Windows API counterparts.\u003C\/p\u003E\n\u003Ch4\u003EExamples\u003C\/h4\u003E\n\u003Cp\u003EFigure 4 shows a few blocks of code that call a function that takes a timestamp value and converts it to a string. Figure 5 shows a simple script that uses \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u2019s \u003Cspan class=\u0022code\u0022\u003Eiterate\u003C\/span\u003E API to print the arguments passed to this function for each place it is called. The script also emulates a simple XOR decode function and prints the resulting, decoded string. Figure 6 shows the resulting output of the script.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Calls to a timestamp conversion function\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Simple example of flare-emu usage\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Output of script shown in Figure 5\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EHere is a \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-emu\/blob\/master\/rename_dynamic_imports.py\u0022\u003Esample script that uses \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E\u003C\/a\u003E to track return values of \u003Cspan class=\u0022code\u0022\u003EGetProcAddress\u003C\/span\u003E and rename the variables they are stored in accordingly. Check out our \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-emu\/blob\/master\/README.md\u0022\u003EREADME\u003C\/a\u003E for more examples and help with \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E.\u003C\/p\u003E\n\u003Ch4\u003EIntroducing objc2_analyzer\u003C\/h4\u003E\n\u003Cp\u003ELast year, I wrote a blog post to introduce you to \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/03\/introduction_to_reve.html\u0022\u003Ereverse engineering Cocoa applications for macOS\u003C\/a\u003E. That post included a short primer on how Objective-C methods are called under the hood, and how this adversely affects cross-references in IDA Pro and other disassemblers. An IDAPython script named \u003Cspan class=\u0022code\u0022\u003Eobjc2_xrefs_helper\u003C\/span\u003E was also introduced in the post to help fix these cross-references issues. If you have not read that blog post, I recommend reading it before continuing on reading this post as it provides some context for what makes \u003Cspan class=\u0022code\u0022\u003Eobjc2_analyzer\u003C\/span\u003E particularly useful. A major shortcoming of \u003Cspan class=\u0022code\u0022\u003Eobjc2_xrefs_helper\u003C\/span\u003E was that if a selector name was ambiguous, meaning that two or more classes implement a method with the same name, the script was unable to determine which class the referenced selector belonged to at any given location in the binary and had to ignore such cases when fixing cross-references.\u003C\/p\u003E\n\u003Cp\u003ENow, with emulation support, this is no longer the case. \u003Cspan class=\u0022code\u0022\u003Eobjc2_analyzer\u003C\/span\u003E uses the iterate API from \u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E along with instruction and call hooks that perform Objective-C disassembly analysis in order to determine the \u003Cspan class=\u0022code\u0022\u003Eid\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003Eselector\u003C\/span\u003E being passed for every call to \u003Cspan class=\u0022code\u0022\u003Eobjc_msgSend\u003C\/span\u003E variants in a binary. As an added bonus, it can also catch calls made to \u003Cspan class=\u0022code\u0022\u003Eobjc_msgSend\u003C\/span\u003E variants when the function pointer is stored in a register, which is a very common pattern in Clang (the compiler used by modern versions of Xcode). IDA Pro tries to catch these itself and does a pretty good job, but it doesn\u2019t catch them all. In addition to x86_64, support was also added for the ARM and ARM64 architectures in order to support reverse engineering iOS applications. This script supersedes the older \u003Cspan class=\u0022code\u0022\u003Eobjc2_xrefs_helper\u003C\/span\u003E script, which has been removed from our repo. And, since the script can perform such data tracking in Objective-C code by using emulation, it can also determine whether an \u003Cspan class=\u0022code\u0022\u003Eid\u003C\/span\u003E is a class instance or a class object itself. Additional support has been added to track \u003Cspan class=\u0022code\u0022\u003Eivars\u003C\/span\u003E being passed as \u003Cspan class=\u0022code\u0022\u003Eids\u003C\/span\u003E as well. With all this information, Objective-C-style pseudocode comments are added to each call to \u003Cspan class=\u0022code\u0022\u003Eobjc_msgSend\u003C\/span\u003E variants that represent the method call being made at each location. An example of the script\u2019s capability is shown in Figure 7 and Figure 8.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Objective-C IDB snippet before running objc2_analyzer\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Objective-C IDB snippet after running objc2_analyzer\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EObserve the instructions referencing selectors have been patched to instead reference the implementation function itself, for easy transition. The comments added to each call make analysis much easier. Cross-references from the implementation functions are also created to point back to the \u003Cspan class=\u0022code\u0022\u003Eobjc_msgSend\u003C\/span\u003E calls that reference them as shown in Figure 9.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/FLAREemu\/Picture9.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Cross-references added to IDB for implementation function\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIt should be noted that every release of IDA Pro starting with 7.0 have brought improvements to Objective-C code analysis and handling. However, at the time of writing, the latest version of IDA Pro being 7.2, there are still shortcomings that are mitigated using this tool as well as the immensely helpful comments that are added. \u003Cspan class=\u0022code\u0022\u003Eobjc2_analyzer\u003C\/span\u003E is available, along with our \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-ida\u0022\u003Eother IDA Pro plugins and scripts\u003C\/a\u003E, at our GitHub page.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eflare-emu\u003C\/span\u003E is a flexible tool to include in your arsenal that can be applied to a variety of code analysis problems. Several example problems were presented and solved using it in this blog post, but this is just a glimpse of its possible applications. If you haven\u2019t given emulation a try for solving your code analysis problems, we hope you will now consider it an option. And for all, we hope you find value in using these new tools!\u003C\/p\u003E\n",
        "jcr:lastModified": "Wed Dec 12 2018 12:04:49 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed Dec 12 2018 12:28:39 GMT-0500",
      "imageRotate": "0"
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EWe are sharing a new IDAPython library\u0026nbsp;that provides scriptable emulation features to reverse engineers.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Dec 12 2018 11:35:50 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    }
  }
}
