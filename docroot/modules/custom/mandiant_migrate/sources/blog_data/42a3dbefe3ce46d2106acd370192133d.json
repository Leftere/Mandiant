{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "fireeye_global_admin",
  "jcr:created": "Wed Apr 01 2020 16:04:13 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "fireeye_global_admin",
    "jcr:title": "Kerberos Tickets on Linux Red Teams",
    "jcr:versionHistory": "9bea5b8a-051c-483d-b778-4c7ea6c69ff9",
    "author": "Trevor Haskell",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "f7e913cd-ca3b-49f9-921a-d76055e6648f"
    ],
    "jcr:created": "Fri Jul 24 2020 06:26:40 GMT+0000",
    "cq:lastModified": "Fri Jul 24 2020 06:26:02 GMT+0000",
    "jcr:baseVersion": "f7e913cd-ca3b-49f9-921a-d76055e6648f",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:trevor-haskell",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:kerberos",
      "fireeye-blog-tags:linux",
      "fireeye-blog-tags:mandiant",
      "fireeye-blog-tags:red-team"
    ],
    "jcr:uuid": "97c631eb-fc58-4205-9efe-4e04ee3483aa",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Wed Apr 01 2020 12:00:00 GMT-0400",
    "cq:lastModifiedBy": "reference-adjustment-service",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EAt \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/mandiant\/incident-response.html\u0022\u003EFireEye Mandiant\u003C\/a\u003E, we conduct numerous red team engagements within Windows Active Directory environments. Consequently, we frequently encounter Linux systems integrated within Active Directory environments. Compromising an individual domain-joined Linux system can provide useful data on its own, but the best value is obtaining data, such as Kerberos tickets, that will facilitate lateral movement techniques. By passing these Kerberos Tickets from a Linux system, it is possible to move laterally from a compromised Linux system to the rest of the Active Directory domain.\u003C\/p\u003E\n\u003Cp\u003EThere are several ways to configure a Linux system to store Kerberos tickets. In this blog post, we will introduce Kerberos and cover some of the various storage solutions. We will also introduce a new tool that extracts Kerberos tickets from domain-joined systems that utilize the System Security Services Daemon Kerberos Cache Manager (SSSD KCM).\u003C\/p\u003E\n\u003Ch4\u003EWhat is Kerberos\u003C\/h4\u003E\n\u003Cp\u003EKerberos is a standardized authentication protocol that was originally created by MIT in the 1980s. The protocol has evolved over time. Today, Kerberos Version 5 is implemented by numerous products, including Microsoft Active Directory.\u0026nbsp;Kerberos was originally designed to mutually authenticate identities over an unsecured communication line.\u003C\/p\u003E\n\u003Cp\u003EThe Microsoft implementation of Kerberos is used in Active Directory environments to securely authenticate users to various services, such as the domain (LDAP), database servers (MSSQL) and file shares (SMB\/CIFS). While other authentication protocols exist within Active Directory, Kerberos is one of the most popular methods. Technical documentation on how Microsoft implemented Kerberos Protocol Extensions within Active Directory can be found in the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/openspecs\/windows_protocols\/ms-kile\/2a32282e-dd48-4ad9-a542-609804b02cc9\u0022\u003EMS-KILE standards\u003C\/a\u003E published on MSDN.\u0026nbsp;\u003C\/p\u003E\n\u003Ch4\u003EShort Example of Kerberos Authentication in Active Directory\u003C\/h4\u003E\n\u003Cp\u003ETo illustrate how Kerberos works, we have selected a common scenario where a user John Smith with the account ACMENET.CORP\\sa_jsmith wishes to authenticate to a Windows SMB (CIFS) file share in the Acme Corporation domain, hosted on the server SQLSERVER.ACMENET.CORP.\u003C\/p\u003E\n\u003Cp\u003EThere are two main types of Kerberos tickets used in Active Directory: Ticket Granting Ticket (TGT) and service tickets. Service tickets are obtained from the Ticket Granting Service (TGS). The TGT is used to authenticate the identity of a particular entity in Active Directory, such as a user account. Service tickets are used to authenticate a user to a specific service hosted on a system. A valid TGT can be used to request service tickets from the Key Distribution Center (KDC). In Active Directory environments, the KDC is hosted on a Domain Controller.\u003C\/p\u003E\n\u003Cp\u003EThe diagram in Figure 1 shows the authentication flow.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture1.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Example Kerberos authentication flow\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EIn summary:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EThe user requests a Ticket Granting Ticket (TGT) from the Domain Controller.\u003C\/li\u003E\n\u003Cli\u003EOnce granted, the user passes the TGT back to the Domain Controller and requests a service ticket for cifs\/SQLSERVER.ACMENET.CORP.\u003C\/li\u003E\n\u003Cli\u003EAfter the Domain Controller validates the request, a service ticket is issued that will authenticate the user to the CIFS (SMB) service on SQLSERVER.ACMENET.CORP.\u003C\/li\u003E\n\u003Cli\u003EThe user receives the service ticket from the Domain Controller and initiates an SMB negotiation with SQLSERVER.ACMENET.CORP. During the authentication process, the user provides a Kerberos blob inside an \u201cAP-REQ\u201d structure that includes the service ticket previously obtained.\u003C\/li\u003E\n\u003Cli\u003EThe server validates the service ticket and authenticates the user.\u003C\/li\u003E\n\u003Cli\u003EIf the server determines that the user has permissions to access the share, the user can begin making SMB queries.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EFor an in-depth example of how Kerberos authentication works, scroll down to view the appendix at the bottom of this article.\u003C\/p\u003E\n\u003Ch4\u003EKerberos On Linux Domain-Joined Systems\u003C\/h4\u003E\n\u003Cp\u003EWhen a Linux system is joined to an Active Directory domain, it also needs to use Kerberos tickets to access services on the Windows Active Directory domain. Linux uses a different Kerberos implementation. Instead of Windows formatted tickets (commonly referred to as the KIRBI format), Linux uses MIT format Kerberos Credential Caches (CCACHE files).\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003EWhen a user on a Linux system wants to access a remote service with Kerberos, such as a file share, the same procedure is used to request the TGT and corresponding service ticket. In older, more traditional implementations, Linux systems often stored credential cache files in the \/tmp directory. Although the files are locked down and not world-readable, a malicious user with root access to the Linux system could trivially obtain a copy of the Kerberos tickets and reuse them.\u003C\/p\u003E\n\u003Cp\u003EOn modern versions of Red Hat Enterprise Linux and derivative distributions, the System Security Services Daemon (SSSD) is used to manage Kerberos tickets on domain-joined systems. SSSD implements its own form of Kerberos Cache Manager (KCM) and encrypts tickets within a database on the system. When a user needs access to a TGT or service ticket, the ticket is retrieved from the database, decrypted, and then passed to the remote service (for more on SSSD, check out this \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/labs.portcullis.co.uk\/presentations\/where-2-worlds-collide-bringing-mimikatz-et-al-to-unix\/#more-6806\u0022\u003Egreat research from Portcullis Labs\u003C\/a\u003E).\u003C\/p\u003E\n\u003Cp\u003EBy default, SSSD maintains a copy of the database at the path \/var\/lib\/sss\/secrets\/secrets.ldb. The corresponding key is stored as a hidden file at the path \/var\/lib\/sss\/secrets\/.secrets.mkey. By default, the key is only readable if you have root permissions.\u003C\/p\u003E\n\u003Cp\u003EIf a user is able to extract both of these files, it is possible to decrypt the files offline and obtain valid Kerberos tickets. We have published a new tool called \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/SSSDKCMExtractor\u0022\u003ESSSDKCMExtractor\u003C\/a\u003E that will decrypt relevant secrets in the SSSD database and pull out \u0026nbsp;the credential cache Kerberos blob. This blob can be converted into a usable Kerberos CCache file that can be passed to other tools, such as \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/gentilkiwi\/mimikatz\u0022\u003EMimikatz\u003C\/a\u003E, \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/SecureAuthCorp\/impacket\u0022\u003EImpacket\u003C\/a\u003E, and \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.samba.org\/samba\/docs\/current\/man-html\/smbclient.1.html\u0022\u003Esmbclient\u003C\/a\u003E. CCache files can be converted into Windows format using tools such as \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/gentilkiwi\/kekeo\u0022\u003EKekeo\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EWe leave it as an exercise to the reader to convert the decrypted Kerberos blob into a usable credential cache file for pass-the-cache and pass-the-ticket operations.\u003C\/p\u003E\n\u003Cp\u003EUsing SSSDKCMExtractor is simple. An example SSSD KCM database and key are shown in Figure 2.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture2.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: SSSD KCM files\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EInvoking SSSDKCMExtractor with the --database and --key parameters will parse the database and decrypt the secrets as shown in Figure 3.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Extracting Kerberos data\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAfter manipulating the data retrieved, it is possible to use the CCACHE in smbclient as shown in Figure 4. In this example, a domain administrator ticket was obtained and used to access the domain controller\u2019s C$ share.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture4.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Compromising domain controller with extracted tickets\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/SSSDKCMExtractor\u0022\u003EPython script and instructions\u003C\/a\u003E can be found on the FireEye Github.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EBy obtaining privileged access to a domain-joined Linux system, it is often possible to scrape Kerberos tickets useful for lateral movement. Although it is still common to find these tickets in the \/tmp directory, it is now possible to also scrape these tickets from modern Linux systems that utilize the SSSD KCM.\u003C\/p\u003E\n\u003Cp\u003EWith the right Kerberos tickets, it is possible to move laterally to the rest of the Active Directory domain. If a privileged user authenticates to a compromised Linux system (such as a Domain Admin) and leaves a ticket behind, it would be possible to steal that user\u0027s ticket and obtain privileged rights in the Active Directory domain.\u003C\/p\u003E\n\u003Ch4\u003EAppendix: Detailed Example of Kerberos Authentication in Active Directory\u003C\/h4\u003E\n\u003Cp\u003ETo illustrate how Kerberos works, we have selected a common scenario where a user John Smith with the account ACMENET.CORP\\sa_jsmith wishes to authenticate to a Windows SMB (CIFS) file share in the Acme Corporation domain, hosted on the server SQLSERVER.ACMENET.CORP.\u003C\/p\u003E\n\u003Cp\u003EThere are two main types of Kerberos ticket types used in Active Directory: Ticket Granting Ticket (TGT) and service tickets. Service tickets are obtained from the Ticket Granting Service (TGS). The TGT is used to authenticate the identity of a particular entity in Active Directory, such as a user account. Service tickets are used to authenticate a user to a specific service hosted on a domain- joined system. A valid TGT can be used to request service tickets from the Key Distribution Center (KDC). In Active Directory environments, the KDC is hosted on a Domain Controller.\u003C\/p\u003E\n\u003Cp\u003EWhen the user wants to authenticate to the remote file share, Windows first checks if a valid TGT is present in memory on the user\u0027s workstation. If a TGT isn\u0027t present, a new TGT is requested from the Domain Controller in the form of an AS-REQ request. To prevent password cracking attacks (\u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/www.harmj0y.net\/blog\/activedirectory\/roasting-as-reps\/\u0022\u003EAS-REP Roasting\u003C\/a\u003E), by default, Kerberos Preauthentication is performed first. Windows creates a timestamp and encrypts the timestamp with the user\u0027s Kerberos key (Note: User Kerberos keys vary based on encryption type. In the case of RC4 encryption, the user\u0027s RC4 Kerberos key is directly derived from the user\u0027s account password. In the case of AES encryption, the user\u0027s Kerberos key is derived from the user\u0027s password and a salt based on the username and domain name). The domain controller receives the request and decrypts the timestamp by looking up the user\u0027s Kerberos key. An example AS-REQ packet is shown in Figure 5.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture5.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: AS-REQ\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce preauthentication is successful, the Domain Controller issues an AS-REP response packet that contains various metadata fields, the TGT itself, and an \u0026quot;Authenticator\u0026quot;. The data within the TGT itself is considered sensitive. If a user could freely modify the content within the TGT, they could \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/adsecurity.org\/?p=1515\u0022\u003Eimpersonate any user in the domain\u003C\/a\u003E\u0026nbsp;as performed in the Golden Ticket attack. To prevent this from easily occurring, the TGT is encrypted with the long term Kerberos key stored on the Domain Controller. This key is derived from the password of the krbtgt account in Active Directory.\u003C\/p\u003E\n\u003Cp\u003ETo prevent users from impersonating another user with a stolen TGT blob, Active Directory\u2019s Kerberos implementation uses session keys that are used for mutual authentication between the user, domain, and service. When the TGT is requested, the Domain Controller generates a session key and places it in two places: the TGT itself (which is encrypted with the krbtgt key and unreadable by the end user), and in a separate structure called the Authenticator. The Domain Controller encrypts the Authenticator with the user\u0027s personal Kerberos key.\u003C\/p\u003E\n\u003Cp\u003EWhen Windows receives the AS-REP packet back from the domain controller, it caches the TGT ticket data itself into memory. It also decrypts the Authenticator with the user\u0027s Kerberos key and obtains a copy of the session key generated by the Domain Controller. Windows stores this session key in memory for future use. At this point, the user\u0027s system has a valid TGT that it can use to request service tickets from the domain controller. An example AS-REP packet is shown in Figure 6.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture6.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: AS-REP\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAfter obtaining a valid TGT for the user, Windows requests a service ticket for the file share service hosted on the remote system SQLSERVER.ACMENET.CORP. The request is made using the service\u0027s Service Principal Name (\u201cSPN\u201d). In this case, the SPN would be cifs\/SQLSERVER.ACMENET.CORP. Windows builds the service ticket request in a TGS-REQ packet. Within the TGS-REQ packet, Windows places a copy of the TGT previously obtained from the Domain Controller. This time, the Authenticator is encrypted with the TGT session key previously obtained from the domain controller. An example TGS-REQ packet is shown in Figure 7.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture7.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: TGS-REQ\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce the Domain Controller receives the TGS-REQ packet, it extracts the TGT from the request and decrypts it with the krbtgt Kerberos key. The Domain Controller verifies that the TGT is valid and extracts the session key field from the TGT. The Domain Controller then attempts to decrypt the Authenticator in the TGS-REQ packet with the session key. Once decrypted, the Domain Controller examines the Authenticator and verifies the contents. If this operation succeeds, the user is considered authenticated by the Domain Controller and the requested service ticket is created.\u003C\/p\u003E\n\u003Cp\u003EThe Domain Controller generates the service ticket requested for cifs\/SQLSERVER.ACMENET.CORP. The data within the service ticket is also considered sensitive. If a user could manipulate the service ticket data, they could \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/adsecurity.org\/?p=1515\u0022\u003Eimpersonate any user on the domain to the service\u003C\/a\u003E\u0026nbsp;as performed in the Silver Ticket attack. To prevent this from easily happening, the Domain Controller encrypts the service ticket with the Kerberos key of the computer the user is authenticating to. All domain-joined computers in Active Directory possess a randomly generated computer account credential that both the computer and Domain Controller are aware of. The Domain Controller also generates a second session key specific to the service ticket and places a copy in both the encrypted service ticket and a new Authenticator structure. This Authenticator is encrypted with the first session key (the TGT session key). The service ticket, Authenticator, and metadata are bundled in a TGS-REP packet and forwarded back to the user. An example TGS-REP packet is shown in Figure 8.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture8.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: TGS-REP\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce Windows receives the TGS-REP for cifs\/SQLSERVER.ACMENET.CORP, Windows extracts the service ticket from the packet and caches it into memory. It also decrypts the Authenticator with the TGT specific session key to obtain the new service specific session key. Using both pieces of information, it is now possible for the user to authenticate to the remote file share. Windows negotiates a SMB connection with SQLSERVER.ACMENET.CORP. It places a Kerberos blob in an \u0026quot;ap-req\u0026quot; structure. This Kerberos blob includes the service ticket received from the domain controller, a new Authenticator structure, and metadata. The new Authenticator is encrypted with the service specific session key that was previously obtained from the Domain Controller.\u0026nbsp;The authentication process is shown in Figure 9.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture9.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Authenticating to SMB (AP-REQ)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EOnce the file share server receives the authentication request, it first extracts and decrypts the service ticket from the Kerberos authentication blob and verifies the data within. It also extracts the service specific session key from the service ticket and attempts to decrypt the Authenticator with it. If this operation succeeds, the user is considered to be authenticated to the service. The server will acknowledge the successful authentication by sending one final Authenticator back to the user, encrypted with the service specific session key. This action completes the mutual authentication process. The response (contained within an \u201cap-rep\u201d structure) is shown in Figure 10.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture10.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: Final Authenticator (Mutual Authentication, AP-REP)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EA diagram of the authentication flow is shown in Figure 11.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/kerberostickets\/Picture11.png\u0022 alt=\u0022\u0022\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Example Kerberos authentication flow\u003C\/span\u003E\u003C\/p\u003E\n",
        "jcr:lastModified": "Mon Apr 20 2020 19:47:25 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EWe introduce Kerberos, cover some of the various storage solutions, and introduce a new tool that extracts Kerberos tickets.\u003C\/p\u003E\n",
      "jcr:lastModified": "Tue Mar 31 2020 18:01:10 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed Apr 01 2020 16:04:04 GMT+0000",
      "imageRotate": "0"
    }
  }
}
