{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Wed Mar 03 2021 19:30:05 GMT+0000",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Fuzzing Image Parsing in Windows, Part Two: Uninitialized Memory",
    "jcr:versionHistory": "974932bd-97bf-4dc3-a8ef-6875b488d7fe",
    "author": "Dhanesh Kizhakkinan",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "db54bdb0-4878-4b84-84f1-4b11a914efb7"
    ],
    "jcr:created": "Wed Mar 03 2021 19:30:05 GMT+0000",
    "cq:lastModified": "Wed Mar 03 2021 19:29:58 GMT+0000",
    "jcr:baseVersion": "db54bdb0-4878-4b84-84f1-4b11a914efb7",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:dhanesh-kizhakkinan",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:FLARE",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:vulnerabilities",
      "fireeye-blog-tags:windows",
      "fireeye-blog-tags:otf"
    ],
    "jcr:uuid": "45592323-7e15-42e0-aef9-5f6997fa0e44",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Wed Mar 03 2021 14:30:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EContinuing our discussion of \u003Ca adhocenable=\u0022false\u0022 href=\u0022\/content\/fireeye-www\/en_US\/blog\/threat-research\/2020\/09\/fuzzing-image-parsing-in-windows-color-profiles.html\u0022\u003Eimage parsing vulnerabilities in Windows\u003C\/a\u003E, we take a look at a comparatively less popular vulnerability class: uninitialized memory. In this post, we will look at Windows\u2019 inbuilt image parsers\u2014specifically for vulnerabilities involving the use of uninitialized memory.\u003C\/p\u003E\n\u003Ch4\u003EThe Vulnerability: Uninitialized Memory\u003C\/h4\u003E\n\u003Cp\u003EIn unmanaged languages, such as C or C++, variables are not initialized by default. Using uninitialized variables causes undefined behavior and may cause a crash. There are roughly two variants of uninitialized memory:\u003C\/p\u003E\n\u003Cul\u003E\n\u003Cli\u003EDirect uninitialized memory usage: An uninitialized pointer or an index is used in read or write. This may cause a crash.\u003C\/li\u003E\n\u003Cli\u003EInformation leakage (info leak) through usage of uninitialized memory: Uninitialized memory content is accessible across a security boundary. An example: an uninitialized kernel buffer accessible from user mode, leading to information disclosure.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003EIn this post we will be looking closely at the second variant in Windows image parsers, which will lead to information disclosure in situations such as web browsers where an attacker can read the decoded image back using JavaScript.\u003C\/p\u003E\n\u003Ch4\u003EDetecting Uninitialized Memory Vulnerabilities\u003C\/h4\u003E\n\u003Cp\u003ECompared to memory corruption vulnerabilities such as heap overflow and use-after-free, uninitialized memory vulnerabilities on their own do not access memory out of bound or out of scope. This makes detection of these vulnerabilities slightly more complicated than memory corruption vulnerabilities. While direct uninitialized memory usage can cause a crash and can be detected, information leakage doesn\u2019t usually cause any crashes. Detecting it requires compiler instrumentations such as MemorySanitizer or binary instrumentation\/recompilation tools such as Valgrind.\u003C\/p\u003E\n\u003Ch4\u003EDetour: Detecting Uninitialized Memory in Linux\u003C\/h4\u003E\n\u003Cp\u003ELet\u0027s take a little detour and look at detecting uninitialized memory in Linux and compare with Windows\u2019 built-in capabilities. Even though compilers warn about some uninitialized variables, most of the complicated cases of uninitialized memory usage are not detected at compile time. For this, we can use a run-time detection mechanism. MemorySanitizer is a compiler instrumentation for both GCC and Clang, which detects uninitialized memory reads. A sample of how it works is given in Figure 1.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ cat sample.cc\u003Cbr\u003E\n #include \u0026lt;stdio.h\u0026gt;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eint main()\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; int *arr = new int[10];\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; if(arr[3] == 0)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;printf(\u0026quot;Yay!\\n\u0026quot;);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; printf(\u0026quot;%08x\\n\u0026quot;, arr[3]);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; return 0;\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ clang++ -fsanitize=memory -fno-omit-frame-pointer -g sample.cc\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E$ .\/a.out\u003Cbr\u003E\n ==29745==WARNING: MemorySanitizer: use-of-uninitialized-value\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; #0 0x496db8\u0026nbsp; (\/home\/dan\/uni\/a.out+0x496db8)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; #1 0x7f463c5f1bf6\u0026nbsp; (\/lib\/x86_64-linux-gnu\/libc.so.6+0x21bf6)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; #2 0x41ad69\u0026nbsp; (\/home\/dan\/uni\/a.out+0x41ad69)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003ESUMMARY: MemorySanitizer: use-of-uninitialized-value (\/home\/dan\/uni\/a.out+0x496db8)\u003Cbr\u003E\n Exiting\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: MemorySanitizer detection of uninitialized memory\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ESimilarly, Valgrind can also be used to detect uninitialized memory during run-time.\u003C\/p\u003E\n\u003Ch4\u003EDetecting Uninitialized Memory in Windows\u003C\/h4\u003E\n\u003Cp\u003ECompared to Linux, Windows lacks any built-in mechanism for detecting uninitialized memory usage. While Visual Studio and Clang-cl recently introduced \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/devblogs.microsoft.com\/cppblog\/addresssanitizer-asan-for-windows-with-msvc\/\u0022\u003EAddressSanitizer support\u003C\/a\u003E, MemorySanitizer and other sanitizers are not implemented as of this writing.\u003C\/p\u003E\n\u003Cp\u003ESome of the useful tools in Windows to detect memory corruption vulnerabilities such as \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows-hardware\/drivers\/debugger\/gflags-and-pageheap\u0022\u003EPageHeap\u003C\/a\u003E do not help in detecting uninitialized memory. On the contrary, PageHeap fills the memory allocations with patterns, which essentially makes them initialized.\u003C\/p\u003E\n\u003Cp\u003EThere are few third-party tools, including Dr.Memory, that use binary instrumentation to detect memory safety issues such as heap overflows, uninitialized memory usages, use-after-frees, and others.\u003C\/p\u003E\n\u003Ch4\u003EDetecting Uninitialized Memory in Image Decoding\u003C\/h4\u003E\n\u003Cp\u003EDetecting uninitialized memory in Windows usually requires binary instrumentation, especially when we do not have access to source code. One of the indicators we can use to detect uninitialized memory usage, specifically in the case of image decoding, is the resulting pixels after the image is decoded.\u003C\/p\u003E\n\u003Cp\u003EWhen an image is decoded, it results in a set of raw pixels. If image decoding uses any uninitialized memory, some or all of the pixels may end up as random. In simpler words, decoding an image multiple times may result in different output each time if uninitialized memory is used. This difference of output can be used to detect uninitialized memory and aid writing a fuzzing harness targeting Windows image decoders. An example fuzzing harness is presented in Figure 2.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E#define ROUNDS 20\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eunsigned char* DecodeImage(char *imagePath)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; unsigned char *pixels = NULL;\u0026nbsp; \u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ use GDI or WIC to decode image and get the resulting pixels\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; ...\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; ...\u0026nbsp; \u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; return pixels;\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Evoid Fuzz(char *imagePath)\u003Cbr\u003E\n {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; unsigned char *refPixels = DecodeImage(imagePath);\u0026nbsp; \u0026nbsp; \u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; if(refPixels != NULL)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; for(int i = 0; i \u0026lt; ROUNDS; i++)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; unsigned char *currPixels = DecodeImage(imagePath);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; if(!ComparePixels(refPixels, currPixels))\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/\/ the reference pixels and current pixels don\u0027t match\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \/\/ crash now to let the fuzzer know of this file\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; CrashProgram();\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; free(currPixels);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; free(refPixels);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n }\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Diff harness\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe idea behind this fuzzing harness is not entirely new; previously, \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/lcamtuf.blogspot.com\/2014\/09\/cve-2014-1564-uninitialized-memory-when.html\u0022\u003Elcamtuf\u003C\/a\u003E used a similar idea to detect uninitialized memory in open-source image parsers and used a web page to display the pixel differences.\u003C\/p\u003E\n\u003Ch4\u003EFuzzing\u003C\/h4\u003E\n\u003Cp\u003EWith the diffing harness ready, one can proceed to look for the supported image formats and gather corpuses. Gathering image files for corpus is considerably easy given the near unlimited availability on the internet, but at the same time it is harder to find good corpuses among millions of files with unique code coverage. Code coverage information for Windows image parsing is tracked from WindowsCodecs.dll.\u003C\/p\u003E\n\u003Cp\u003ENote that unlike regular Windows fuzzing, we will not be enabling PageHeap this time as PageHeap \u201cinitializes\u201d the heap allocations with patterns.\u003C\/p\u003E\n\u003Ch4\u003EResults\u003C\/h4\u003E\n\u003Cp\u003EDuring my research, I found three cases of uninitialized memory usage while fuzzing Windows built-in image parsers. Two of them are explained in detail in the next sections. Root cause analysis of uninitialized memory usage is non-trivial. We don\u2019t have a crash location to back trace, and have to use the resulting pixel buffer to back trace to find the root cause\u2014or use clever tricks to find the deviation.\u003C\/p\u003E\n\u003Ch3\u003ECVE-2020-0853\u003C\/h3\u003E\n\u003Cp\u003ELet\u2019s look at the rendering of the proof of concept (PoC) file before going into the root cause of this vulnerability. For this we will use lcamtuf\u2019s HTML, which loads the PoC image multiple times and compares the pixels with reference pixels.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fuzzing-image2\/fig3.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: CVE-2020-0853\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAs we can see from the resulting images (Figure 3), the output varies drastically in each decoding and we can assume this PoC leaks a lot of uninitialized memory.\u003C\/p\u003E\n\u003Cp\u003ETo identify the root cause of these vulnerabilities, I used Time Travel Debugging (TTD) extensively. Tracing back the execution and keeping track of the memory address is a tedious task, but TTD makes it only slightly less painful by keeping the addresses and values constant and providing unlimited forward and backward executions.\u0026nbsp;\u003C\/p\u003E\n\u003Cp\u003EAfter spending quite a bit of time debugging the trace, I found the source of uninitialized memory in \u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!CFormatConverter::Initialize\u003C\/span\u003E. Even though the source was found, it was not initially clear why this memory ends up in the calculation of pixels without getting overwritten at all. To solve this mystery, additional debugging was done by comparing PoC execution trace against a normal TIFF file decoding. The following section shows the allocation, copying of uninitialized value to pixel calculation and the actual root cause of the vulnerability.\u003C\/p\u003E\n\u003Ch4\u003EAllocation and Use of Uninitialized Memory\u003C\/h4\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!CFormatConverter::Initialize\u003C\/span\u003E allocates 0x40 bytes of memory, as shown in Figure 4.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; r\u003Cbr\u003E\n rax=0000000000000000 rbx=0000000000000040 rcx=0000000000000040\u003Cbr\u003E\n rdx=0000000000000008 rsi=000002257a3db448 rdi=0000000000000000\u003Cbr\u003E\n rip=00007ffaf047a238 rsp=000000ad23f6f7c0 rbp=000000ad23f6f841\u003Cbr\u003E\n \u0026nbsp;r8=000000ad23f6f890\u0026nbsp; r9=0000000000000010 r10=000002257a3db468\u003Cbr\u003E\n r11=000000ad23f6f940 r12=000000000000000e r13=000002257a3db040\u003Cbr\u003E\n r14=000002257a3dbf60 r15=0000000000000000\u003Cbr\u003E\n iopl=0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; nv up ei pl zr na po nc\u003Cbr\u003E\n cs=0033\u0026nbsp; ss=002b\u0026nbsp; ds=002b\u0026nbsp; es=002b\u0026nbsp; fs=0053\u0026nbsp; gs=002b\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; efl=00000246\u003Cbr\u003E\n windowscodecs!CFormatConverter::Initialize+0x1c8:\u003Cbr\u003E\n 00007ffa`f047a238 ff15ea081200\u0026nbsp;\u0026nbsp;\u0026nbsp; call\u0026nbsp;\u0026nbsp;\u0026nbsp; qword ptr [windowscodecs!_imp_malloc (00007ffa`f059ab28)] ds:00007ffa`f059ab28={msvcrt!malloc (00007ffa`f70e9d30)}\u003Cbr\u003E\n 0:000\u0026gt; k\u003Cbr\u003E\n \u0026nbsp;# Child-SP\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; RetAddr\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Call Site\u003Cbr\u003E\n 00 000000ad`23f6f7c0 00007ffa`f047c5fb\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; windowscodecs!CFormatConverter::Initialize+0x1c8\u003Cbr\u003E\n 01 000000ad`23f6f890 00007ffa`f047c2f3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; windowscodecs!CFormatConverter::Initialize+0x12b\u003Cbr\u003E\n 02 000000ad`23f6f980 00007ff6`34ca6dff\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; windowscodecs!CFormatConverterResolver::Initialize+0x273\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\/\/\u003Cb\u003EUninitialized memory after allocation\u003C\/b\u003E:\u003Cbr\u003E\n 0:000\u0026gt; db @rax\u003Cbr\u003E\n 00000225`7a3dbf70\u0026nbsp; d0 b0 3d 7a 25 02 00 00-60 24 3d 7a 25 02 00 00\u0026nbsp; ..=z%...`$=z%...\u003Cbr\u003E\n 00000225`7a3dbf80\u0026nbsp; 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00\u0026nbsp; ................\u003Cbr\u003E\n 00000225`7a3dbf90\u0026nbsp; 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00\u0026nbsp; ................\u003Cbr\u003E\n 00000225`7a3dbfa0\u0026nbsp; 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 \u0026nbsp;................\u003Cbr\u003E\n 00000225`7a3dbfb0\u0026nbsp; 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00\u0026nbsp; ................\u003Cbr\u003E\n 00000225`7a3dbfc0\u0026nbsp; 00 00 00 00 00 00 00 00-64 51 7c 26 c3 2c 01 03\u0026nbsp; ........dQ|\u0026amp;.,..\u003Cbr\u003E\n 00000225`7a3dbfd0\u0026nbsp; f0 00 2f 6b 25 02 00 00-f0 00 2f 6b 25 02 00 00\u0026nbsp; ..\/k%.....\/k%...\u003Cbr\u003E\n 00000225`7a3dbfe0\u0026nbsp; 60 00 3d 7a 25 02 00 00-60 00 3d 7a 25 02 00 00\u0026nbsp; `.=z%...`.=z%...\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Allocation of memory\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe memory never gets written and the uninitialized values are inverted in \u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!CLibTiffDecoderBase::HrProcessCopy\u003C\/span\u003E and further processed in \u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!GammaConvert_16bppGrayInt_128bppRGBA\u003C\/span\u003E and in later called scaling functions.\u003C\/p\u003E\n\u003Cp\u003EAs there is no read or write into uninitialized memory before HrProcessCopy, I traced the execution back from HrProcessCopy and compared the execution traces with a normal tiff decoding trace. A difference was found in the way \u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!CLibTiffDecoderBase::UnpackLine\u003C\/span\u003E behaved with the PoC file compared to a normal TIFF file, and one of the function parameters in \u003Cspan class=\u0022code\u0022\u003EUnpackLine\u003C\/span\u003E was a pointer to the uninitialized buffer.\u003C\/p\u003E\n\u003Cp\u003EThe \u003Cspan class=\u0022code\u0022\u003EUnpackLine\u003C\/span\u003E function has a series of switch-case statements working with bits per sample (BPS) of TIFF images. In our PoC TIFF file, the BPS value is 0x09\u2014which is not supported by \u003Cspan class=\u0022code\u0022\u003EUnpackLine\u003C\/span\u003E\u2014and the control flow never reaches a code path that writes to the buffer. This is the root cause of the uninitialized memory, which gets processed further down the pipeline and finally shown as pixel data.\u003C\/p\u003E\n\u003Ch4\u003EPatch\u003C\/h4\u003E\n\u003Cp\u003EAfter presenting my analysis to Microsoft, they decided to patch the vulnerability by making the files with unsupported BPS values as invalid. This avoids all decoding and rejects the file in the very early phase of its loading.\u003C\/p\u003E\n\u003Ch4\u003ECVE-2020-1397\u003C\/h4\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/fuzzing-image2\/fig5.png\u0022 alt=\u0022\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Rendering of CVE-2020-1397\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EUnlike the previous vulnerability, the difference in the output is quite limited in this one, as seen in Figure 5. One of the simpler root cause analysis techniques that can be used to figure out a specific type of uninitialized memory usage is comparing execution traces of runs that produce two different outputs. This specific technique can be helpful when an uninitialized variable causes a control flow change in the program and that causes a difference in the outputs. For this, a binary instrumentation script was written, which logged all the instructions executed along with its registers and accessed memory values.\u003C\/p\u003E\n\u003Cp\u003EDiffing two distinct execution traces by comparing the instruction pointer (RIP) value, I found a control flow change in \u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!CCCITT::Expand2DLine\u003C\/span\u003E due to a usage of an uninitialized value. Back tracing the uninitialized value using TTD trace was exceptionally useful for finding the root cause. The following section shows the allocation, population and use of the uninitialized value, which leads to the control flow change and deviance in the pixel outputs.\u003C\/p\u003E\n\u003Ch4\u003EAllocation\u003C\/h4\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!TIFFReadBufferSetup\u003C\/span\u003E allocates 0x400 bytes of memory, as shown in Figure 6.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Ewindowscodecs!TIFFReadBufferSetup:\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; ...\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; allocBuff = malloc(size);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; *(v3 + 16) |= 0x200u;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; *(v3 + 480) = allocBuff;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; k\u003Cbr\u003E\n \u0026nbsp;# Child-SP\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; RetAddr\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Call Site\u003Cbr\u003E\n 00 000000aa`a654f128 00007ff9`4404d4f3 windowscodecs!TIFFReadBufferSetup\u003Cbr\u003E\n 01 000000aa`a654f130 00007ff9`4404d3c9 windowscodecs!TIFFFillStrip+0xab\u003Cbr\u003E\n 02 000000aa`a654f170 00007ff9`4404d2dc windowscodecs!TIFFReadEncodedStrip+0x91\u003Cbr\u003E\n 03 000000aa`a654f1b0 00007ff9`440396dd windowscodecs!CLibTiffDecoderBase::ReadStrip+0x74\u003Cbr\u003E\n 04 000000aa`a654f1e0 00007ff9`44115fca windowscodecs!CLibTiffDecoderBase::GetOneUnpackedLine+0x1ad\u003Cbr\u003E\n 05 000000aa`a654f2b0 00007ff9`44077400 windowscodecs!CLibTiffDecoderBase::HrProcessCopy+0x4a\u003Cbr\u003E\n 06 000000aa`a654f2f0 00007ff9`44048dbb windowscodecs!CLibTiffDecoderBase::HrReadScanline+0x20\u003Cbr\u003E\n 07 000000aa`a654f320 00007ff9`44048b40 windowscodecs!CDecoderBase::CopyPixels+0x23b\u003Cbr\u003E\n 08 000000aa`a654f3d0 00007ff9`44043c95 windowscodecs!CLibTiffDecoderBase::CopyPixels+0x80\u003Cbr\u003E\n 09 000000aa`a654f4d0 00007ff9`4404563b windowscodecs!CDecoderFrame::CopyPixels+0xb5\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003EAfter allocation:\u003Cbr\u003E\n 0:000\u0026gt; !heap -p -a @rax\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; address 0000029744382140 found in\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; _HEAP @ 29735190000\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; HEAP_ENTRY Size Prev Flags\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; UserPtr UserSize - state\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; 0000029744382130 0041 0000\u0026nbsp; [00]\u0026nbsp;\u0026nbsp; 0000029744382140\u0026nbsp;\u0026nbsp;\u0026nbsp; 00400 - (busy)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; unknown!noop\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\/\/\u003Cb\u003EUninitialized memory after allocation\u0026nbsp;\u003C\/b\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u003Cbr\u003E\n 0:000\u0026gt; db @rax\u003Cbr\u003E\n 00000297`44382140\u0026nbsp; 40 7c 5e 97 29 5d 5f ae-73 31 98 70 b8 4f da ac\u0026nbsp; @|^.)]_.s1.p.O..\u003Cbr\u003E\n 00000297`44382150\u0026nbsp; 06 51 54 18 2e 2a 23 3a-4f ab 14 27 e9 c6 2c 83\u0026nbsp; .QT..*#:O..\u0027..,.\u003Cbr\u003E\n 00000297`44382160\u0026nbsp; 3a 25 b2 f6 9d e7 3c 09-cc a5 8e 27 b0 73 41 a9\u0026nbsp; :%....\u0026lt;....\u0027.sA.\u003Cbr\u003E\n 00000297`44382170\u0026nbsp; fb 9b 02 b5 81 3e ea 45-4c 0f ab a7 72 e3 21 e7\u0026nbsp; .....\u0026gt;.EL...r.!.\u003Cbr\u003E\n 00000297`44382180\u0026nbsp; c8 44 84 3b c3 b5 44 8a-c9 6e 4b 2e 40 31 38 e0\u0026nbsp; .D.;..D..nK.@18.\u003Cbr\u003E\n 00000297`44382190\u0026nbsp; 85 f0 bd 98 3b 0b ca b8-78 b1 9d d0 dd 4d 61 66\u0026nbsp; ....;...x....Maf\u003Cbr\u003E\n 00000297`443821a0\u0026nbsp; 16 7d 0a e2 40 fa f8 45-4f 79 ab 95 d8 54 f9 44\u0026nbsp; .}..@..EOy...T.D\u003Cbr\u003E\n 00000297`443821b0\u0026nbsp; 66 26 28 00 b7 96 52 88-15 f0 ed 34 94 5f 6f 94\u0026nbsp; f\u0026amp;(...R....4._o.\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Allocation of memory\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EPartially Populating the Buffer\u003C\/h4\u003E\n\u003Cp\u003E0x10 bytes are copied from the input file to this allocated buffer by TIFFReadRawStrip1. The rest of the buffer remains uninitialized with random values, as shown in Figure 7.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003Eif ( !TIFFReadBufferSetup(v2, a2, stripCount) ) {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; return 0i64;\u003Cbr\u003E\n }\u003Cbr\u003E\n if ( TIFFReadRawStrip1(v2, v3, sizeToReadFromFile, \u0026quot;TIFFFillStrip\u0026quot;) != sizeToReadFromFile )\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; r\u003Cbr\u003E\n rax=0000000000000001 rbx=000002973519a7e0 rcx=000002973519a7e0\u003Cbr\u003E\n rdx=0000000000000000 rsi=0000000000000000 rdi=0000000000000010\u003Cbr\u003E\n rip=00007ff94404d58c rsp=000000aaa654f128 rbp=0000000000000000\u003Cbr\u003E\n \u0026nbsp;r8=0000000000000010\u0026nbsp; r9=00007ff94416fc38 r10=0000000000000000\u003Cbr\u003E\n r11=000000aaa654ef60 r12=0000000000000001 r13=0000000000000000\u003Cbr\u003E\n r14=0000029744377de0 r15=0000000000000001\u003Cbr\u003E\n iopl=0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; nv up ei pl nz na pe nc\u003Cbr\u003E\n cs=0033\u0026nbsp; ss=002b\u0026nbsp; ds=002b\u0026nbsp; es=002b\u0026nbsp; fs=0053 \u0026nbsp;gs=002b\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; efl=00000202\u003Cbr\u003E\n windowscodecs!TIFFReadRawStrip1:\u003Cbr\u003E\n 00007ff9`4404d58c 488bc4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; mov\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; rax,rsp\u003Cbr\u003E\n 0:000\u0026gt; k\u003Cbr\u003E\n \u0026nbsp;# Child-SP\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; RetAddr\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Call Site\u003Cbr\u003E\n 00 000000aa`a654f128 00007ff9`4404d491 windowscodecs!TIFFReadRawStrip1\u003Cbr\u003E\n 01 000000aa`a654f130 00007ff9`4404d3c9 windowscodecs!TIFFFillStrip+0x49\u003Cbr\u003E\n 02 000000aa`a654f170 00007ff9`4404d2dc windowscodecs!TIFFReadEncodedStrip+0x91\u003Cbr\u003E\n 03 000000aa`a654f1b0 00007ff9`440396dd windowscodecs!CLibTiffDecoderBase::ReadStrip+0x74\u003Cbr\u003E\n 04 000000aa`a654f1e0 00007ff9`44115fca windowscodecs!CLibTiffDecoderBase::GetOneUnpackedLine+0x1ad\u003Cbr\u003E\n 05 000000aa`a654f2b0 00007ff9`44077400 windowscodecs!CLibTiffDecoderBase::HrProcessCopy+0x4a\u003Cbr\u003E\n 06 000000aa`a654f2f0 00007ff9`44048dbb windowscodecs!CLibTiffDecoderBase::HrReadScanline+0x20\u003Cbr\u003E\n 07 000000aa`a654f320 00007ff9`44048b40 windowscodecs!CDecoderBase::CopyPixels+0x23b\u003Cbr\u003E\n 08 000000aa`a654f3d0 00007ff9`44043c95 windowscodecs!CLibTiffDecoderBase::CopyPixels+0x80\u003Cbr\u003E\n 09 000000aa`a654f4d0 00007ff9`4404563b windowscodecs!CDecoderFrame::CopyPixels+0xb5\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; db 00000297`44382140\u003Cbr\u003E\n 00000297`44382140\u0026nbsp; 5b cd 82 55 2a 94 e2 6f-d7 2d a5 93 58 23 00 6c\u0026nbsp; [..U*..o.-..X#.l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/\u0026nbsp;\u003Cb style=\u0022font-size: 12px;\u0022\u003E0x10 bytes from file\u003Cbr\u003E\n \u003C\/b\u003E00000297`44382150\u0026nbsp; 06 51 54 18 2e 2a 23 3a-4f ab 14 27 e9 c6 2c 83\u0026nbsp; .QT..*#:O..\u0027..,. \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ uninitialized memory\u003Cbr\u003E\n 00000297`44382160\u0026nbsp; 3a 25 b2 f6 9d e7 3c 09-cc a5 8e 27 b0 73 41 a9\u0026nbsp; :%....\u0026lt;....\u0027.sA.\u003Cbr\u003E\n 00000297`44382170\u0026nbsp; fb 9b 02 b5 81 3e ea 45-4c 0f ab a7 72 e3 21 e7\u0026nbsp; .....\u0026gt;.EL...r.!.\u003Cbr\u003E\n 00000297`44382180\u0026nbsp; c8 44 84 3b c3 b5 44 8a-c9 6e 4b 2e 40 31 38 e0\u0026nbsp; .D.;..D..nK.@18.\u003Cbr\u003E\n 00000297`44382190\u0026nbsp; 85 f0 bd 98 3b 0b ca b8-78 b1 9d d0 dd 4d 61 66\u0026nbsp; ....;...x....Maf\u003Cbr\u003E\n 00000297`443821a0\u0026nbsp; 16 7d 0a e2 40 fa f8 45-4f 79 ab 95 d8 54 f9 44\u0026nbsp; .}..@..EOy...T.D\u003Cbr\u003E\n 00000297`443821b0\u0026nbsp; 66 26 28 00 b7 96 52 88-15 f0 ed 34 94 5f 6f 94\u0026nbsp; f\u0026amp;(...R....4._o.\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Partial population of memory\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EUse of Uninitialized Memory\u003C\/h4\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; r\u003Cbr\u003E\n rax=0000000000000006 rbx=0000000000000007 rcx=0000000000000200\u003Cbr\u003E\n rdx=0000000000011803 rsi=0000029744382150 rdi=0000000000000000\u003Cbr\u003E\n rip=00007ff94414e837 rsp=000000aaa654f050 rbp=0000000000000001\u003Cbr\u003E\n \u0026nbsp;r8=0000029744382550\u0026nbsp; r9=0000000000000000 r10=0000000000000008\u003Cbr\u003E\n r11=0000000000000013 r12=00007ff94418b7b0 r13=0000000000000003\u003Cbr\u003E\n r14=0000000023006c00 r15=00007ff94418bbb0\u003Cbr\u003E\n iopl=0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; nv up ei pl nz na po nc\u003Cbr\u003E\n cs=0033\u0026nbsp; ss=002b\u0026nbsp; ds=002b\u0026nbsp; es=002b\u0026nbsp; fs=0053\u0026nbsp; gs=002b\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; efl=00000206\u003Cbr\u003E\n windowscodecs!CCCITT::Expand2DLine+0x253:\u003Cbr\u003E\n 00007ff9`4414e837 0fb606\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; movzx\u0026nbsp;\u0026nbsp; eax,byte ptr [rsi] ds:00000297`44382150=06\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ;\u0026nbsp;\u003Cb style=\u0022font-size: 12px;\u0022\u003EUninitialized memory being accessed\u003C\/b\u003E\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; db 00000297`44382140\u003Cbr\u003E\n 00000297`44382140\u0026nbsp; 5b cd 82 55 2a 94 e2 6f-d7 2d a5 93 58 23 00 6c\u0026nbsp; [..U*..o.-..X#.l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/\u0026nbsp;\u003Cb style=\u0022font-size: 12px;\u0022\u003E0x10 bytes from file\u003Cbr\u003E\n \u003C\/b\u003E00000297`44382150\u0026nbsp; 06 51 54 18 2e 2a 23 3a-4f ab 14 27 e9 c6 2c 83\u0026nbsp; .QT..*#:O..\u0027..,.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ uninitialized memory\u003Cbr\u003E\n 00000297`44382160\u0026nbsp; 3a 25 b2 f6 9d e7 3c 09-cc a5 8e 27 b0 73 41 a9\u0026nbsp; :%....\u0026lt;....\u0027.sA.\u003Cbr\u003E\n 00000297`44382170\u0026nbsp; fb 9b 02 b5 81 3e ea 45-4c 0f ab a7 72 e3 21 e7\u0026nbsp; .....\u0026gt;.EL...r.!.\u003Cbr\u003E\n 00000297`44382180\u0026nbsp; c8 44 84 3b c3 b5 44 8a-c9 6e 4b 2e 40 31 38 e0\u0026nbsp; .D.;..D..nK.@18.\u003Cbr\u003E\n 00000297`44382190\u0026nbsp; 85 f0 bd 98 3b 0b ca b8-78 b1 9d d0 dd 4d 61 66\u0026nbsp; ....;...x....Maf\u003Cbr\u003E\n 00000297`443821a0\u0026nbsp; 16 7d 0a e2 40 fa f8 45-4f 79 ab 95 d8 54 f9 44\u0026nbsp; .}..@..EOy...T.D\u003Cbr\u003E\n 00000297`443821b0\u0026nbsp; 66 26 28 00 b7 96 52 88-15 f0 ed 34 94 5f 6f 94\u0026nbsp; f\u0026amp;(...R....4._o.\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp;\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003E0:000\u0026gt; k\u003Cbr\u003E\n \u0026nbsp;# Child-SP\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; RetAddr\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Call Site\u003Cbr\u003E\n 00 000000aa`a654f050 00007ff9`4414df80 windowscodecs!CCCITT::Expand2DLine+0x253\u003Cbr\u003E\n 01 000000aa`a654f0d0 00007ff9`4412afcc windowscodecs!CCCITT::CCITT_Expand+0xac\u003Cbr\u003E\n 02 000000aa`a654f120 00007ff9`4404d3f0 windowscodecs!CCITTDecode+0x7c\u003Cbr\u003E\n 03 000000aa`a654f170 00007ff9`4404d2dc windowscodecs!TIFFReadEncodedStrip+0xb8\u003Cbr\u003E\n 04 000000aa`a654f1b0 00007ff9`440396dd windowscodecs!CLibTiffDecoderBase::ReadStrip+0x74\u003Cbr\u003E\n 05 000000aa`a654f1e0 00007ff9`44115fca windowscodecs!CLibTiffDecoderBase::GetOneUnpackedLine+0x1ad\u003Cbr\u003E\n 06 000000aa`a654f2b0 00007ff9`44077400 windowscodecs!CLibTiffDecoderBase::HrProcessCopy+0x4a\u003Cbr\u003E\n 07 000000aa`a654f2f0 00007ff9`44048dbb windowscodecs!CLibTiffDecoderBase::HrReadScanline+0x20\u003Cbr\u003E\n 08 000000aa`a654f320 00007ff9`44048b40 windowscodecs!CDecoderBase::CopyPixels+0x23b\u003Cbr\u003E\n 09 000000aa`a654f3d0 00007ff9`44043c95 windowscodecs!CLibTiffDecoderBase::CopyPixels+0x80\u003Cbr\u003E\n 0a 000000aa`a654f4d0 00007ff9`4404563b windowscodecs!CDecoderFrame::CopyPixels+0xb5\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Reading of uninitialized value\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EDepending on the uninitialized value (Figure 8), different code paths are taken in Expand2DLine, which will change the output pixels, as shown in Figure 9.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cspan class=\u0022code\u0022\u003E\u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; if ( v11 != 1 || a2 )\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; unintValue = *++allocBuffer | (unintValue \u0026lt;\u0026lt; 8);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ uninit mem read\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; else\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; {\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; unintValue \u0026lt;\u0026lt;= 8;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; ++allocBuffer;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; --v11;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; v16 += 8;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; v29 = unintValue \u0026gt;\u0026gt; (v16 - 8);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; dependentUninitValue = *(l + 2i64 * v29);\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; v16 -= *(l + 2i64 * v29 + 1);\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; if ( dependentUninitValue \u0026gt;= 0 )\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ path 1\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; break;\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; if ( dependentUninitValue \u0026lt; \u0027\\xC0\u0027 )\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; return 0xFFFFFFFFi64;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ path 2\u003Cbr\u003E\n \u0026nbsp; }\u003Cbr\u003E\n \u0026nbsp; if ( dependentUninitValue \u0026lt;= 0x3F )\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \/\/ path xx\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp; break;\u003C\/span\u003E\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Use of uninitialized memory in \u003Ci style=\u0022font-size: 12px;\u0022\u003Eif\u003C\/i\u003E conditions\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EPatch\u003C\/h4\u003E\n\u003Cp\u003EMicrosoft decided to patch this vulnerability by using \u003Cspan class=\u0022code\u0022\u003Ecalloc\u003C\/span\u003E instead of \u003Cspan class=\u0022code\u0022\u003Emalloc\u003C\/span\u003E, which initializes the allocated memory with zeros.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EPart Two of this blog series presents multiple vulnerabilities in Windows\u2019 built-in image parsers. In the next post, we will explore newer supported image formats in Windows such as RAW, HEIF and more.\u003C\/p\u003E\n",
        "jcr:lastModified": "Wed Mar 03 2021 19:26:00 GMT+0000",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003EIn this post we look at Windows\u2019 inbuilt image parsers\u2014specifically for vulnerabilities involving the use of uninitialized memory.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Mar 03 2021 18:08:22 GMT+0000",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed Mar 03 2021 19:29:58 GMT+0000",
      "imageRotate": "0"
    }
  }
}
