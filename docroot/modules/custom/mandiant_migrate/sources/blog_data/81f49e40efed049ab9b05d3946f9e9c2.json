{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Tue Jan 08 2019 10:55:06 GMT-0500",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Digging Up the Past: Windows Registry Forensics Revisited",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "74e02ff7-0fdd-43aa-a4be-445e18238428",
    "author": "David Via",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "15843b91-88ad-4313-97ef-1c9da31b18c4"
    ],
    "jcr:created": "Tue Jan 08 2019 14:36:34 GMT-0500",
    "cq:lastReplicated": "Tue Jan 08 2019 14:36:32 GMT-0500",
    "cq:lastModified": "Tue Jan 08 2019 14:36:08 GMT-0500",
    "jcr:baseVersion": "15843b91-88ad-4313-97ef-1c9da31b18c4",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:david-via",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:forensics",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:registry"
    ],
    "jcr:uuid": "376538ab-768e-43c4-a3ae-403633cd3ccc",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Jan 08 2019 11:00:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Ch4\u003EIntroduction\u003C\/h4\u003E\n\u003Cp\u003EFireEye consultants frequently utilize Windows registry data when performing forensic analysis of computer networks as part of incident response and compromise assessment missions. This can be useful to discover malicious activity and to determine what data may have been stolen from a network. Many different types of data are present in the registry that can provide evidence of program execution, application settings, malware persistence, and other valuable artifacts.\u003C\/p\u003E\n\u003Cp\u003EPerforming forensic analysis of past attacks can be particularly challenging. Advanced persistent threat actors will frequently utilize anti-forensic techniques to hide their tracks and make the jobs of incident responders more difficult. To provide our consultants with the best possible tools we revisited our existing registry forensic techniques and identified new ways to recover historical and deleted registry data. Our analysis focused on the following known sources of historical registry data:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003ERegistry transaction logs (.LOG)\u003C\/li\u003E\n\u003Cli\u003ETransactional registry transaction logs (.TxR)\u003C\/li\u003E\n\u003Cli\u003EDeleted entries in registry hives\u003C\/li\u003E\n\u003Cli\u003EBackup system hives (REGBACK)\u003C\/li\u003E\n\u003Cli\u003EHives backed up with System Restore\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Ch4\u003EWindows Registry Format\u003C\/h4\u003E\n\u003Cp\u003EThe Windows registry is stored in a collection of hive files. Hives are binary files containing a simple filesystem with a set of cells used to store keys, values, data, and related metadata. Registry hives are read and written in 4KB pages (also called bins).\u003C\/p\u003E\n\u003Cp\u003EFor a detailed description of the Windows registry hive format, see this \u003Ca adhocenable=\u0022false\u0022 href=\u0022http:\/\/sentinelchicken.com\/data\/TheWindowsNTRegistryFileFormat.pdf\u0022\u003Eresearch paper\u003C\/a\u003E and this \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/msuhanov\/regf\/blob\/master\/Windows%20registry%20file%20format%20specification.md\u0022\u003EGitHub page\u003C\/a\u003E.\u003C\/p\u003E\n\u003Ch4\u003ERegistry Transaction Logs (.LOG)\u003C\/h4\u003E\n\u003Cp\u003ETo maximize registry reliability, Windows can use transaction logs when performing writes to registry files. The logs act as journals that store data being written to the registry before it is written to hive files. Transaction logs are used when registry hives cannot directly be written due to locking or corruption.\u003C\/p\u003E\n\u003Cp\u003ETransaction logs are written to files in the same directory as their corresponding registry hives. They use the same filename as the hive with a \u003Cspan class=\u0022code\u0022\u003E.LOG\u003C\/span\u003E extension. Windows may use multiple logs in which case \u003Cspan class=\u0022code\u0022\u003E.LOG1\u003C\/span\u003E and \u003Cspan class=\u0022code\u0022\u003E.LOG2\u003C\/span\u003E extensions will be used.\u003C\/p\u003E\n\u003Cp\u003EFor more details about the transaction log format, see this \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/msuhanov\/regf\/blob\/master\/Windows%20registry%20file%20format%20specification.md#format-of-transaction-log-files\u0022\u003EGitHub page\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003ERegistry transaction logs were first introduced in Windows 2000. In the original transaction log format data is always written at the start of the transaction log. A bitmap is used to indicate what pages are present in the log, and pages follow in order. Because the start of the file is frequently overwritten, it is very difficult to recover old data from these logs. Since different amounts of data will be written to the transaction log on each use, it is possible for old pages to remain in the file across multiple uses. However, the location of each page will have to be inferred by searching for similar pages in the current hive, and the probability of consistent data recovery is very small.\u003C\/p\u003E\n\u003Cp\u003EA new registry transaction log format was introduced with Windows 8.1. Although the new logs are used in the same fashion, they have a different format. The new logs work like a ring buffer where the oldest data in the log is overwritten by new data. Each entry in the new log format includes a sequence number as well as registry offset making it easy to determine the order of writes and where the pages were written. Because of the changed log format, data is overwritten much less frequently, and old transactions can often be recovered from these log files.\u003C\/p\u003E\n\u003Cp\u003EThe amount of data that can be recovered depends on registry activity. A sampling of transaction logs from real world systems showed a range of recoverable data from a few days to a few weeks. Real world recoverability can vary considerably. Registry-heavy operations, such as Windows Update, can significantly reduce the recoverable range.\u003C\/p\u003E\n\u003Cp\u003EAlthough the new log format contains more recoverable information, turning a set of registry pages into useful data is quite tricky. First, it requires keeping track of all pages in the registry and determining what might have changed in a particular write. It also requires determining if that change resulted in something that is not present in later revisions of the hive to assess whether or not it contains unique data.\u003C\/p\u003E\n\u003Cp\u003EOur current approach for processing registry transaction files uses the following algorithm:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003ESort all writes by sequence number descending so that we process the most recent writes first.\u003C\/li\u003E\n\u003Cli\u003EPerform allocated and unallocated cell parsing to find allocated and deleted entries.\u003C\/li\u003E\n\u003Cli\u003ECompare entries against the original hive. Any entries that are not present are marked as deleted and logged.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch4\u003ETransaction Log Example\u003C\/h4\u003E\n\u003Cp\u003EIn this example we create a registry value under the Run key that starts malware.exe when the user logs in to the system.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: A malicious actor creates a value in the Run key\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAt a later point in time the malware is removed from the system. The registry value is overwritten before being deleted.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: The malicious value is overwritten and deleted\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EAlthough the deleted value still exists in the hive, existing forensic tools will not be able to recover the original data because it was overwritten.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: The overwritten value is present in the registry hive\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EHowever, in this case the data is still present in the transaction log and can be recovered.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: The transaction log contains the original value\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ETransactional Registry Transaction Logs (.TxR)\u003C\/h4\u003E\n\u003Cp\u003EIn addition to the transaction log journal there are also logs used by the transactional registry subsystem. Applications can utilize the transactional registry to perform compound registry operations atomically. This is most commonly used by application installers as it simplifies failed operation rollback.\u003C\/p\u003E\n\u003Cp\u003ETransactional registry logs use the Common Log File Sytstem (CLFS) format. The logs are stored to files of the form \u003Cspan class=\u0022code\u0022\u003E\u0026lt;hive\u0026gt;\u0026lt;GUID\u0026gt;.TxR.\u0026lt;number\u0026gt;.regtrans-ms\u003C\/span\u003E. For user hives these files are stored in the same directory as the hive and are cleared on user logout. However, for system hives logs are stored in \u003Cspan class=\u0022code\u0022\u003E%SystemRoot%\\System32\\config\\TxR\u003C\/span\u003E, and the logs are not automatically cleared. As a result, it is typically possible to recover historical data from system transactional logs.\u003C\/p\u003E\n\u003Cp\u003EThe format of transactional logs is not well understood or documented. Microsoft has provided a \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/docs.microsoft.com\/en-us\/windows-hardware\/drivers\/kernel\/introduction-to-the-common-log-file-system\u0022\u003Egeneral overview of CLFS logs and API\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EWith some experimentation we were able to determine the basic record format. We can identify records for registry key creation and deletion as well as registry value writes and deletes. The relevant key path, value name, data type, and data are present within log entries. See the appendix for transaction log record format details.\u003C\/p\u003E\n\u003Cp\u003EAlthough most data present in registry transaction logs is not particularly valuable for intrusion investigations, there are some cases where the data can prove useful. In particular, we found that scheduled task creation and deletion use registry transactions. By parsing registry transaction logs we were able to find evidence of attacker created scheduled tasks on live systems. This data was not available in any other location.\u003C\/p\u003E\n\u003Cp\u003EThe task scheduler has been observed using transactional registry operations on Windows Vista through Windows 8.1; the task scheduler on Windows 10 does not exhibit this behavior. It is not known why Windows 10 behaves differently.\u003C\/p\u003E\n\u003Ch4\u003ETransactional Registry Example\u003C\/h4\u003E\n\u003Cp\u003EIn this example we create a scheduled task. The scheduled task periodically runs malware.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Creating a scheduled task to run malware\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EInformation about the scheduled task is stored to the registry.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: A registry entry created by the task scheduler\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBecause the scheduled task was written to the registry using transacted registry operations, a copy of the data is available in the transactional registry transaction log. The data can remain in the log well after the scheduled task has been removed from the system.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: The malicious scheduled task in the TxR log\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003EDeleted Entry Recovery\u003C\/h4\u003E\n\u003Cp\u003EIn addition to transaction logs, we also examined methods for the recovery of deleted entries from registry hive files. We started with an in-depth analysis of some common techniques used by forensic tools today in the hopes of identifying a more accurate approach.\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003EDeleted entry recovery requires parsing registry cells in hive files. This is relatively straightforward. FireEye has a number of tools that can read raw registry hive files and parse relevant keys, values, and data from cells. Recovering deleted data is more complex because some information is lost when elements are deleted. A more sophisticated approach is required to deal with the resulting ambiguity.\u003C\/p\u003E\n\u003Cp\u003EWhen parsing cells there is only one common field: the cell size. Some cell types contain magic number identifiers, which can help determine their type. However, other cell types, such as data and value lists, do not have identifiers; their types must be inferred by following references from other cells. Additionally, the size of data within a cell can differ from the cell size. Depending on the cell type it may be necessary to leverage information from referencing cells to determine the data size.\u003C\/p\u003E\n\u003Cp\u003EWhen a registry element is deleted its cells are marked as unallocated. Because the cells are not immediately overwritten, deleted elements can often be recovered from registry hives. However, unallocated cells may be coalesced with adjacent unallocated cells to maximize traversal efficiency. This makes deleted cell recovery more complex because cell sizes may be modified. As a result, original cell boundaries are not well defined and must be determined implicitly by examining cell contents.\u003C\/p\u003E\n\u003Ch4\u003EExisting Approaches for Recovering Deleted Entries\u003C\/h4\u003E\n\u003Cp\u003EA review of public literature and source code revealed existing methods for recovery of deleted elements from registry hive files. Variations of the following algorithm were commonly found:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003ESearch through all unallocated cells looking for deleted key cells.\u003C\/li\u003E\n\u003Cli\u003EFind referenced deleted values from deleted keys.\u003C\/li\u003E\n\u003Cli\u003ESearch through all remaining unallocated cells looking for unreferenced deleted value cells.\u003C\/li\u003E\n\u003Cli\u003EFind referenced data cells from all deleted values.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Cp\u003EWe implemented a similar algorithm to experiment with its efficacy. Although this simple algorithm was able to recover many deleted registry elements, it had a number of significant shortcomings. One major issue was the inability to validate any references from deleted cells. Because referenced cells may have already been overwritten or reused multiple times, our program frequently made mistakes in identifying values and data resulting in false positives and invalid output.\u003C\/p\u003E\n\u003Cp\u003EWe also compared program output to popular registry forensic tools. Although our program produced much of the same output, it was evident that existing registry forensic tools were able to recover more data. In particular, existing tools were able to recover deleted elements from slack space of allocated cells that had not yet been overwritten.\u003C\/p\u003E\n\u003Cp\u003EAdditionally, we found that orphaned allocated cells are also considered deleted. It is not known how unreferenced allocated cells could exist in a registry hive as all related cells should be unallocated simultaneously on deletion. It is possible that certain types of failures could result in deleted cells not becoming unallocated properly.\u003C\/p\u003E\n\u003Cp\u003EThrough experimentation we discovered that existing registry tools were able to perform better validation resulting in fewer false positives. However, we also identified many cases where existing tools made incorrect deleted value associations and output invalid data. This likely occurs when cells are reused multiple times resulting in references that could appear valid if not carefully scrutinized.\u003C\/p\u003E\n\u003Ch4\u003EA New Approach for Recovering Deleted Entries\u003C\/h4\u003E\n\u003Cp\u003EGiven the potential for improving our algorithm, we undertook a major redesign to recover deleted registry elements with maximum accuracy and efficiency. After many rounds of experimentation and refinement we ended up with a new algorithm that can accurately recover deleted registry elements while maximizing performance. This was achieved by discovering and keeping track of all cells in registry hives to perform better validation, by processing cell slack space, and by discovering orphaned keys and values. Testing results closely matched existing registry forensics tools but with better validation and fewer false positives.\u003C\/p\u003E\n\u003Cp\u003EThe following is a summary of the improved algorithm:\u003C\/p\u003E\n\u003Col\u003E\n\u003Cli\u003EPerform basic parsing for all allocated and unallocated cells. Determine cell type and data size where possible.\u003C\/li\u003E\n\u003Cli\u003EEnumerate all allocated cells and do the following:\u003Cul\u003E\n\u003Cli\u003EFor allocated keys find referenced value lists, class names, and security records. Populate data size of referenced cells. Validate key ancestors to determine if the key has been orphaned.\u003C\/li\u003E\n\u003Cli\u003EFor allocated values find referenced data and populate data size.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003C\/li\u003E\n\u003Cli\u003EDefine all allocated cell slack space as unallocated cells.\u003C\/li\u003E\n\u003Cli\u003EEnumerate allocated keys and attempt to find deleted values present in the values list. Also attempt to find old deleted value references in the value list slack space.\u003C\/li\u003E\n\u003Cli\u003EEnumerate unallocated cells and attempt to find deleted key cells.\u003C\/li\u003E\n\u003Cli\u003EEnumerate unallocated keys and attempt to define referenced class names, security records, and values.\u003C\/li\u003E\n\u003Cli\u003EEnumerate unallocated cells and attempt to find unreferenced deleted value cells.\u003C\/li\u003E\n\u003Cli\u003EEnumerate unallocated values and attempt to find referenced data cells.\u003C\/li\u003E\n\u003C\/ol\u003E\n\u003Ch4\u003EDeleted Recovery Example\u003C\/h4\u003E\n\u003Cp\u003EThe following example demonstrates how our deleted entry recovery algorithm can perform more accurate data recovery and avoid false positives. Figure 8 shows an example of a data recovery error by a popular registry forensics tool:\u003Cb\u003E\u003C\/b\u003E\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/WindowRegistry\/Fig8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Incorrectly recovered registry data\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ENote that the ProviderName recovered from this key was jumbled because it referred to a location that had been overwritten. When our deleted registry recovery tool is run over the same hive, it recognizes that the data has been overwritten and does not output garbled text. The \u003Cspan class=\u0022code\u0022\u003Edata_present\u003C\/span\u003E field in Figure 9 with a value of 0 indicates that the deleted data could not be recovered from the hive.\u003C\/p\u003E\n\u003Ctable cellpadding=\u00221\u0022 cellspacing=\u00220\u0022 border=\u00221\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\u003Cp\u003E\u003Cspan class=\u0022code\u0022\u003EKey: CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}\\\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;ControlSet002\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\0019\u003Cbr\u003E\n Value: ProviderName\u0026nbsp; Type: REG_SZ\u0026nbsp; (value_offset=0x137FE40) (data_size=20)\u003Cbr\u003E\n \u0026nbsp; \u0026nbsp; \u0026nbsp;(\u003Cb\u003Edata_present=0\u003C\/b\u003E) (data_offset=0x10EAF68) (deleted_type=UNALLOCATED)\u003C\/span\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: Properly validated registry data\u003C\/span\u003E\u003C\/p\u003E\n\u003Ch4\u003ERegistry Backups\u003C\/h4\u003E\n\u003Cp\u003EWindows includes a simple mechanism to backup system registry hives periodically. The hives are backed up with a scheduled task called RegIdleBackup, which is scheduled to run every 10 days by default. Backed up hives are stored to \u003Cspan class=\u0022code\u0022\u003E%SystemRoot%\\System32\\config\\RegBack\u003C\/span\u003E. Only the most recent backup is stored in this location. This can be useful for investigating recent activity on a system.\u003C\/p\u003E\n\u003Cp\u003EThe RegIdleBackup feature was first included with Windows Vista. It is present in all versions of Windows since then, but it does not run by default on Windows 10 systems, and even when it is manually run no backups are created. It is not known why RegIdleBackup was removed from Windows 10.\u003C\/p\u003E\n\u003Cp\u003EIn addition to RegBack, registry data is backed up with System Restore. By default, System Restore snapshots are created whenever software is installed or uninstalled, including Windows Updates. As a result, System Restore snapshots are usually created on at least a monthly basis if not more frequently. Although some advanced persistent threat groups have been known to manipulate System Restore snapshots, evidence of historical attacker activity can usually be found if a snapshot was taken at a time when the attacker was active. System Restore snapshots contain all registry hives including system and user hives.\u003C\/p\u003E\n\u003Cp\u003EWikipedia has some good information about \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/en.wikipedia.org\/wiki\/System_Restore\u0022\u003ESystem Restore\u003C\/a\u003E.\u003C\/p\u003E\n\u003Cp\u003EProcessing hives in System Restore snapshots can be challenging as there may be many snapshots present on a system resulting in a large amount of data to be processed, and often there will only be minor changes in hives between snapshots. One strategy to handle the large number of snapshots is to build a structure representing the cells of the registry hive, then repeat the process for each snapshot. Anything not in the previous structure can be considered deleted and logged appropriately.\u003C\/p\u003E\n\u003Ch4\u003EConclusion\u003C\/h4\u003E\n\u003Cp\u003EThe registry can provide a wealth of data for a forensic investigator. With numerous sources of deleted and historical data, a more complete picture of attacker activity can be assembled during an investigation. As attackers continue to gain sophistication and improve their tradecraft, investigators will have to adapt to discover and defend against them.\u003C\/p\u003E\n\u003Ch4\u003EAppendix - Transactional Registry Transaction Log (.TxR) Record Format\u003C\/h4\u003E\n\u003Cp\u003ERegistry transaction logs contain records with the following format:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 width=\u0022336\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EOffset\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EField\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ESize\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E0\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EMagic number (0x280000)\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E...\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E12\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ERecord size\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E16\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ERecord type (1)\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E20\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003ERegistry operation type\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E...\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E40\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EKey path size\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E42\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022192\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EKey path size repeated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002267\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EThe magic number is always 0x280000.\u003Cbr\u003E\nThe record size includes the header.\u003Cbr\u003E\nThe record type is always 1.\u003C\/p\u003E\n\u003Cp\u003EOperation type 1 is key creation.\u003Cbr\u003E\nOperation type 2 is key deletion.\u003Cbr\u003E\nOperation types 3-8 are value write or delete. It is not known what the different types signify.\u003C\/p\u003E\n\u003Cp\u003EThe key path size is at offset 40 and repeated at offset 42. This is present for all registry operation types.\u003C\/p\u003E\n\u003Cp\u003EFor registry key write and delete operations, the key path is at offset 72.\u003C\/p\u003E\n\u003Cp\u003EFor registry value write and delete operations, the following data is present:\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022 width=\u0022336\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EOffset\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003EField\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u003Cb\u003ESize\u003C\/b\u003E\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E56\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EValue name size\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E58\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EValue name size repeated\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E2\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E...\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E\u0026nbsp;\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E72\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EData type\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd width=\u002277\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E76\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u0022196\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003EData size\u003C\/p\u003E\n\u003C\/td\u003E\n\u003Ctd width=\u002263\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003E4\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003EThe data for value records starts at offset 88. It contains the key path followed by the value name optionally followed by data. If data size is nonzero, the record is a value write operation; otherwise it is a value delete operation.\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue Jan 08 2019 14:36:08 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003ELearn about using\u0026nbsp;Windows registry data when performing forensic analysis of computer networks.\u003C\/p\u003E\n",
      "jcr:lastModified": "Mon Jan 07 2019 15:31:57 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Tue Jan 08 2019 10:54:17 GMT-0500",
      "imageRotate": "0"
    }
  }
}
