{
  "jcr:primaryType": "cq:Page",
  "jcr:createdBy": "admin",
  "jcr:created": "Tue Nov 20 2018 12:25:18 GMT-0500",
  "jcr:content": {
    "jcr:primaryType": "cq:PageContent",
    "jcr:mixinTypes": [
      "mix:versionable"
    ],
    "jcr:createdBy": "admin",
    "jcr:title": "Cmd and Conquer: De-DOSfuscation with flare-qdb",
    "cq:lastReplicationAction": "Activate",
    "jcr:versionHistory": "2ca0a627-75fa-495f-a82d-17dd752bff74",
    "author": "Michael Bailey",
    "cq:template": "\/apps\/fireeye-blog\/templates\/page_blogpost",
    "cq:lastReplicatedBy": "adam.greenberg@fireeye.com",
    "jcr:language": "en_us",
    "jcr:predecessors": [
      "9248bec7-6ee4-40d4-89a5-cf01620b8bea"
    ],
    "jcr:created": "Wed May 08 2019 18:25:44 GMT-0400",
    "cq:lastReplicated": "Wed May 08 2019 18:25:43 GMT-0400",
    "cq:lastModified": "Wed May 08 2019 18:25:32 GMT-0400",
    "jcr:baseVersion": "9248bec7-6ee4-40d4-89a5-cf01620b8bea",
    "jcr:isCheckedOut": true,
    "cq:tags": [
      "fireeye-blog-authors:michael-bailey",
      "fireeye-blog-threat-research:threat-research",
      "fireeye-blog-tags:homepage-carousel",
      "fireeye-blog-tags:latest",
      "fireeye-blog-tags:debugger",
      "fireeye-blog-tags:scripting",
      "fireeye-blog-tags:FLARE"
    ],
    "jcr:uuid": "d4ef80bc-2671-46a8-ba11-c4a73c1306ed",
    "sling:resourceType": "social\/blog\/components\/page",
    "published": "Tue Nov 20 2018 12:30:00 GMT-0500",
    "cq:lastModifiedBy": "adam.greenberg@fireeye.com",
    "par": {
      "jcr:primaryType": "nt:unstructured",
      "sling:resourceType": "foundation\/components\/parsys",
      "entry": {
        "jcr:primaryType": "nt:unstructured",
        "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
        "text": "\u003Cp\u003EWhen \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research.html\/category\/etc\/tags\/fireeye-blog-authors\/daniel-bohannon\u0022\u003EDaniel Bohannon\u003C\/a\u003E released his excellent \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2018\/03\/dosfuscation-exploring-obfuscation-and-detection-techniques.html\u0022\u003EDOSfuscation\u003C\/a\u003E paper, I was fascinated to see how tricks I used as a systems engineer could help attackers evade detection. I didn\u2019t have much to contribute to this conversation until I had to analyze a hideously obfuscated batch file as part of my job on the FLARE malware queue.\u003C\/p\u003E\n\u003Cp\u003EPreviously, I released \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-qdb\u0022\u003Eflare-qdb\u003C\/a\u003E, which is a command-line and Python-scriptable debugger based on Vivisect. I previously \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research\/2017\/01\/flare_script_series.html\u0022\u003Ewrote\u003C\/a\u003E about how to use flare-qdb to instrument and modify malware behavior. Flare-qdb also made a guest appearance in \u003Ca href=\u0022https:\/\/www.fireeye.com\/blog\/threat-research.html\/category\/etc\/tags\/fireeye-blog-authors\/austin-baker\u0022\u003EAustin Baker\u003C\/a\u003E and Jacob Christie\u2019s \u003Ca href=\u0022https:\/\/www.sans.org\/summit-archives\/file\/summit-archive-1498249764.pdf\u0022\u003ESANS DFIR Summit 2017 briefing\u003C\/a\u003E, inducing the Windows event log service to exclude process creation events. In this blog post, I will show how I used flare-qdb to bring \u201cscript block logging\u201d to the Windows command interpreter. I will also share an Easter Egg that I found by flipping only a single bit in the process address space of cmd.exe. Finally, I will share the \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-qdb\/blob\/master\/flareqdb\/scripts\/deDOSfuscator.py\u0022\u003Escript that I added to flare-qdb\u003C\/a\u003E so you can de-obfuscate malicious command scripts yourself by executing them (in a safe environment, of course). But first, I\u2019ll talk about the analysis that led me to this solution.\u003C\/p\u003E\n\u003Ch4\u003EAt First Glance\u003C\/h4\u003E\n\u003Cp\u003EFigure 1 shows a batch script (MD5 hash 6C8129086ECB5CF2874DA7E0C855F2F6) that has been obfuscated using the BatchEncryption tool referenced in Daniel Bohannon\u2019s paper. This file does not appear in VirusTotal as of this writing, but its dropper does (the MD5 hash is ABD0A49FDA67547639EEACED7955A01A). My goal was to de-obfuscate this script and report on what the attacker was doing.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture1.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 1: Contents of XYNT.bat\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis 165k batch file is dropped as C:\\Windows\\Temp\\XYNT.bat and executed by its dropper. Its commands are built from environment variable substrings. Figure 2 shows how to use the ECHO command to decode the first command.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture2.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 2: Partial command decoding via the ECHO command\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThe script uses hundreds of commands to set environment variables that are ultimately expanded to de-obfuscate malicious commands. A tedious approach to de-obfuscating this script would be to de-fang each command by prepending an ECHO statement to print each de-obfuscated command to the console. Unfortunately, although the ECHO command can \u201cdecode\u201d each command, BatchEncryption needs the SET commands to be executed to decode future commands. To decode this script while allowing the full malicious functionality to run as expected, you would have to iteratively and carefully echo and selectively execute a few hundred obfuscated SET commands.\u003C\/p\u003E\n\u003Cp\u003EThe irony of BatchEncryption is that batch scripts are viewed as being easy to de-obfuscate, making binary code the safer place to hide logic from the prying eyes of network defenders. But BatchEncryption adds a formidable barrier to analysis by its extensive, layered use of environment variables to rebuild the original commands.\u003C\/p\u003E\n\u003Ch4\u003ETaking Cmd of the Situation\u003C\/h4\u003E\n\u003Cp\u003EI decided to see if it would be easier to instrument cmd.exe to log commands rather than de-obfuscating the script myself. To begin, I debugged cmd.exe, set a breakpoint on CreateProcessW, and executed a program from the command prompt. Figure 3 shows the call stack for CreateProcessW as cmd.exe executes notepad.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture3.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 3: Call stack for CreateProcessW in cmd.exe\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EStarting from cmd!ExecPgm, I reviewed the disassembly of the above functions in cmd.exe to trace the origin of the command string up the call stack. I discovered cmd!Dispatch, which receives not a string but a structure with pointers to the command, arguments, and any I\/O redirection information (such as \u003Ca href=\u0022https:\/\/support.microsoft.com\/en-us\/help\/110930\/redirecting-error-messages-from-command-prompt-stderr-stdout\u0022\u003Eredirecting the standard output or error\u003C\/a\u003E streams of a program to a file or device). Testing revealed that these strings had all their environment variables expanded, which means we should be able to read the de-obfuscated commands from here.\u003C\/p\u003E\n\u003Cp\u003EFigure 4 is an exploration of this structure in WinDbg after running the command \u0026quot;echo hai \u0026gt; nul\u0026quot;. This command prints the word hai to the standard output stream but uses the right-angle bracket to redirect standard output to the NUL device, which discards all data. The orange boxes highlight non-null pointers that got my attention during analysis, and the arrows point to the commands I used to discover their contents.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture4.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 4: Exploring the interesting pointers in 2nd argument to cmd!Dispatch\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBecause users can redirect multiple I\/O streams in a single command, cmd.exe represents I\/O redirection with a linked list. For example, the command in Listing 1 shows redirection of standard output (stream #1 is implicit) to shares.txt and standard error (stream #2 is explicitly referenced) to errors.txt.\u003C\/p\u003E\n\u003Ctable border=\u00221\u0022 cellspacing=\u00220\u0022 cellpadding=\u00220\u0022\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd width=\u0022671\u0022 valign=\u0022top\u0022\u003E\u003Cp\u003Enet use \u0026gt; shares.txt 2\u0026gt;errors.txt\u003C\/p\u003E\n\u003C\/td\u003E\n\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\n\u003Cp\u003E\u003Cspan class=\u0022type-XS\u0022\u003EListing 1: Command-line I\/O redirection example\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EFigure 5 shows the command data structure and the I\/O redirection linked list in block diagram format.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture5.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 5: Command data structure diagram\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EBy inspection, I found that cmd!Dispatch is responsible for executing both shell built-ins and executable programs, so unlike breaking on CreateProcess, it will not miss commands that do not result in process creation. Based on these findings, I wrote a flare-qdb script to parse and dump commands as they are executed.\u003C\/p\u003E\n\u003Ch4\u003EIntroducing De-DOSfuscator\u003C\/h4\u003E\n\u003Cp\u003EDe-DOSfuscator uses flare-qdb and Vivisect to hook the Dispatch function in cmd.exe and parse commands from memory. The \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-qdb\/blob\/master\/flareqdb\/scripts\/deDOSfuscator.py\u0022\u003EDe-DOSfuscator script\u003C\/a\u003E\u0026nbsp;runs in a 64-bit Python 2 interpreter and dumps commands to both the console and a log file. The script comes with the latest version of \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-qdb\u0022\u003Eflare-qdb\u003C\/a\u003E and is installed as a Python entry point named dedosfuscator.exe.\u003C\/p\u003E\n\u003Cp\u003EDe-DOSfuscator relies on the location of the non-exported Dispatch function to log commands, and its location varies per system. For convenience, if an Internet connection is available, De-DOSfuscator automatically retrieves this function\u2019s offset using Microsoft\u2019s symbol server. To allow offline use, you can supply the path to a copy of cmd.exe from your offline machine to the --getoff switch to obtain this offset. You can then supply that output as the argument to the --useoff switch in your offline machine to inform De-DOSfuscator where the function is located. Alternately, you can use De-DOSfuscator with a downloaded PDB or a local symbol cache containing the correct symbols.\u003C\/p\u003E\n\u003Cp\u003EFigure 6 demonstrates getting and using the offset in a single session. Note that for this to work in an isolated VM, you would instead specify the path to a copy of the guest\u2019s command interpreter specific to that VM.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture6.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 6: Getting and using offsets and testing De-DOSfuscator\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis works great on the BatchEncrypted script in Figure 1. Let\u2019s have a look.\u003C\/p\u003E\n\u003Ch4\u003EResults\u003C\/h4\u003E\n\u003Cp\u003EFigure 7 shows the log created by De-DOSfuscator after running XYNT.bat. Hundreds of lines of SET statements progressively build environment variables for composing further commands. Keen eyes will also note a misspelling of the endlocal command-line extension keyword.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture7.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 7: Beginning of dumped commands\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThese environment variable manipulations give way to real commands as shown in Figure 8. One of the script\u2019s first actions is to use reg.exe to check the NUMBER_OF_PROCESSORS environment variable. This analysis system only had one vCPU, which can be seen in the set \u0026quot;a=1\u0026quot; output on line 620. After this, the script executes goto del, which branches to a batch label that ultimately deletes the script and other dropped files.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture8.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 8: Anti-sandbox measure\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EThis is a batch-oriented spin on a common sandbox evasion trick. It works because many malware analysis sandboxes run with a single CPU to minimize hypervisor resources, whereas most modern systems have at least two CPU cores. Now that we can easily read the script\u2019s commands, it is trivial to circumvent this evasion by, for example, increasing the number of vCPUs available to the VM. Figure 9 shows De-DOSfuscator log after inducing the rest of the code to run.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture9.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 9: After circumventing anti-sandbox measure\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EXYNT.bat calls a dropped binary to create and start a Windows service for persistence. The largest dropped binary is a variant of the XMRig cryptocurrency miner, and many of the services and executables referenced by the script also appear to be cryptocurrency-related.\u003C\/p\u003E\n\u003Ch4\u003EHappy Easter\u003C\/h4\u003E\n\u003Cp\u003EEaster is a long way off, but I must present you with a very early Easter Egg because it is such a neat little find. During my journey through cmd.exe, I noticed a variable named fDumpParse having only one cross-reference that seemed to control an interesting behavior. The lone cross-reference and the relevant code are shown in Figure 10. Although fDumpParse is inaccessible anywhere else in the code, it controls whether a function is called to dump information about the command that has been parsed.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture10.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 10: fDumpParse evaluation and cross-refs (EDI is NULL)\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003ETo experiment with this, you can use De-DOSfuscator\u2019s --fDumpParse switch. You will then be greeted with a command prompt that is more transparent about what it has parsed. Figure 11 shows an example along with a graphical representation of the abstract syntax tree (AST) of parsed command tokens.\u003C\/p\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture11.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 11: Command interpreter with fDumpParse set\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EMicrosoft probably inserted the fDumpParse flag so developers could debug issues with cmd.exe. Unfortunately, as nifty as this is, it has drawbacks for bulk de-obfuscation:\u003C\/p\u003E\n\u003Cul style=\u0022list-style-position: inside;\u0022\u003E\n\u003Cli\u003EThis output is harder to read than plain commands, because it dumps the tree in \u003Ca href=\u0022https:\/\/en.wikipedia.org\/wiki\/Tree_traversal\u0022\u003Epreorder traversal rather than inorder\u003C\/a\u003E like it was typed.\u003C\/li\u003E\n\u003Cli\u003EOutput copied from the console may contain extraneous line breaks depending on the console host program\u2019s text wrapping behavior.\u003C\/li\u003E\n\u003Cli\u003EScrolling in the command interpreter to read or copy output can be tedious.\u003C\/li\u003E\n\u003Cli\u003EThe console buffer is limited, so not everything may be captured.\u003C\/li\u003E\n\u003Cli\u003EMalicious script authors can still use the CLS command to clear the screen and make all the fDumpParse output disappear.\u003C\/li\u003E\n\u003Cli\u003EGratuitous joining of commands with command separators (as found in XYNT.bat) yields unreadable ASTs that exceed the console width and wrap around, as in Figure 12.\u003C\/li\u003E\n\u003C\/ul\u003E\n\u003Cp\u003E\u003Cimg src=\u0022\/content\/dam\/fireeye-www\/blog\/images\/cmd-conquer\/Picture12.png\u0022\u003E\u003Cbr\u003E\n\u003Cspan class=\u0022type-XS\u0022\u003EFigure 12: fDumpParse result exceeding console width\u003C\/span\u003E\u003C\/p\u003E\n\u003Cp\u003EConsequently, fDumpParse is not ideal for de-obfuscating large, malicious batch files; however, it is still interesting and useful for de-obfuscating short scripts or one-off commands. You can get the offset De-DOSfuscator needs for offline use via --getoff and use it via --useoff, as with normal operation.\u003C\/p\u003E\n\u003Ch4\u003EWrapping Up\u003C\/h4\u003E\n\u003Cp\u003EI have given you an example of a heavily obfuscated command script and I have shared a useful tool for de-obfuscating it, along with the analytical steps that I followed to synthesize it. The \u003Ca adhocenable=\u0022false\u0022 href=\u0022https:\/\/github.com\/fireeye\/flare-qdb\/blob\/master\/flareqdb\/scripts\/deDOSfuscator.py\u0022\u003EDe-DOSfuscator script code\u003C\/a\u003E\u0026nbsp;comes with the latest version of \u003Ca href=\u0022https:\/\/github.com\/fireeye\/flare-qdb\/\u0022\u003Eflare-qdb\u003C\/a\u003E and is accessible as a script entry point (dedosfuscator.exe) when you install flare-qdb. It is my hope that this not only helps you to conveniently analyze malicious batch scripts, but also inspires you to devise your own creative ways to employ flare-qdb against malware.\u003C\/p\u003E\n",
        "jcr:lastModified": "Tue Nov 20 2018 15:53:45 GMT-0500",
        "sling:resourceType": "social\/blog\/components\/entrytext"
      }
    },
    "summary": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "text": "\u003Cp\u003ELearn how to use flare-qdb to bring \u201cscript block logging\u201d to the Windows command interpreter, and more.\u003C\/p\u003E\n",
      "jcr:lastModified": "Wed Nov 14 2018 16:42:05 GMT-0500",
      "sling:resourceType": "social\/blog\/components\/entrytextteaser"
    },
    "image": {
      "jcr:primaryType": "nt:unstructured",
      "jcr:lastModifiedBy": "adam.greenberg@fireeye.com",
      "jcr:lastModified": "Wed May 08 2019 18:25:32 GMT-0400",
      "imageRotate": "0"
    }
  }
}
